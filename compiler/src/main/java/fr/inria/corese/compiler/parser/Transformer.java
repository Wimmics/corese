package fr.inria.corese.compiler.parser;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import fr.inria.corese.sparql.triple.cst.RDFS;
import fr.inria.corese.sparql.triple.parser.*;
import fr.inria.corese.compiler.api.QueryVisitor;
import fr.inria.corese.sparql.triple.parser.Dataset;
import fr.inria.corese.sparql.triple.parser.visitor.ASTWalker;
import fr.inria.corese.sparql.compiler.java.JavaCompiler;
import fr.inria.corese.kgram.api.core.*;
import static fr.inria.corese.kgram.api.core.ExpType.NODE;
import fr.inria.corese.kgram.core.Exp;
import fr.inria.corese.kgram.core.Mapping;
import fr.inria.corese.kgram.core.Mappings;
import fr.inria.corese.kgram.core.Query;
import fr.inria.corese.kgram.core.Sorter;
import fr.inria.corese.compiler.federate.FederateVisitor;
import fr.inria.corese.compiler.eval.QuerySolver;
import static fr.inria.corese.compiler.eval.QuerySolver.SPARQL_COMPLIANT_DEFAULT;
import fr.inria.corese.compiler.eval.QuerySolverVisitor;
import fr.inria.corese.compiler.visitor.MetadataVisitor;
import fr.inria.corese.sparql.api.IDatatype;
import fr.inria.corese.sparql.exceptions.EngineException;
import fr.inria.corese.sparql.exceptions.SafetyException;
import fr.inria.corese.sparql.triple.parser.visitor.ASTParser;
import fr.inria.corese.sparql.triple.parser.visitor.Record;
import java.io.IOException;
import java.util.HashMap;

/**
 * Compiler of SPARQL AST to KGRAM Exp Query Use Corese SPARQL parser Use an
 * abstract compiler to generate target edge/node/filter implementations
 *
 * sub query compiled as distinct edge/node to avoid inappropriate type
 * inference on nodes, except variable nodes which are shared
 *
 * @author Olivier Corby, Edelweiss, INRIA 2009
 *
 */
public class Transformer implements ExpType {
  
    private static Logger logger = LoggerFactory.getLogger(Transformer.class);
    private static final String LINKED_DATA_PATH_VISITOR = 
            "fr.inria.corese.core.visitor.ldpath.LinkedDataPath";
    public static final String NL = System.getProperty("line.separator");
    public static final String ROOT = "?_kgram_";
    public static final String THIS = "?this";
    private static final String EXTENSION = Processor.KGEXTENSION;
    private static final String EXT_NAMESPACE = NSManager.KGEXT;
    private static final String EXT_NAMESPACE_QUERY = NSManager.KGEXTCONS;
    public static final String FEDERATE = NSManager.KGRAM + "federate";
    int count = 0;
    CompilerFactory fac;
    // ldscript function compiler
    private FunctionCompiler functionCompiler;
    // edge and node compiler, see CompilerKgram
    Compiler compiler;
    // QuerySolver for federated compiler 
    private QuerySolver sparql;
    // Visitor tune compiling
    // @metadata: uncertainty, @ldpath: ldpath
    // @visitor className: user defined visitor  
    private List<QueryVisitor> visit;
    // Refine std query sorter
    // corese core SorterImpl take cardinality into account
    Sorter sort;
    // use case: reuse federated visitor source selection
    private Mappings mappings;
    private ASTQuery ast;
    // Compiler to generate type checker
    Checker check;
    // table of type checker (check class/property definition)
    // not used yet
    HashMap<Edge, Query> table;
    // list of nested subquery
    ArrayList<Query> subQueryList;
    int ncount = 0, rcount = 0;
    boolean //fail = false,
            isSPARQLCompliant = SPARQL_COMPLIANT_DEFAULT,
            isSPARQL1 = true;
    // bind(exp as var) generated by compiler
    // not used 
    private boolean isUseBind = false;
    private boolean isGenerateMain = true;
    private boolean isBGP = false;
    private boolean pathType = false;
    // draft alternative interpreter not used 
    private boolean algebra = false;
    // deprecated
    String namespaces;
    // deprecated
    private String base;
    // user defined from [named] dataset
    private Dataset dataset;
    // Annotation to tune compiling and execution, e.g. @debug
    private Metadata metadata;
    // deprecated
    private BasicGraphPattern pragma;
    private int planner = Query.STD_PLAN;
    private int number = 0;

    static {
        create().init();
    }

    Transformer() {
        table = new HashMap<>();
        fac = new CompilerFacKgram();
        compiler = fac.newInstance();
        subQueryList = new ArrayList<>();
        functionCompiler = new FunctionCompiler(this);
    }

    Transformer(CompilerFactory f) {
        this();
        fac = f;
        compiler = fac.newInstance();
    }

    public static Transformer create(CompilerFactory f) {
        return new Transformer(f);
    }

    public static Transformer create() {
        return new Transformer();
    }

    /**
     * Predefined extension functions for SPARQL functions (see Processor)
     * uri() -> rq:uri
     */
    void init() {
        if (Processor.getAST() != null) {
            try {
                Query q = transform(Processor.getAST());
            } catch (EngineException ex) {
                logger.error(ex.getMessage());
            }
        }
    }

    public void set(Dataset ds) {
        if (ds != null) {
            dataset = ds;
        }
    }

    public void setMetadata(Metadata m) {
        metadata = m;
    }
    
    public void set(Sorter s) {
        sort = s;
    }
    
    List<QueryVisitor> getCreateVisitorList() {
        if (getVisitorList() == null) {
            setVisitorList(new ArrayList<>());
        }
        return getVisitorList();
    }

    public void add(QueryVisitor v) {        
        getCreateVisitorList().add(v);
    }

    public void add(List<QueryVisitor> v) {
        getCreateVisitorList().addAll(v);
    }

    public Query transform(String squery) throws EngineException {
        return transform(squery, false);
    }

    /**
     * TODO: throw  EngineException when there are undefined functions ?
     */
    public Query transform(String squery, boolean isRule) throws EngineException {
        setAST(parse(squery, isRule));
        Query q = transform(getAST());
        return q;
    }
    
    /**
     * SPARQL parser
     * parse sparql query and return AST without compiling
     */ 
    public ASTQuery parse(String squery) throws EngineException {
        return parse(squery, false);
    }
    
    public ASTQuery parse(String squery, boolean isRule) throws EngineException {
        ASTQuery ast = ASTQuery.create(squery);
        ast.setRule(isRule);
        ast.setDefaultNamespaces(namespaces);
        ast.setDefaultBase(getDefaultBase());
        ast.setSPARQLCompliant(isSPARQLCompliant);
        if (getDataset() != null) {
            // if Dataset has Context, it becomes ast Context
            ast.setDefaultDataset(getDataset());
        }
        // isLoad == true : parse Turtle document as sparql where query pattern
        // -> rdf graph considered as query graph
        boolean isLoad = getDataset()!=null && getDataset().isLoad();
        ParserSparql1.create(ast).setLoad(isLoad).parse();
        if (getDataset()!=null && getDataset().getMetadata()!=null) {
            ast.addMetadata(getDataset().getMetadata());
        }
        if (getMetadata()!=null) {
            ast.addMetadata(getMetadata());
        }
        ASTParser walk = new ASTParser(ast).configure();
        // preprocessing: @report -> service report, bnode scope checking
        ast.process(walk);
        return ast;
    }
    
    String getDefaultBase() {        
        if (getDataset() != null && getDataset().getBase() != null) {
            return getDataset().getBase();
        }
        return getBase();
    }

    /**
     * Transform outer query (not subquery)
     */
    public Query transform(ASTQuery ast) throws EngineException {
        this.setAST(ast);
        ast.setSPARQLCompliant(isSPARQLCompliant);
        if (isSPARQLCompliant) {
            // special case when there is from of from named but not both
            // std sparql is strict, corese is relax
            ast.getDataset().complete();
        }
        compiler.setAST(ast);
        annotate(ast);
        // pragma are deprecated, use annotation
        Pragma p = new Pragma(this, ast);
        if (ast.getPragma() != null) {
            p.compile();
        }
        if (getPragma() != null) {
            p.compile(getPragma());
        }

        generateMain();

        if (ast.isDescribe()) {
            // need to collect select * before compiling 
            ast.validate();
        }

        // compile describe
        ast.compile();

        // type check:
        // check scope for bind()
        ast.validate();

        // @federate <uri> -> run FederateVisitor compiler
        federate(ast);
        // visitor such as uncertainty, ldpath or user defined
        visit(ast);
        
        template(ast);

        Query q = compile(ast);
        if (ast.isFail()) {
            // Walker ASTParser detected syntax pb
            q.setCorrect(false);
        }
        q.setRule(ast.isRule());
        q.setAlgebra(isAlgebra());
        if (ast.getContext() != null) {
            q.setContext(ast.getContext());
        }
//        if (ast.getTemplateVisitor() != null) {
//            // visitor comes from ast defaultDataset   
//            // Workflow Data record visitor in Dataset 
//            // query(q, ds) -> ast.setDefaultDataset(ds)
//            q.setTemplateVisitor(ast.getTemplateVisitor()); 
//        }
        preprocessTemplateValues(q, ast);
        // compile select filters
        q = transform(q, ast);       
        getFunctionCompiler().compile(q, ast);               
        error(q, ast);               
        metadata(ast, q);
        // safety exception
        validate(ast, q);
        
        return q;
    }
    
    /**
     * Check static safety exception
     */
    void validate(ASTQuery ast, Query q) throws EngineException {
        ASTWalker walker = new ASTWalker(ast);
        ast.process(walker);
        
        if (!walker.getRecord().isEmpty()) {
            StringBuilder sb = new StringBuilder();
            for (Record rec : walker.getRecord()) {
                sb.append(rec.toString()).append(NL);
            }
            throw new SafetyException(sb.toString());
        }
    }
    
    
    public Query transform(Query q, ASTQuery ast) throws EngineException {
        compiler.setAST(ast);

        if (ast.isConstruct() || ast.isDescribe() || ast.isInsert() ) {
            construct(q, ast);
        }

        if (ast.isDelete()) {
            validate(ast.getDelete(), ast);
            Exp del = delete(ast);
            q.setDelete(del);
            q.setDelete(true);
        }

        if (ast.isUpdate()) {
            q.setUpdate(true);
        }

        // retrieve select nodes for query:
        complete(q, ast);

        having(q, ast);

        if (ast.isRule()) {
            new VisitQuery(compiler).visit(q);
        }

        q.setSort(ast.isSorted());
        if (ast.isDebug()) {
            q.setDebug(ast.isDebug());
        }
        q.setCheck(ast.isCheck());
        q.setRelax(ast.isMore());
        q.setPlanProfile(getPlanProfile());
        // type checking 
        for (Edge edge : table.keySet()) {
            q.set(edge, table.get(edge));
        }

        filters(q);
        relax(q);
        new QueryProfile(q).profile();
               
        q.setSubQueryList(subQueryList);
        if (getVisitorList() != null) {
            for (QueryVisitor v : getVisitorList()) {
                v.visit(q);
            }
        }

        return q;
    }
    
    
    void metadata(ASTQuery ast, Query q) {
        Metadata meta = ast.getMetadata();
        if (meta != null) {
            if (ast.hasMetadata(Metadata.TRACE)) {
                System.out.println(ast.toString());
            }
            if (ast.hasMetadata(Metadata.TEST)) {
                q.setTest(true);
            }
            if (ast.hasMetadata(Metadata.PARALLEL)) {
                q.setParallel(true);
            }
            if (ast.hasMetadata(Metadata.SEQUENCE)) {
                q.setParallel(false);
            }
            if (ast.hasMetadata(Metadata.UPDATE)) {
                q.setDetail(true);
            }
            if (meta.hasMetadata(Metadata.UNLOCK) || 
                    (meta.getDatatypeValue(Metadata.LOCK) != null
                    && !meta.getDatatypeValue(Metadata.LOCK).booleanValue())) {
                q.setLock(false);
            }
            if (ast.hasMetadata(Metadata.PATH_TYPE)) {
                q.setPathType(true);
            }
        }
        // @public @update event function ...
        if (QuerySolver.isVisitorable()
         && ASTExtension.getSingleton().getMetadata(QuerySolverVisitor.UPDATE, QuerySolverVisitor.UPDATE_ARITY) != null) {
            q.setDetail(true);
        } 
    }
    
    @Deprecated
    void toJava(ASTQuery ast) throws EngineException{
        if (ast.hasMetadata(Metadata.COMPILE)){
            String name = ast.getMetadata().getValue(Metadata.COMPILE);
            JavaCompiler jc = new JavaCompiler(name);
            try {
                jc.compile(ast);
                jc.write();
            } catch (IOException ex) {
                logger.error(ex.getMessage());
            }
        }
    }
    
    void visit(ASTQuery ast) {
        visitor(ast);
        if (getVisitorList() != null) {
            for (QueryVisitor v : getVisitorList()) {
                v.visit(ast);
                if (v.getMappings() != null) {
                    // federate visitor return source selection Mappings 
                    getSPARQLEngine().setMappings(v.getMappings());
                }
            }
        }
    }
    
    /**
     * Metadata => Visitor
     */
    void visitor(ASTQuery ast) {
        if (ast.hasMetadata(Metadata.METADATA)){
            add(new MetadataVisitor());
        }
        if (ast.hasMetadata(Metadata.LDPATH)) {
            ast.getMetadata().add(Metadata.VISITOR, LINKED_DATA_PATH_VISITOR);
        }
        if (ast.hasMetadata(Metadata.VISITOR)) {
            for (String name : ast.getMetadata().getValues(Metadata.VISITOR)) {
                try {
                    Class visClass = Class.forName(name);
                    Object obj = visClass.getDeclaredConstructor().newInstance();
                    if (obj instanceof QueryVisitor) {
                        add((QueryVisitor) obj);
                    }
                    else {
                        logger.error("Undefined QueryVisitor: " + name);
                    }
                } catch (Exception ex) {
                    logger.error("Undefined QueryVisitor: " + name);
                }
            }
        }
    }
    
    /**
     * use case: 
     * @federate <s1> 
     * @federate <s2> 
     * select * where { }
     * Rewrite every triple t as: service <s1> <s2> { t }
     */
    void federate(ASTQuery ast) {
        if (ast.hasMetadata(Metadata.FEDERATION) && !ast.hasMetadata(Metadata.FEDERATE)) {
            add(new FederateVisitor(getSPARQLEngine()).setMappings(getMappings()));
        }
        
        if (ast.getServiceList() != null && ast.getServiceList().size() > 1) {
            ast.defService((String) null);
            add(new FederateVisitor(getSPARQLEngine()).setMappings(getMappings()));
        }
    }

    void annotate(ASTQuery ast) {
        if (getMetadata() != null) {
            ast.addMetadata(getMetadata());
        }
        if (ast.getContext() != null) {
            context(ast);
        }
        annotateLocal(ast);
    }
    
    void context(ASTQuery ast) {
        if (ast.getContext().hasValue(Context.STL_METADATA)) {
            for (IDatatype meta : ast.getContext().get(Context.STL_METADATA).getValues()) {
                ast.getMetadata().add(meta.getLabel());
            }
        }
    }
    
    void annotateLocal(ASTQuery ast){
        if (ast.hasMetadata(Metadata.ALGEBRA)){
            // @algebra use case with @db
            setBGP(true);
            setAlgebra(true);
        }
        if (ast.hasMetadata(Metadata.PATH_TYPE)){
            setPathType(true);
        }
    }

    /**
     * when exist function xt:main(){} 
     * -> 
     * generate select (xt:main() as ?main)
     */
    void generateMain() {
        if (isGenerateMain()) {
            Expr exp = getAST().getDefine().get(Processor.XT_MAIN, 0);
            if (exp != null) {
                getAST().defSelect(new Variable(ASTQuery.MAIN_VAR),
                        getAST().createFunction(Processor.FUN_XT_MAIN));
            }
        }
    }


    /**
     * Optimize values in template Insert values in template body in case the
     * ?in variable is bound hence it is more efficient to verify values
     * according to ?in binding instead of testing values blindly use case:
     * template where { ?in a ?t EXP } values ?t { list of values } rewritten
     * as: template where { ?in a ?t values ?t { list of values } EXP }
     */
    void template(ASTQuery ast) {
        if (!ast.isTemplate()) {
            return;
        }
        fr.inria.corese.sparql.triple.parser.Exp body = ast.getBody();
        if (ast.getValues() != null
                && body.size() > 0
                && body instanceof BasicGraphPattern
                && body.get(0).isTriple()
                && !body.get(0).isFilter()) {

            Triple t = body.get(0).getTriple();

            if (bound(ast.getValues(), t)) {
                body.add(1, ast.getValues());
                ast.getValues().setMoved(true);
            }
        }
    }

    boolean bound(Values values, Triple t) {
        if (!t.getArg(1).isVariable()) {
            return false;
        }
        for (Variable var : values.getVarList()) {
            if (var.equals(t.getArg(1))) {
                return true;
            }
        }
        return false;
    }

    private void preprocessTemplateValues(Query q, ASTQuery ast) throws EngineException {
        if (ast.isTemplate()) {
            q.setTemplate(true);
            q.setProfile(ast.getProfile());
            q.setAllResult(ast.isAllResult());

            if (ast.getName() != null) {
                q.setName(ast.getName());
            }

            ast.getTemplateGroup().compile(ast);
            q.setTemplateGroup(Exp.create(FILTER, ast.getTemplateGroup()));

            Term nl = Term.function(Processor.STL_NL);
            nl.compile(ast);
            q.setTemplateNL(Exp.create(FILTER, nl));

            for (Variable var : ast.getArgList()) {
                Node node = compiler.createNode(var);
                q.defArg(node);
            }
            q.setPriority(ast.getPriority());
        }
    }
    
    void error(Query q, ASTQuery ast) throws EngineException {
        if (ast.isFail()) {
            q.setFail(true);
        }
        if (ast.isTemplate()) {
            // TODO: because template st:profile may not have been read yet ...
            return;
        }
        getFunctionCompiler().undefinedFunction(q, ast, ast.getLevel());
    }
    
    
    public void imports(Query q, String path) throws EngineException {
        getFunctionCompiler().imports(q,  q.getAST(), path);
    }
    
    public boolean getLinkedFunction(String label) throws EngineException {
        return getFunctionCompiler().getLinkedFunction(label);
    }
        
    public boolean getLinkedFunctionBasic(String label) throws EngineException {
        return getFunctionCompiler().getLinkedFunctionBasic(label);
    }
    
    public static void removeLinkedFunction() {
        FunctionCompiler.removeLinkedFunction();
    }
    
    /**
     * isDefine = true means export to Interpreter Use case: Transformation
     * st:profile does not export to Interpreter hence it uses isDefine = false
     */
    public void definePublic(ASTExtension ext, Query q, boolean isDefine) {
        getFunctionCompiler().definePublic(ext, q, isDefine);
    }
    



    void construct(Query q, ASTQuery ast) throws EngineException {
        validate(ast.getInsert(), ast);
        Exp cons = compile(ast.getInsert(), false);
        q.setConstruct(cons);
        if (ast.isInsert()) {
            q.setInsert(true);
        }
        else {
            q.setConstruct(true);
        }
        //q.setConstruct(true);
        q.setConstructNodes(cons.getNodes());
    }



    /**
     * Subquery is a construct where
     */
    Query constructQuery(ASTQuery ast) throws EngineException {
        Transformer t = Transformer.create();
        t.setAlgebra(isAlgebra());
        return t.transform(ast);
    }
    
    Query updateQuery(ASTQuery ast) throws EngineException {
        Query q = constructQuery(ast);
        return q;
    }

    /**
     * subquery is compiled using a new compiler to get fresh new nodes to
     * prevent type inference on nodes between outer and sub queries
     */
    Query compileQuery(ASTQuery ast) throws EngineException {
        // new
        Compiler save = compiler;
        compiler = fac.newInstance();
        // share variable nodes
        compiler.share(save);
        compiler.setAST(ast);

        Query q = compile(ast);
        subQueryList.add(q);
        // complete select, order by, group by
        complete(q, ast);
        having(q, ast);

        q.setRelax(ast.isMore());
        // detect query pattern to be optimized
        // use case: select (count(*) as ?c) where {?s ?p ?o}
        new QueryProfile(q).profile();
        if (save != null) {
            compiler = save;
        }

        return q;
    }
    
    
    /**
     * For query and subquery Generate a new compiler for each (sub) query in
     * order to get fresh new nodes
     */
    Query compile(ASTQuery ast) throws EngineException {        
        Exp ee = compile(ast.getBody(), false);
        Query q = Query.create(ee);
        q.setUseBind(isUseBind());
        q.setAST(ast);
        q.setService(ast.getService());
        // use same compiler
        values(q, ast);
        path(q, ast);

        return q;
    }
    
    
    /**
     * Compile AST statements into KGRAM statements Compile triple into Edge,
     * filter into Filter
     */
    Exp compile(fr.inria.corese.sparql.triple.parser.Exp query, boolean opt) throws EngineException {
        return compile(query, opt, 0);
    }

    Exp compile(fr.inria.corese.sparql.triple.parser.Exp query, boolean opt, int level) throws EngineException {
        Exp exp = null;
        int type = getType(query);
        opt = opt || isOption(type);

        switch (type) {

            case FILTER:
                exp = compileFilter(query.getFilter(), opt);
                break;

            case EDGE:
                exp = compileEdge(query.getTriple(), opt);
                break;

            case QUERY:
                ASTQuery aa = query.getAST();
                if (aa.isConstruct()) {
                    exp = constructQuery(aa);
                } 
                else if (aa.isUpdate()) {
                    exp = updateQuery(aa);
                }
                else {
                    exp = compileQuery(aa);
                }
                break;

            case BIND:
                exp = compileBind(getAST(), query.getBind());
                break;

            case SERVICE:
                exp = compileService(query.getService());
                break;

            case VALUES:
                Values val = query.getValuesExp();
                if (val.hasExpression()) {
                    // values var {unnest(exp)}
                    exp = compile(val.getBind(), opt, level);

                } else {
                    exp = compileValues(val, opt, level);
                }
                break;

            default:

                /**
                 * ************************
                 *
                 * Compile Body
                 *
                 *************************
                 */
                exp = Exp.create(cpType(type));

                for (fr.inria.corese.sparql.triple.parser.Exp ee : query.getBody()) {
                    Exp cpl = compile(ee, opt, level + 1);

                    if (cpl != null) {

                        if (cpl.isGraph() && cpl.getBind() != null) {
                            // see compileGraph()
                            exp.add(cpl.getBind());
                            cpl.setBind(null);
                        }

                        if (isJoinable(exp, ee)) {
                            join(exp, cpl, bgpType());
                        } else {
                            // add elements of AND one by one
                            exp.insert(cpl);
                        }
                    }
                }
                
                // PRAGMA: do it after loop above to have filter compiled
                // bnode scope
                query.validateBlank(getAST());
                
                exp = complete(exp, query, opt);
                
                if (isAlgebra() && exp.isBGP()){
                    // possibly join arguments
                    // deprecated
                    exp.dispatch();
                }
                
        }

        exp.setNum(incrNumber());
        return exp;
    }       

    Exp compileBind(ASTQuery ast, Binding b) throws EngineException {
        return compileBind(ast, b.getFilter(), b.getVariable());
    }

    Exp compileBind(ASTQuery ast, Expression e, Variable var) throws EngineException {
        fr.inria.corese.kgram.api.core.Filter f = compileSelect(e, ast);
        Node node = compiler.createNode(var);
        Exp exp = Exp.create(BIND);
        exp.setFilter(f);
        exp.setNode(node);
        exp.setFunctional(f.isFunctional());
        //ast.setHasFunctional(f.isFunctional());
        function(null, exp, var);
        return exp;
    }

    /**
     * Delete/Insert/Construct
     */
    Exp compile(ASTQuery ast, fr.inria.corese.sparql.triple.parser.Exp exp) throws EngineException {
        Compiler save = compiler;
        compiler = fac.newInstance();
        compiler.setAST(ast);
        Exp ee = compile(exp, false);

        if (save != null) {
            compiler = save;
        }
        return ee;
    }

    /**
     * Compile service as a subquery if it is a graph pattern and also as a subquery if it
     * already is one
     */
    Exp compileService(Service service) throws EngineException {
        Node src = compile(service.getServiceName());
        Exp node = Exp.create(NODE, src);
              
        fr.inria.corese.sparql.triple.parser.Exp body = service.get(0);
        ASTQuery aa;

        if (body.isBGP() && body.size() == 1 && body.get(0).isQuery()) {
            // service body is a subquery
            aa = body.get(0).getAST();
        } else {
            // service body is a pattern
            aa = getAST().subCreate();
            aa.setSelectAll(true);
            // PRAGMA: body must be a BGP
            aa.setBody(body);
        }
        //collect select * nodes
        aa.validate();
        Query q = compileQuery(aa);
        q.setService(true);
        q.setSilent(service.isSilent());

        Exp exp = Exp.create(SERVICE, node, q);
        exp.setSilent(service.isSilent());
        exp.setGenerated(service.isGenerated());

        if (service.getServiceList().size() > 1 || service.isGenerated()) {
            // special case for federated query
            // one service clause with several URI
            // perform merge of resut Mappings
            ArrayList<Node> list = new ArrayList<>();
            for (Atom at : service.getServiceList()) {
                Node serv = compile(at);
                list.add(serv);
            }
            exp.setNodeSet(list);
        }
        exp.setNumber(service.getNumber());
        return exp;
    }

    Query create(Exp exp) {
        Query q = Query.create(exp);
        if (sort != null) {
            q.set(sort);
        }
        return q;
    }

    Exp compileValues(Values val, boolean opt, int level) throws EngineException {
        Exp exp = compileValues(val);
        if (exp == null) {
            getAST().setFail(true);
            getAST().addErrorMessage(ASTQuery.VALUES_ERROR);
            return null;
        }
        return exp;
    }

    Exp compileValues(Values values) {
        List<Node> lNode = compileValuesNodes(values);
        Node[] nodes = getNodes(lNode);

        Mappings lMap = new Mappings();

        for (List<Constant> lVal : values.getValues()) {
            if (values.getVarList().size() != lVal.size()) {
                // error: not right number of values
                return null;
            } else {
                List<Node> list = compileValuesList(lVal);
                Mapping map = create(nodes, list);
                lMap.add(map);
            }
        }

        Exp bind = Exp.create(VALUES);
        bind.setNodeList(lNode);
        bind.setMappings(lMap);
        return bind;
    }
    
    // compile final values: select where {} values {}
    void values(Query q, ASTQuery ast){
        if (ast.getValues() == null) {
            return;
        }
        compileValues(q, ast);
        if (q.getValues() != null && isAlgebra()){
            if (q.getBody().size() == 0){
                q.setBody(q.getValues());
            }
            else {
                Exp exp = Exp.create(JOIN, Exp.create(BGP, q.getValues()), q.getBody());
                q.setBody(Exp.create(BGP, exp));
            }
        }
    }
    

    
    void compileValues(Query q, ASTQuery ast) {
        Exp bind = compileValues(ast.getValues());
        if (bind == null) {
            q.setCorrect(false);
            q.addError(Message.VALUES_ERROR);
        } else {
            q.setValues(bind);
            if (ast.getValues().isMoved()) {
                //q.setTemplateMappings(bind.getMappings());
                q.getValues().setPostpone(true);
            } 
//            else {
//                q.setMappings(bind.getMappings());
//                q.setBindingNodes(bind.getNodeList());
//            }
        }
    }

    List<Node> compileValuesNodes(Values values) {
        List<Node> lNode = new ArrayList<>();

        for (Variable var : values.getVarList()) {
            Node qNode = compiler.createNode(var);
            lNode.add(qNode);
        }

        return lNode;
    }

    Node[] getNodes(List<Node> lNode) {
        Node[] nodes = new Node[lNode.size()];
        lNode.toArray(nodes);
        return nodes;
    }

    /**
     * values (x y) { (x1 v1) }
     * compile x1 v1 as Node values
     */
    List<Node> compileValuesList(List<Constant> lVal) {
        List<Node> lNode = new ArrayList<>();
        
        for (Constant val : lVal) {
            Node node = null;
            if (val != null) {
                if (val.isTriple() && val.getTriple()!=null) {
                    Edge edge = compiler.compile(val.getTriple(), true, true);
                    if (edge.hasReferenceNode()) {
                        node = edge.getReferenceNode();
                    }
                }
                else {
                    node = compiler.createNode(val);
                }
            }
            lNode.add(node);
        }
        return lNode;
    }

    Mapping create(Node[] lNode, List<Node> lVal) {
        Node[] nodes = new Node[lVal.size()];
        lVal.toArray(nodes);
        return Mapping.safeCreate(lNode, nodes);
    }

    Exp construct(ASTQuery ast) throws EngineException {
        return compile(ast, ast.getInsert());
    }

    Exp delete(ASTQuery ast) throws EngineException {
        return compile(ast, ast.getDelete());
    }

    public ASTQuery getAST() {
        return ast;
    }

    public Compiler getCompiler() {
        return compiler;
    }

    void complete(Query qCurrent, ASTQuery ast) throws EngineException {
        qCurrent.collect();
        select(qCurrent, ast);
        qCurrent.setOrderBy(orderBy(qCurrent, ast));
        qCurrent.setGroupBy(groupBy(qCurrent, ast));

        qCurrent.setDistinct(ast.isDistinct());
        // generate a DISTINCT(?x) for distinct ?x
        qCurrent.distinct();
        qCurrent.setFrom(nodes(ast.getActualFrom()));
        qCurrent.setNamed(nodes(ast.getActualNamed()));

        // sort from uri to speed up verification at query time 
        // Producer may use dichotomy
        qCurrent.setFrom(sort(qCurrent.getFrom()));
        qCurrent.setNamed(sort(qCurrent.getNamed()));

        qCurrent.setLimit(Math.min(ast.getMaxResult(), ast.getMaxProjection()));
        qCurrent.setOffset(ast.getOffset());

        qCurrent.setGraphNode(createNode());

        if (qCurrent.isCorrect()) {
            // check semantics of select vs aggregates and group by
            boolean correct = qCurrent.check();
            if (!correct) {
                qCurrent.setCorrect(false);
            } else {
                qCurrent.setCorrect(ast.isCorrect());
            }
        }

    }

    void path(Query q, ASTQuery ast) throws EngineException {
        if (ast.getRegexTest().size() > 0) {
            Node node = compiler.createNode(Variable.create(THIS));
            q.setPathNode(node);
        }
        for (Expression test : ast.getRegexTest()) {
            // ?x c:isMemberOf[?this != <inria>] + ?y
            fr.inria.corese.kgram.api.core.Filter f = compile(test);
            q.addPathFilter(f);
        }
    }

    void having(Query q, ASTQuery ast) throws EngineException {
        if (ast.getHaving() != null) {
            fr.inria.corese.kgram.api.core.Filter having = compileSelect(ast.getHaving(), ast);
            q.setHaving(Exp.create(FILTER, having));
        }
    }

    /**
     * Retrieve/Compute the nodes for the select of qCurrent Query Nodes may be
     * std Node or select fun() as ?var node in this last case we may create a
     * node from scratch for ?var This function is called - once for each
     * subquery - once for the global query
     */
    List<Exp> select(Query qCurrent, ASTQuery ast) throws EngineException {
        List<Exp> select = new ArrayList<>();
        // list of query nodes created for variables in filter that need
        // an outer node value
        List<Node> lNodes = new ArrayList<>();

        if (ast.isSelectAll() || ast.isConstruct() || ast.isInsert()) {
            // select *
            // get nodes from query nodes and edges
            select =  toExp(qCurrent.selectNodesFromPattern());  
        }

        qCurrent.setSelectFun(select);

        for (Variable var : ast.getSelectVar()) {
            // retrieve var node from query
            String varName = var.getName();
            Node node = getNode(qCurrent, var);
            Exp exp = Exp.create(NODE, node);

            // process filter if any
            Expression ee = ast.getExpression(varName);

            if (ee != null) {
                // select fun() as var
                fr.inria.corese.kgram.api.core.Filter f = compileSelect(ee, ast);

                if (f != null) {
                    // select fun() as var
                    exp.setFilter(f);
                    // create node in lNodes for var in filter f if needed
                    checkFilterVariables(qCurrent, f, select, lNodes);
                    function(qCurrent, exp, var);
                    aggregate(qCurrent, exp, ee, select);
                }
            }

            // TODO: check var in select * to avoid duplicates

            add(select, exp);

            if (lNodes.contains(exp.getNode())) {
                // undef variable of former exp is current exp as var
                lNodes.remove(exp.getNode());
            }
        }

        for (Node node : lNodes) {
            // additional variables for exp in select (exp as var)
            Exp exp = Exp.create(NODE, node);
            exp.status(true);
            select.add(exp);
        }

        qCurrent.setSelect(selectNodeList(qCurrent));
        
        return select;
    }
    
        // compute select node list from list Exp(node, exp)
    List<Node> selectNodeList(Query q) {
        List<Node> list = new ArrayList<>();
        
        for (Exp ee : q.getSelectFun()) {
            if (! list.contains(ee.getNode())) {
                list.add(ee.getNode());
            }
        }
        return list;
    }
      
    
     List<Exp> toExp(List<Node> lNode) {
        List<Exp> lExp = new ArrayList<>();
        for (Node node : lNode) {
            lExp.add(Exp.create(NODE, node));
        }
        return lExp;
    }

    /**
     * select * (exp as var) if var is already in select *, add exp to var
     */
    void add(List<Exp> select, Exp exp) {
        boolean found = false;

        for (Exp e : select) {
            if (e.getNode().same(exp.getNode())) {
                if (exp.getFilter() != null) {
                    e.setFilter(exp.getFilter());
                }
                found = true;
                break;
            }
        }

        if (!found) {
            select.add(exp);
        }
    }

    void aggregate(Query qCurrent, Exp exp, Expression ee, List<Exp> list) throws EngineException {
        if (exp.isAggregate()) {
            // process  min(?l, groupBy(?x, ?y))
            extendAggregate(qCurrent, exp, ee);
        } else {
            // check if exp has a variable that is computed by a previous aggregate
            // if yes, exp is also considered as an aggregate
            checkAggregate(exp, list);
        }
    }

    /**
     * use case: select (count(?x) as ?c) (?c + ?c as ?d) check that ?c is an
     * aggregate variable set ?c + ?c as aggregate
     */
    void checkAggregate(Exp exp, List<Exp> select) {
        List<String> list = exp.getFilter().getVariables();

        for (Exp ee : select) {
            if (ee.isAggregate()) {
                String name = ee.getNode().getLabel();
                if (list.contains(name)) {
                    exp.setAggregate(true);
                    break;
                }
            }
        }
    }

    /**
     * min(?l, groupBy(?x, ?y))
     */
    void extendAggregate(Query qCurrent, Exp exp, Expression ee) throws EngineException {
        if (ee.isAggregate() && ee.arity() > 1) {
            Expression g = ee.getArg(ee.arity() - 1);
            if (g.oper() == ExprType.GROUPBY) {
                List<Exp> ob = orderBy(qCurrent, g.getArgs(), getAST());
                exp.setExpGroupBy(ob);
            }
        }
    }

    Node getNode(Query qCurrent, Variable var) {
        Node node = null;
        if (qCurrent != null) {
            node = getProperAndSubSelectNode(qCurrent, var.getName());
        }
        if (node == null) {
            node = compiler.createNode(var);
        }
        return node;
    }

    ASTQuery getAST(Query q) {
        return q.getAST();
    }

    Node getProperAndSubSelectNode(Query q, String name) {
        Node node;
        if (Query.test) {
            node = q.getSelectNodes(name);
        } else {
            node = q.getProperAndSubSelectNode(name);
        }
        return node;
    }

    /**
     * If filter isFunctionnal() create it's query node list
     */
    void function(Query qCurrent, Exp exp, Variable var) {
        if (exp.getFilter().isFunctional()) {
            if (var.getVariableList() != null) {
                // sql() as (?x, ?y)
                for (Variable vv : var.getVariableList()) {
                    Node qNode = getNode(qCurrent, vv);
                    exp.addNode(qNode);
                }
            } else {
                exp.addNode(exp.getNode());
            }
        }
    }

    /**
     * Check that variables in filter have corresponding proper node otherwise
     * create a Node to import value from outer query
     *
     * @param query
     * @param f
     */
    void checkFilterVariables(Query query, fr.inria.corese.kgram.api.core.Filter f, List<Exp> select, List<Node> lNodes) {
        switch (f.getExp().oper()) {
            // do not create Node for local variables
            case ExprType.PACKAGE:
            case ExprType.STL_DEFINE:
            case ExprType.FUNCTION:
            case ExprType.LET:
            //return;
            }

        List<String> lVar = f.getVariables();
        for (String name : lVar) {
            Node node = getProperAndSubSelectNode(query, name);
            if (node == null) {
                if (!containsExp(select, name) && !containsNode(lNodes, name)) {
                    node = compiler.createNode(name);
                    lNodes.add(node);
                }
            }
        }
    }

    boolean containsExp(List<Exp> lExp, String name) {
        for (Exp exp : lExp) {
            if (exp.getNode().getLabel().equals(name)) {
                return true;
            }
        }
        return false;
    }

    boolean containsNode(List<Node> lNode, String name) {
        for (Node node : lNode) {
            if (node.getLabel().equals(name)) {
                return true;
            }
        }
        return false;
    }

    List<Exp> orderBy(Query qCurrent, ASTQuery ast) throws EngineException {
        List<Exp> order = orderBy(qCurrent, ast.getSort(), ast);
        if (order.size() > 0) {
            int n = 0;
            for (boolean b : ast.getReverse()) {
                order.get(n).status(b);
                n++;
            }
        }
        return order;
    }

    List<Exp> groupBy(Query qCurrent, ASTQuery ast) throws EngineException {
        List<Exp> list = orderBy(qCurrent, ast.getGroupBy(), ast);
        qCurrent.setConnect(ast.isConnex());
        return list;
    }

    List<Exp> orderBy(Query qCurrent, List<Expression> input, ASTQuery ast) throws EngineException {
        List<Exp> list = new ArrayList<Exp>();

        for (Expression ee : input) {
            if (ee.isVariable()) {
                Exp exp = qCurrent.getSelectExp(ee.getName());
                Node node;

                if (exp != null) {
                    node = exp.getNode();
                } else {
                    node = getProperAndSubSelectNode(qCurrent, ee.getName());
                }

                if (node == null) {
                    ast.addErrorMessage(ASTQuery.ORDER_GROUP_UNDEFINED, ee);
                    node = compiler.createNode(ee.getName());
                }
                Exp e = Exp.create(NODE, node);

                if (exp != null && exp.isAggregate()) {
                    // order by ?count
                    e.setAggregate(true);
                }
                list.add(e);
            } else {
                // order by fun(?x)
                // TODO: check rewrite fun() as var
                fr.inria.corese.kgram.api.core.Filter f = compile(ee);
                Node node = createNode();
                Exp exp = Exp.create(NODE, node);
                exp.setFilter(f);
                list.add(exp);
            }
        }
        return list;
    }

    /**
     * Create a fake query node
     */
    Node createNode() {
        String name = getVarName();
        Node node = compiler.createNode(name);
        return node;
    }

    String getVarName() {
        return ROOT + count++;
    }

    List<Node> nodes(List<Constant> from) {
        List<Node> nodes = new ArrayList<>();
        for (Constant cst : from) {
            nodes.add(new NodeImpl(cst));
        }
        return nodes;
    }

    List<Node> sort(List<Node> list) {
        Collections.sort(list, new Comparator<Node>() {
            public int compare(Node o1, Node o2) {
                return o1.compare(o2);
            }
        });
        return list;
    }


    
    /**
     * Add Exp rst into this exp 
     * If this exp is BGP{e1 .. en}
     * return: BGP{JOIN{BGP{e1 .. en} rst}}
     */
    void join(Exp exp, Exp rst, int type) {
        if (exp.isBGPAnd() && exp.size() > 0) { 
            Exp fst = exp.get(0);
            if (exp.size() == 1) {
                if (!fst.isBGPAnd()) { 
                    fst = Exp.create(type, fst);
                }
            } else {
                fst = Exp.create(type);
                for (Exp ee : exp) {
                    fst.add(ee);
                }
            }
            Exp body = Exp.create(JOIN, fst, rst);
            exp.getExpList().clear();
            exp.add(body);
        } 
        else {
            exp.add(rst);
        }
    }
    
    int bgpType(){
       return (isBGP()) ? BGP : AND;
    }
    
    Exp compileEdge(Triple t, boolean opt) throws EngineException {
        if (isPathType() && t.isType() && t.getObject().isConstant()) {
            return compilePathType(t);
        } else {
            return basicCompileEdge(t);
        }
    }

    Exp basicCompileEdge(Triple t) throws EngineException {
        Edge r = compiler.compile(t, getAST().isInsertData());
        Exp exp = Exp.create(EDGE, r);
        if (t.isXPath()) {
            // deprecated ?x xpath() ?y
            exp.setType(EVAL);
            fr.inria.corese.kgram.api.core.Filter xpath = compiler.compile(t.getXPath());
            exp.setFilter(xpath);
        } else if (t.isPath()) {
            path(t, exp);
        } else if (getAST().isCheck()) {
            check(t, r);
        }

        return exp;
    }
    

    void path(Triple tt, Exp exp) throws EngineException {
        exp.setType(PATH);
        Expression regex = tt.getRegex();
        if (regex == null) {
            // deprecated: there may be a match($path, regex)
        } else {
            regex.compile(getAST());
            exp.setRegex(regex);
        }
        exp.setObject(tt.getMode());
    }

    /**
     *
     * Generate rdf:type/rdfs:subClassOf*
     */
    Exp compilePathType(Triple t) throws EngineException {
        Expression re = Term.create(Term.RE_SEQ,
                getAST().createQName(RDFS.rdftype),
                Term.function(Term.STAR, getAST().createQName(RDFS.rdfssubclassof)));
        Triple p = getAST().createPath(t.getSubject(), re, t.getObject());
        return basicCompileEdge(p);
    }


    /**
     * Complete compilation
     */
    Exp complete(Exp exp, fr.inria.corese.sparql.triple.parser.Exp srcexp, boolean opt) throws EngineException {
        // complete path (deprecated)
        path(exp);

        switch (getType(srcexp)) {

            case MINUS:
                // add a fake graph node 
                // use case:
                // graph ?g {PAT minus {PAT}}
                // deprecated
                exp.setNode(createNode());
                break;

            case GRAPH:
                compileGraph(getAST(), exp, srcexp.getNamedGraph());
                break;
                
        }

        return exp;
    }

    /**
     * graph kg:describe BGP -> bind(kg:describe() as ?g) graph ?g BGP
     */
    @Deprecated
    Exp compileGraph(ASTQuery ast, Exp exp, Source srcexp) throws EngineException {
        Atom at = srcexp.getSource();
        Atom nat = getSrc(at);
        Exp gr = compileGraph(exp, nat);

        if (at != nat) {
            // generate bind(kg:describe() as var)
            Term fun = ast.createFunction(ast.createQName(EXTENSION), at.getConstant());
            Exp b = compileBind(ast, fun, nat.getVariable());
            gr.setBind(b);
        }

        return gr;
    }

    Atom getSrc(Atom at) {
        if (at.isConstant() && isSystemGraph(at.getConstant().getLabel())) {
            at = Variable.create(getVarName());
        }
        return at;
    }

    boolean isSystemGraph(String cst) {
        return (cst.startsWith(EXT_NAMESPACE)
                || cst.startsWith(EXT_NAMESPACE_QUERY));
    }

    Exp compileGraph(Exp exp, Atom at) {
        Node src = compiler.createNode(at, getAST().isInsertData());
        // create a NODE kgram expression for graph ?g
        Exp node = Exp.create(NODE, src);
        Exp gnode = Exp.create(GRAPHNODE, node);
        exp.add(0, gnode);
        return exp;
    }

    Exp compileFilter(Expression ee, boolean opt) throws EngineException {
        List<fr.inria.corese.kgram.api.core.Filter> qvec = compiler.compileFilter(ee);
        Exp exp;

        if (qvec.size() == 1) {
            exp = Exp.create(FILTER, qvec.get(0));
            compileExist(qvec.get(0).getExp(), opt);
        } else {
            exp = Exp.create(AND);
            for (fr.inria.corese.kgram.api.core.Filter qm : qvec) {
                Exp f = Exp.create(FILTER, qm);
                compileExist(qm.getExp(), opt);
                exp.add(f);
            }
        }
        return exp;
    }

    Node compile(Atom at) {
        return compiler.createNode(at);
    }

    /**
     * Rewrite fun() as ?var in exp Compile exists {}
     */
    fr.inria.corese.kgram.api.core.Filter compile(Expression exp) throws EngineException {
        fr.inria.corese.kgram.api.core.Filter f = compiler.compile(exp);
        compileExist(f.getExp(), false);
        return f;
    }

    /**
     * Do not rewrite fun() as var
     */
    fr.inria.corese.kgram.api.core.Filter compileSelect(Expression exp, ASTQuery ast) throws EngineException {
        fr.inria.corese.kgram.api.core.Filter f = exp.compile(ast);
        compileExist(f.getExp(), false);
        return f;
    }

    /**
     * filter(exist {PAT})
     */
    void compileExist(Expr exp, boolean opt) throws EngineException {
        if (exp.oper() == ExprType.EXIST) {
            Term term = (Term) exp;
            Exp pat = compile(term.getExist(), opt);
            term.setPattern(pat);
        } 
        //else 
        {
            for (Expr ee : exp.getExpList()) {
                compileExist(ee, opt);
            }
        }
    }

    /**
     * Assign pathLength($path) <= 10 to its path
     */
    void path(Exp exp) throws EngineException {
        for (Exp ee : exp) {
            if (ee.isPath()) {
                for (Exp ff : exp) {
                    if (ff.isFilter()) {
                        processPath(ee, ff);
                    }
                }
                if (ee.getRegex() == null) {
                    String name = ee.getEdge().getEdgeLabel();
                    Term star = Term.function(Term.STAR, Constant.create(name));
                    star.compile(getAST());
                    ee.setRegex(star);
                }
            }
        }
    }

    /**
     * Check if filter f concerns path e for regex, mode, min, max store them in
     * Exp e
     */
    void processPath(Exp exp, Exp ef) throws EngineException {
        fr.inria.corese.kgram.api.core.Filter f = ef.getFilter();
        Edge e = exp.getEdge();
        Node n = e.getEdgeVariable();

        List<String> lVar = f.getVariables();
        if (lVar.size() == 0) {
            return;
        }
        if (n == null) {
            return;
        }
        if (!n.getLabel().equals(lVar.get(0))) {
            return;
        }

        Regex regex = compiler.getRegex(f);

        if (regex != null && exp.getRegex() == null) {
            // mode: i d s
            String mode = compiler.getMode(f);
            if (mode != null) {
                exp.setObject(mode);
                if (mode.indexOf("i") != -1) {
                    regex = Term.function(Term.SEINV, ((Expression) regex));
                }
            }
            ((Expression) regex).compile(getAST());
            exp.setRegex(regex);
        } else {
            if (compiler.getMin(f) != -1) {
                exp.setMin(compiler.getMin(f));
            }
            if (compiler.getMax(f) != -1) {
                exp.setMax(compiler.getMax(f));
            }
        }
    }

    boolean isOption(int type) {
        switch (type) {
            case OPTION:
            case OPTIONAL:
            case UNION:
            case MINUS:
                return true;

            default:
                return false;
        }
    }

    int getType(fr.inria.corese.sparql.triple.parser.Exp query) {
        if (query.isFilter()) {
            return FILTER;
        } else if (query.isTriple()) {
            return EDGE;
        } else if (query.isUnion()) {
            return UNION;
        } else if (query.isJoin()) {
            return JOIN;
        } else if (query.isOption()) {
            return OPTION;
        } else if (query.isOptional()) {
            return OPTIONAL;
        } else if (query.isMinus()) {
            return MINUS;
        } else if (query.isGraph()) {
            return GRAPH;
        } else if (query.isService()) {
            return SERVICE;
        } else if (query.isQuery()) {
            return QUERY;
        } else if (query.isBind()) {
            return BIND;
        } else if (query.isValues()) {
            return VALUES;
        } else if (query.isBGP()) {
            return bgpType();
        } else if (query.isAnd()) {
            return AND;
        } else {
            return EMPTY;
        }
    }

    int cpType(int type) {
        switch (type) {
            default:
                return type;
        }
    }

    /**
     * ************************************
     */
    /**
     * Generate a complementary Query that checks: definition of class/property
     */
    void check(Triple tt, Edge edge) {
        ASTQuery aa = new Checker(getAST()).check(tt);
        if (aa != null) {
            Transformer tr = Transformer.create();
            Query qq;
            try {
                qq = tr.transform(aa);
                add(edge, qq);
            } catch (EngineException ex) {
                java.util.logging.Logger.getLogger(Transformer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
            }
        }
    }

    void add(Edge edge, Query query) {
        table.put(edge, query);
    }

    /**
     * Generate predefined system filters that may be used by kgram Filters are
     * stored in a table, we can have several predefined filters pathNode()
     * generate a blank node for each path (PathFinder)
     */
    void filters(Query q) throws EngineException {
        ASTQuery ast =  q.getAST();
        Term t = Term.function(Processor.PATHNODE);
        q.setFilter(Query.PATHNODE, t.compile(ast));
    }

    @Deprecated
    void relax(Query q) {
        ASTQuery ast =  q.getAST();
        for (Expression exp : ast.getRelax()) {
            if (exp.isConstant()) {
                Constant p = exp.getConstant();
                Node n = compiler.createNode(p);
                q.addRelax(n);
            }
        }
    }

    
    /**
     * check unbound variable in construct/insert/delete
     */
    boolean validate(fr.inria.corese.sparql.triple.parser.Exp exp, ASTQuery ast) {
        boolean suc = true;

        for (fr.inria.corese.sparql.triple.parser.Exp ee : exp.getBody()) {
            boolean b = true;
            
            if (ee.isTriple()) {
                b = validate(ee.getTriple(), ast);
            } else if (ee.isGraph()) {
                b = validate((Source) ee, ast);
            } else {
                b = validate(ee, ast);
            }

            suc = suc && b;
        }

        return suc;
    }

    boolean validate(Source exp, ASTQuery ast) {
        boolean suc = validate(exp.getSource(), ast);

        for (fr.inria.corese.sparql.triple.parser.Exp ee : exp.getBody()) {
            suc = validate(ee, ast) && suc;
        }

        return suc;
    }

    boolean validate(Atom at, ASTQuery ast) {
        if (at.isVariable()
                && !at.isBlankNode()
                && !ast.isSelectAllVar(at.getVariable())) {
            ast.addErrorMessage(ASTQuery.VARIABLE_UNDEFINED, ast.getUpdateTitle(), at.getLabel());
            return false;
        }

        return true;
    }

    boolean validate(Triple t, ASTQuery ast) {
        boolean suc = validate(t.getSubject(), ast);
        suc = validate(t.getObject(), ast) && suc;

        Variable var = t.getVariable();
        if (var != null) {
            suc = validate(var, ast) && suc;
        }

        return suc;
    }


    public Dataset getDataset() {
        return dataset;
    }

    public void setDataset(Dataset dataset) {
        this.dataset = dataset;
    }

    /**
     * Must exp ee be joined with preceding statements ?
     */
    private boolean isJoinable(Exp exp, fr.inria.corese.sparql.triple.parser.Exp ee) {
        return (isAlgebra()) ? isJoinableAlgebra(exp, ee) : isJoinableBasic(ee) ;        
    }
    
    private boolean isJoinableBasic(fr.inria.corese.sparql.triple.parser.Exp ee) {
        return ee.isBGP() || ee.isUnion() || ee.isGraph();
    }
    
    private boolean isJoinableAlgebra(Exp exp, fr.inria.corese.sparql.triple.parser.Exp ee) {
        return ee.isBGP() || ee.isUnion();
    }

    public int getPlanProfile() {
        return planner;
    }

    public void setPlanProfile(int planner) {
        this.planner = planner;
    }

    public boolean isUseBind() {
        return isUseBind;
    }

   public void setUseBind(boolean isUseBind) {
        this.isUseBind = isUseBind;
    }

   public boolean isGenerateMain() {
        return isGenerateMain;
    }

   public void setGenerateMain(boolean isGenerateMain) {
        this.isGenerateMain = isGenerateMain;
    }

   public QuerySolver getSPARQLEngine() {
        return sparql;
    }

   public void setSPARQLEngine(QuerySolver sparql) {
        this.sparql = sparql;
    }

//   public List<Atom> getServiceList() {
//        return serviceList;
//    }
//
//   public void setServiceList(List<Atom> serviceList) {
//        this.serviceList = serviceList;
//    }

   public FunctionCompiler getFunctionCompiler() {
        return functionCompiler;
    }

   public void setFunctionCompiler(FunctionCompiler functionCompiler) {
        this.functionCompiler = functionCompiler;
    }

   
    public int getNumber() {
        return number;
    }
    
    int incrNumber() {
        return number++;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public boolean isAlgebra() {
        return algebra;
    }

    public void setAlgebra(boolean algebra) {
        this.algebra = algebra;
    }

    public boolean isBGP() {
        return isBGP;
    }

    public void setBGP(boolean BGP) {
        this.isBGP = BGP;
    }
    
    public boolean isPathType() {
        return pathType;
    }

    public void setPathType(boolean pathType) {
        this.pathType = pathType;
    }
    
    public BasicGraphPattern getPragma() {
        return pragma;
    }

    public String getBase() {
        return base;
    }

    public void setAST(ASTQuery ast) {
        this.ast = ast;
    }

    public List<QueryVisitor> getVisitorList() {
        return visit;
    }

    public void setVisitorList(List<QueryVisitor> visit) {
        this.visit = visit;
    }
    
    
    public boolean isSPARQLCompliant() {
        return isSPARQLCompliant;
    }

    public void setSPARQLCompliant(boolean b) {
        isSPARQLCompliant = b;
    }

    public void setNamespaces(String ns) {
        namespaces = ns;
    }

    public void setPragma(BasicGraphPattern p) {
        pragma = p;
    }

    public void setBase(String ns) {
        base = ns;
    }

    public void setSPARQL1(boolean b) {
        isSPARQL1 = b;
    }

    public Mappings getMappings() {
        return mappings;
    }

    public void setMappings(Mappings mappings) {
        this.mappings = mappings;
    }

    public Metadata getMetadata() {
        return metadata;
    }
    

}
