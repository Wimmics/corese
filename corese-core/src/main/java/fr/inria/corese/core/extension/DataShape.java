package fr.inria.corese.core.extension;

import fr.inria.corese.sparql.api.IDatatype;
import fr.inria.corese.core.query.PluginImpl;
import fr.inria.corese.sparql.datatype.DatatypeMap;


/**
 * Code generated by LDScript Java compiler for SPARQL extension functions 
 * Compiler is run by annotation: 
 * @compile <fr.inria.corese.extension.DataShape> 
 * @path    </home/me/src/> 
 * functions are called with: 
 * prefix java: <function://fr.inria.corese.extension.DataShape> 
 * java:fun(?x) 
 *
 * Olivier Corby - Wimmics Inria I3S - Thu Aug 24 11:28:17 CEST 2017 
 */
public class DataShape extends PluginImpl { 

static final IDatatype _cst_0 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/dsmain");
static final IDatatype _cst_1 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#bnodeid");
static final IDatatype _cst_2 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/null");
static final IDatatype _cst_3 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/dsconstraint");
static final IDatatype _cst_4 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/dspath");
static final IDatatype _cst_5 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/test");
static final IDatatype _cst_6 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/dscore");
static final IDatatype _cst_7 = DatatypeMap.newInstance("define");
static final IDatatype _cst_8 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#class");
static final IDatatype _cst_9 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#ClassConstraintComponent");
static final IDatatype _cst_10 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#datatype");
static final IDatatype _cst_11 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#DatatypeConstraintComponent");
static final IDatatype _cst_12 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#nodeKind");
static final IDatatype _cst_13 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#NodeKindConstraintComponent");
static final IDatatype _cst_14 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#minCount");
static final IDatatype _cst_15 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MinCountConstraintComponent");
static final IDatatype _cst_16 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#maxCount");
static final IDatatype _cst_17 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MaxCountConstraintComponent");
static final IDatatype _cst_18 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#minExclusive");
static final IDatatype _cst_19 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MinExclusiveConstraintComponent");
static final IDatatype _cst_20 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#minInclusive");
static final IDatatype _cst_21 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MinInclusiveConstraintComponent");
static final IDatatype _cst_22 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#maxExclusive");
static final IDatatype _cst_23 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MaxExclusiveConstraintComponent");
static final IDatatype _cst_24 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#maxInclusive");
static final IDatatype _cst_25 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MaxInclusiveConstraintComponent");
static final IDatatype _cst_26 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#minLength");
static final IDatatype _cst_27 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MinLengthConstraintComponent");
static final IDatatype _cst_28 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#maxLength");
static final IDatatype _cst_29 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#MaxLengthConstraintComponent");
static final IDatatype _cst_30 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#pattern");
static final IDatatype _cst_31 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#PatternConstraintComponent");
static final IDatatype _cst_32 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#languageIn");
static final IDatatype _cst_33 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#LanguageInConstraintComponent");
static final IDatatype _cst_34 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#uniqueLang");
static final IDatatype _cst_35 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#UniqueLangConstraintComponent");
static final IDatatype _cst_36 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#equals");
static final IDatatype _cst_37 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#EqualsConstraintComponent");
static final IDatatype _cst_38 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#disjoint");
static final IDatatype _cst_39 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#DisjointConstraintComponent");
static final IDatatype _cst_40 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#lessThan");
static final IDatatype _cst_41 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#LessThanConstraintComponent");
static final IDatatype _cst_42 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#lessThanOrEquals");
static final IDatatype _cst_43 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#LessThanOrEqualsConstraintComponent");
static final IDatatype _cst_44 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#not");
static final IDatatype _cst_45 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#NotConstraintComponent");
static final IDatatype _cst_46 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#and");
static final IDatatype _cst_47 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#AndConstraintComponent");
static final IDatatype _cst_48 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#or");
static final IDatatype _cst_49 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#OrConstraintComponent");
static final IDatatype _cst_50 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#xone");
static final IDatatype _cst_51 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#XoneConstraintComponent");
static final IDatatype _cst_52 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#node");
static final IDatatype _cst_53 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#NodeConstraintComponent");
static final IDatatype _cst_54 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#qualifiedValueShape");
static final IDatatype _cst_55 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#QualifiedValueShapeConstraintComponent");
static final IDatatype _cst_56 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#qualifiedMinCount");
static final IDatatype _cst_57 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent");
static final IDatatype _cst_58 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#qualifiedMaxCount");
static final IDatatype _cst_59 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent");
static final IDatatype _cst_60 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#qualifiedValueShapeDisjoint");
static final IDatatype _cst_61 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#qualifiedValueShapeDisjointConstraintComponent");
static final IDatatype _cst_62 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#closed");
static final IDatatype _cst_63 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#ClosedConstraintComponent");
static final IDatatype _cst_64 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#hasValue");
static final IDatatype _cst_65 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#HasValueConstraintComponent");
static final IDatatype _cst_66 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#in");
static final IDatatype _cst_67 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#InConstraintComponent");
static final IDatatype _cst_68 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#sparql");
static final IDatatype _cst_69 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#SPARQLConstraintComponent");
static final IDatatype _cst_70 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#message");
static final IDatatype _cst_71 = DatatypeMap.newInstance("?s");
static final IDatatype _cst_72 = DatatypeMap.newInstance("?p");
static final IDatatype _cst_73 = DatatypeMap.newInstance("?o");
static final IDatatype _cst_74 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#severity");
static final IDatatype _cst_75 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#Violation");
static final IDatatype _cst_76 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nconstruct {_:bn_1 rdf:type sh:ValidationReport . \n_:bn_1 sh:conforms true . }\nwhere\n{}\n\n");
static final IDatatype _cst_77 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/trace");
static final IDatatype _cst_78 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/graph");
static final IDatatype _cst_79 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#classsh");
static final IDatatype _cst_80 = DatatypeMap.newInstance("?name");
static final IDatatype _cst_81 = DatatypeMap.newInstance("?value");
static final IDatatype _cst_82 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#def");
static final IDatatype _cst_83 = DatatypeMap.newResource("http://ns.inria.fr/sparql-template/turtle");
static final IDatatype _cst_84 = DatatypeMap.newResource("http://ns.inria.fr/sparql-extension/graph");
static final IDatatype _cst_85 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?shape ?pp ?q ?path \nwhere\n{graph ?shape {values (?q ){\n(rdf:rest )\n(sh:inversePath )\n(sh:alternativePath )\n(sh:zeroOrMorePath )\n(sh:oneOrMorePath )\n(sh:zeroOrOnePath )\n}\n\n?pp ?q ?path . }}\n\n");
static final IDatatype _cst_86 = DatatypeMap.newInstance("?shape");
static final IDatatype _cst_87 = DatatypeMap.newInstance("?pp");
static final IDatatype _cst_88 = DatatypeMap.newInstance("?res");
static final IDatatype _cst_89 = DatatypeMap.newInstance("?q");
static final IDatatype _cst_90 = DatatypeMap.newInstance("?path");
static final IDatatype _cst_91 = DatatypeMap.newResource("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest");
static final IDatatype _cst_92 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#sequence");
static final IDatatype _cst_93 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?s ?p (aggregate(?o) as ?l) \nwhere\n{?s ?p ?o . }\n\n");
static final IDatatype _cst_94 = DatatypeMap.newInstance("?s");
static final IDatatype _cst_95 = DatatypeMap.newInstance("?p");
static final IDatatype _cst_96 = DatatypeMap.newInstance("?l");
static final IDatatype _cst_97 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#path");
static final IDatatype _cst_98 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?o ?p (aggregate(?s) as ?l) \nwhere\n{?s ?p ?o . }\n\n");
static final IDatatype _cst_99 = DatatypeMap.newInstance("?o");
static final IDatatype _cst_100 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?s ?p (count(*) as ?c) \nwhere\n{?s ?p ?o . }\n\n");
static final IDatatype _cst_101 = DatatypeMap.newInstance("?c");
static final IDatatype _cst_102 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?o ?p (count(*) as ?c) \nwhere\n{?s ?p ?o . }\n\n");
static final IDatatype _cst_103 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?shape ?pp (aggregate(java:path(?shape, ?e)) as ?l) \nwhere\n{graph ?shape {?pp (rdf:rest)*/rdf:first ?e . }}\n\n");
static final IDatatype _cst_104 = DatatypeMap.newInstance("select ?_b0 ?shape ?o ?lv  where { bind (exists {values (?o ){\n(UNDEF )\n}\n\ngraph ?shape {?lv (rdf:rest)*/rdf:first ?v . \nfilter ((?o = ?v) && ((!(isLiteral(?o))) || (datatype(?o) = datatype(?v)))) }} as ?_b0) } values (?shape ?o ?lv ) { (UNDEF UNDEF UNDEF ) }");
static final IDatatype _cst_105 = DatatypeMap.newInstance("?lv");
static final IDatatype _cst_106 = DatatypeMap.newInstance("?_b0");
static final IDatatype _cst_107 = DatatypeMap.newInstance("select ?_b1 ?shape ?o ?c  where { bind (exists {?o rdf:type/(rdfs:subClassOf)* ?c . } as ?_b1) } values (?shape ?o ?c ) { (UNDEF UNDEF UNDEF ) }");
static final IDatatype _cst_108 = DatatypeMap.newInstance("?c");
static final IDatatype _cst_109 = DatatypeMap.newInstance("?_b1");
static final IDatatype _cst_110 = DatatypeMap.newInstance("select ?_b2 ?shape ?o ?lv  where { bind (exists {values (?o ){\n(UNDEF )\n}\n\nbind(lang(?o) as ?lang)\nfilter bound(?lang) \ngraph ?shape {?lv (rdf:rest)*/rdf:first ?l . \nfilter langMatches(?lang, ?l) }} as ?_b2) } values (?shape ?o ?lv ) { (UNDEF UNDEF UNDEF ) }");
static final IDatatype _cst_111 = DatatypeMap.newInstance("?_b2");
static final IDatatype _cst_112 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#IRI");
static final IDatatype _cst_113 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#BlankNodeOrIRI");
static final IDatatype _cst_114 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#IRIOrLiteral");
static final IDatatype _cst_115 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#Literal");
static final IDatatype _cst_116 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#BlankNodeOrLiteral");
static final IDatatype _cst_117 = DatatypeMap.newResource("http://www.w3.org/ns/shacl#BlankNode");
static final IDatatype _cst_118 = DatatypeMap.newInstance("?oper");
static final IDatatype _cst_119 = DatatypeMap.newInstance("pathmap");
static final IDatatype _cst_120 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?sh ?s ?shape ?suc ?fail (SUM(?val) as ?count) \nwhere\n{graph ?shape {?sh (rdf:rest)*/rdf:first ?cst . }\nbind(java:testShapeCore(?shape, ?cst, ?s) as ?hasShape)\nbind(if(bound(?hasShape), if(?hasShape, ?suc, ?fail), 'error') as ?val)}\n\nvalues (?s ?suc ?fail ){\n(UNDEF UNDEF UNDEF )\n}\n");
static final IDatatype _cst_121 = DatatypeMap.newInstance("?sh");
static final IDatatype _cst_122 = DatatypeMap.newInstance("?suc");
static final IDatatype _cst_123 = DatatypeMap.newInstance("?fail");
static final IDatatype _cst_124 = DatatypeMap.newInstance("?count");
static final IDatatype _cst_125 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nconstruct {?bnode rdf:type sh:ValidationReport . \n?bnode sh:result ?r . \n?bnode sh:conforms false . \n?r rdf:type sh:ValidationResult . \n?r sh:resultSeverity ?sev . \n?r sh:focusNode ?foc . \n?r sh:focusNodeDetail ?focDetail . \n?r sh:resultPath ?pathDetail . \n?r sh:value ?oo . \n?r sh:valueDetail ?valueDetail . \n?r sh:resultMessage ?mes . \n?r sh:sourceConstraintComponent ?def . \n?r sh:sourceShape ?sh . }\nwhere\n{bind(uuid() as ?r)\ngraph ?shape {bind(java:severity(?sh) as ?sev)\nbind(java:message(?sh) as ?m)\nbind(if(bound(?m), ?m, concat('Fail at: ', st:apply-templates-with(st:turtle, ?sh))) as ?mes)\nbind(coalesce(java:isdefby(?name), ?name) as ?def)\nbind(java:value(?p) as ?pp)\nbind(java:value(?o) as ?oo)\nbind(if(bound(?pp), java:graph(?pp), error()) as ?pathDetail)}\nbind(java:graphbnode(?foc) as ?focDetail)\nbind(if(bound(?oo), java:graphbnode(?oo), error()) as ?valueDetail)\nbind(java:bnodeid() as ?bnode)}\n\nvalues (?name ?sh ?shape ?foc ?p ?o ){\n(UNDEF UNDEF UNDEF UNDEF UNDEF UNDEF )\n}\n");
static final IDatatype _cst_126 = DatatypeMap.newInstance("?name");
static final IDatatype _cst_127 = DatatypeMap.newInstance("?foc");
static final IDatatype _cst_128 = DatatypeMap.newInstance("prefix cos: <http://www.inria.fr/acacia/corese#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix java: <function://fr.inria.corese.extension.DataShape.>\nprefix sh: <http://www.w3.org/ns/shacl#>\nprefix st: <http://ns.inria.fr/sparql-template/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix doc: <http://w3c.github.io/data-shapes/shacl/#>\nprefix xt: <http://ns.inria.fr/sparql-extension/>\nprefix fun: <http://www.w3.org/ns/shacl#>\nselect ?sh ?s ?p ?o ?shape ?suc ?fail (SUM(?val) as ?count) \nwhere\n{graph ?shape {?sh (rdf:rest)*/rdf:first ?cst .  optional {?cst ((sh:property|sh:path)|sh:closed) ?prop . }}\nbind(if(bound(?prop), java:testShapeCore(?shape, ?cst, ?o), java:hasPath(?shape, ?cst, false, ?s, ?p, ?o)) as ?hasShape)\nbind(if(bound(?hasShape), if(?hasShape, ?suc, ?fail), 'error') as ?val)}\n\nvalues (?s ?suc ?fail ?p ?o ){\n(UNDEF UNDEF UNDEF UNDEF UNDEF )\n}\n");

public IDatatype main() {
  return pack(DatatypeMap.newInstance("main", "http://www.w3.org/2001/XMLSchema#string"), _cst_0);
}

public IDatatype bnodeid() {
  IDatatype bnode = coalesce(getPluginTransform().cget(_cst_1, _cst_1), _cst_2);
  if (bnode.eq(_cst_2).booleanValue()) {
    return getPluginTransform().cset(_cst_1, _cst_1, bnode());
  }
  else {
    return bnode;
  }
}

public IDatatype constraint() {
  return pack(DatatypeMap.newInstance("constraint", "http://www.w3.org/2001/XMLSchema#string"), _cst_3);
}

public IDatatype path() {
  return pack(DatatypeMap.newInstance("path", "http://www.w3.org/2001/XMLSchema#string"), _cst_4);
}

public IDatatype bnodeid2() {
  return coalesce(getPluginTransform().get(_cst_1), getPluginTransform().set(_cst_1, bnode()));
}

public IDatatype test() {
  return getPluginTransform().get(_cst_5, DatatypeMap.TRUE);
}

public IDatatype starter() {
  return init();
}

public IDatatype core() {
  return pack(DatatypeMap.newInstance("core", "http://www.w3.org/2001/XMLSchema#string"), _cst_6);
}

public IDatatype init() {
  return map(_cst_7, def());
}

public IDatatype def() {
  IDatatype list = DatatypeMap.newList(DatatypeMap.newList(_cst_8, _cst_9), DatatypeMap.newList(_cst_10, _cst_11), DatatypeMap.newList(_cst_12, _cst_13), DatatypeMap.newList(_cst_14, _cst_15), DatatypeMap.newList(_cst_16, _cst_17), DatatypeMap.newList(_cst_18, _cst_19), DatatypeMap.newList(_cst_20, _cst_21), DatatypeMap.newList(_cst_22, _cst_23), DatatypeMap.newList(_cst_24, _cst_25), DatatypeMap.newList(_cst_26, _cst_27), DatatypeMap.newList(_cst_28, _cst_29), DatatypeMap.newList(_cst_30, _cst_31), DatatypeMap.newList(_cst_32, _cst_33), DatatypeMap.newList(_cst_34, _cst_35), DatatypeMap.newList(_cst_36, _cst_37), DatatypeMap.newList(_cst_38, _cst_39), DatatypeMap.newList(_cst_40, _cst_41), DatatypeMap.newList(_cst_42, _cst_43), DatatypeMap.newList(_cst_44, _cst_45), DatatypeMap.newList(_cst_46, _cst_47), DatatypeMap.newList(_cst_48, _cst_49), DatatypeMap.newList(_cst_50, _cst_51), DatatypeMap.newList(_cst_52, _cst_53), DatatypeMap.newList(_cst_54, _cst_55), DatatypeMap.newList(_cst_56, _cst_57), DatatypeMap.newList(_cst_58, _cst_59), DatatypeMap.newList(_cst_60, _cst_61), DatatypeMap.newList(_cst_62, _cst_63), DatatypeMap.newList(_cst_64, _cst_65), DatatypeMap.newList(_cst_66, _cst_67), DatatypeMap.newList(_cst_68, _cst_69));
  return list;
}

public IDatatype message(IDatatype sh) {
  for (IDatatype _for_1 : edge(sh, _cst_70).getValueList()) {
    IDatatype s = gget(_for_1, _cst_71, DatatypeMap.ZERO);
    IDatatype p = gget(_for_1, _cst_72, DatatypeMap.ONE);
    IDatatype o = gget(_for_1, _cst_73, DatatypeMap.TWO);
    return o;
  }
  return error();
  
}

public IDatatype severity(IDatatype sh) {
  for (IDatatype _for_0 : edge(sh, _cst_74).getValueList()) {
    IDatatype s = gget(_for_0, _cst_71, DatatypeMap.ZERO);
    IDatatype p = gget(_for_0, _cst_72, DatatypeMap.ONE);
    IDatatype o = gget(_for_0, _cst_73, DatatypeMap.TWO);
    return o;
  }
  return _cst_75;
  
}

public IDatatype success(IDatatype b) {
  if (b.booleanValue()) {
    IDatatype g = kgram(_cst_76);
    getPluginTransform().visit(_cst_77, _cst_78, g);
  }
  else {
    self(DatatypeMap.TRUE);
  }
  return DatatypeMap.TRUE;
  
}

public IDatatype graphbnode(IDatatype var) {
  if (isBlank(var).booleanValue()) {
    return graph(var);
  }
  else {
    return error();
  }
}

public IDatatype clean(IDatatype q) {
  if (q.eq(_cst_8).booleanValue()) {
    return _cst_79;
  }
  else {
    return q;
  }
}

public IDatatype define(IDatatype def) {
  IDatatype name = gget(def, _cst_80, DatatypeMap.ZERO);
  IDatatype value = gget(def, _cst_81, DatatypeMap.ONE);
  getPluginTransform().cset(_cst_82, name, value);
  return DatatypeMap.TRUE;
  
}

public IDatatype graph(IDatatype var) {
  if (isBlank(var).booleanValue()) {
    return strdt(getPluginTransform().transform(DatatypeMap.FALSE, _cst_83, var), _cst_84);
  }
  else {
    return var;
  }
}

public IDatatype isdefby(IDatatype name) {
  return getPluginTransform().cget(_cst_82, name);
}

public IDatatype value(IDatatype v) {
  if (v.eq(_cst_2).booleanValue()) {
    return error();
  }
  else {
    return v;
  }
}

public IDatatype optimize(IDatatype shape, IDatatype sh) {
  return DatatypeMap.TRUE;
}

public IDatatype disjoint(IDatatype l1, IDatatype l2) {
  for (IDatatype x : l1.getValueList()) {
    if (member(x, l2).booleanValue()) {
      return DatatypeMap.FALSE;
    }
    else {
      self(DatatypeMap.TRUE);
    }
  }
  return DatatypeMap.TRUE;
  
}

public IDatatype path(IDatatype shape, IDatatype pp) {
  if (isURI(pp).booleanValue()) {
    return pp;
  }
  else {
    IDatatype _let_13 = kgram(_cst_85, _cst_86, shape, _cst_87, pp);
    IDatatype res = gget(_let_13, _cst_88, DatatypeMap.ZERO);
    if (not(bound(res)).booleanValue()) {
      return error();
    }
    else {
      IDatatype q = gget(res, _cst_89, DatatypeMap.ZERO);
      IDatatype path = gget(res, _cst_90, DatatypeMap.ONE);
      if (not(bound(q)).booleanValue()) {
        return error();
      }
      else if (q.eq(_cst_91).booleanValue()) {
        return list(_cst_92, listsh(shape, pp));
      }
      else {
        return list(q, path(shape, path));
      }
    }
  }
}

public IDatatype predicate(IDatatype s, IDatatype p) {
  IDatatype _let_11 = get(kgram(_cst_93, _cst_94, s, _cst_95, p), DatatypeMap.ZERO);
  IDatatype l = gget(_let_11, _cst_96, DatatypeMap.ZERO);
  return l;
}

public IDatatype equal(IDatatype l1, IDatatype l2) {
  if (size(l1).neq(size(l2)).booleanValue()) {
    return DatatypeMap.FALSE;
  }
  else {
    for (IDatatype x : l1.getValueList()) {
      if (not(member(x, l2)).booleanValue()) {
        return DatatypeMap.FALSE;
      }
      else {
        self(DatatypeMap.TRUE);
      }
    }
  }
  return DatatypeMap.TRUE;
  
}

public IDatatype datatype(IDatatype o, IDatatype d) {
  if (isLiteral(o).booleanValue()) {
    return and(datatype(o).eq(d), isWellFormed(o));
  }
  else {
    return DatatypeMap.FALSE;
  }
}

public IDatatype pack(IDatatype test, IDatatype name) {
  if (test().booleanValue()) {
    return concat(DatatypeMap.newInstance("/user/corby/home/AAData/sttl/datashape/", "http://www.w3.org/2001/XMLSchema#string"), test);
  }
  else {
    return name;
  }
}

public IDatatype getPath2(IDatatype shape, IDatatype p) {
  return coalesce(getPluginTransform().cget(_cst_97, p), getPluginTransform().cset(_cst_97, p, path(shape, p)));
}

public IDatatype maxCount(IDatatype s, IDatatype m) {
  return s.le(m);
}

public IDatatype inverse(IDatatype o, IDatatype p) {
  IDatatype _let_12 = get(kgram(_cst_98, _cst_99, o, _cst_95, p), DatatypeMap.ZERO);
  IDatatype l = gget(_let_12, _cst_96, DatatypeMap.ZERO);
  return l;
}

public IDatatype count(IDatatype s, IDatatype p) {
  IDatatype _let_2 = get(kgram(_cst_100, _cst_94, s, _cst_95, p), DatatypeMap.ZERO);
  IDatatype c = gget(_let_2, _cst_101, DatatypeMap.ZERO);
  return c;
}

public IDatatype invCount(IDatatype o, IDatatype p) {
  IDatatype _let_3 = get(kgram(_cst_102, _cst_99, o, _cst_95, p), DatatypeMap.ZERO);
  IDatatype c = gget(_let_3, _cst_101, DatatypeMap.ZERO);
  return c;
}

public IDatatype minCount(IDatatype s, IDatatype m) {
  return s.ge(m);
}

public IDatatype getPath(IDatatype shape, IDatatype p) {
  IDatatype res = coalesce(getPluginTransform().cget(_cst_97, p), _cst_2);
  if (res.eq(_cst_2).booleanValue()) {
    return getPluginTransform().cset(_cst_97, p, path(shape, p));
  }
  else {
    return res;
  }
}

public IDatatype listsh(IDatatype shape, IDatatype pp) {
  IDatatype _let_10 = get(kgram(_cst_103, _cst_86, shape, _cst_87, pp), DatatypeMap.ZERO);
  IDatatype l = gget(_let_10, _cst_96, DatatypeMap.ZERO);
  return l;
}

public IDatatype xone(IDatatype or, IDatatype s, IDatatype shape) {
  return bool(or, s, shape, DatatypeMap.ONE, DatatypeMap.ZERO).eq(DatatypeMap.ONE);
}

public IDatatype path(IDatatype shape, IDatatype s, IDatatype p) {
  return path(shape, s, getPath(shape, p), DatatypeMap.FALSE);
}

public IDatatype maxLength(IDatatype shape, IDatatype s, IDatatype m) {
  return and(not(isBlank(s)), coalesce(strlen(s).le(m), DatatypeMap.FALSE));
}

public IDatatype maxInclusive(IDatatype shape, IDatatype o, IDatatype m) {
  return o.le(m);
}

public IDatatype hasValue(IDatatype shape, IDatatype s, IDatatype v) {
  return s.eq(v);
}

public IDatatype minInclusive(IDatatype shape, IDatatype o, IDatatype m) {
  return o.ge(m);
}

public IDatatype pathProperty(IDatatype s, IDatatype p, IDatatype inv) {
  if (inv.booleanValue()) {
    return inverse(s, p);
  }
  else {
    return predicate(s, p);
  }
}

public IDatatype or(IDatatype or, IDatatype s, IDatatype shape) {
  return bool(or, s, shape, DatatypeMap.ONE, DatatypeMap.ZERO).gt(DatatypeMap.ZERO);
}

public IDatatype maxCount(IDatatype s, IDatatype p, IDatatype m) {
  return count(s, p).le(m);
}

public IDatatype testShapeCore(IDatatype shape, IDatatype sh, IDatatype s) {
  return getPluginTransform().transform(DatatypeMap.TRUE, core(), shape, sh, DatatypeMap.FALSE, s);
}

public IDatatype minExclusive(IDatatype shape, IDatatype o, IDatatype m) {
  return o.gt(m);
}

public IDatatype and(IDatatype and, IDatatype s, IDatatype shape) {
  return bool(and, s, shape, DatatypeMap.ZERO, DatatypeMap.ONE).eq(DatatypeMap.ZERO);
}

public IDatatype minCount(IDatatype s, IDatatype p, IDatatype m) {
  return count(s, p).ge(m);
}

public IDatatype in(IDatatype shape, IDatatype o, IDatatype lv) {
  return gget(kgram(_cst_104, _cst_86, shape, _cst_99, o, _cst_105, lv), _cst_106);
}

public IDatatype classsh(IDatatype shape, IDatatype o, IDatatype c) {
  return gget(kgram(_cst_107, _cst_86, shape, _cst_99, o, _cst_108, c), _cst_109);
}

public IDatatype languageIn(IDatatype shape, IDatatype o, IDatatype lv) {
  return gget(kgram(_cst_110, _cst_86, shape, _cst_99, o, _cst_105, lv), _cst_111);
}

public IDatatype node(IDatatype shape, IDatatype o, IDatatype cst) {
  return testShapeCore(shape, cst, o);
}

public IDatatype datatype(IDatatype shape, IDatatype o, IDatatype d) {
  return datatype(o, d);
}

public IDatatype qualifiedShape(IDatatype subject, IDatatype shape, IDatatype qsh) {
  return testShapeCore(shape, qsh, subject);
}

public IDatatype minLength(IDatatype shape, IDatatype s, IDatatype m) {
  return and(not(isBlank(s)), coalesce(strlen(s).ge(m), DatatypeMap.FALSE));
}

public IDatatype nodeKind(IDatatype shape, IDatatype value, IDatatype kind) {
  return or(or(and(isURI(value), in(kind, DatatypeMap.newList(_cst_112, _cst_113, _cst_114))), and(isLiteral(value), in(kind, DatatypeMap.newList(_cst_115, _cst_116, _cst_114)))), and(isBlank(value), in(kind, DatatypeMap.newList(_cst_117, _cst_113, _cst_116))));
}

public IDatatype property(IDatatype shape, IDatatype o, IDatatype cst) {
  return hasShape(shape, cst, DatatypeMap.TRUE, o);
}

public IDatatype maxExclusive(IDatatype shape, IDatatype o, IDatatype m) {
  return o.lt(m);
}

public IDatatype safe(IDatatype shape, IDatatype sh, IDatatype suc) {
  return suc;
}

public IDatatype hasShape(IDatatype shape, IDatatype sh, IDatatype vis, IDatatype ls) {
  return getPluginTransform().transform(DatatypeMap.TRUE, core(), shape, sh, vis, ls);
}

public IDatatype sequence(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  if (inv.booleanValue()) {
    return seqlist(shape, s, reverse(p), inv);
  }
  else {
    return seqlist(shape, s, p, inv);
  }
}

public IDatatype seqlist(IDatatype shape, IDatatype s, IDatatype lp, IDatatype inv) {
  if (size(lp).eq(DatatypeMap.ZERO).booleanValue()) {
    return list(s);
  }
  else {
    IDatatype l = path(shape, s, first(lp), inv);
    IDatatype res = list();
    for (IDatatype e : l.getValueList()) {
      res = merge(res, seqlist(shape, e, rest(lp), inv));
    }
    return res;
    
  }
}

public IDatatype path(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  if (isURI(p).booleanValue()) {
    return pathProperty(s, p, inv);
  }
  else {
    IDatatype oper = gget(p, _cst_118, DatatypeMap.ZERO);
    IDatatype path = gget(p, _cst_90, DatatypeMap.ONE);
    return funcall(oper, shape, s, path, inv);
  }
}

public IDatatype inversePath(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  return path(shape, s, p, not(inv));
}

public IDatatype pathmap(IDatatype l, IDatatype shape, IDatatype s, IDatatype inv) {
  return path(shape, s, l, inv);
}

public IDatatype zeroOrOnePath(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  IDatatype l = path(shape, s, p, inv);
  if (member(s, l).booleanValue()) {
    return l;
  }
  else {
    return cons(s, l);
  }
}

public IDatatype oneOrMorePath(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  return rec(shape, s, p, list(), inv);
}

public IDatatype report(IDatatype name, IDatatype s, IDatatype suc, IDatatype vis) {
  if (vis.booleanValue()) {
    getPluginTransform().visit(name, s, suc);
  }
  else {
    self(DatatypeMap.TRUE);
  }
  return DatatypeMap.TRUE;
  
}

public IDatatype alternativePath(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  IDatatype l = get(p, DatatypeMap.ONE);
  return merge(maplist(_cst_119, l, shape, s, inv));
}

public IDatatype hasConstraint(IDatatype shape, IDatatype sh, IDatatype vis, IDatatype s) {
  return getPluginTransform().transform(DatatypeMap.TRUE, constraint(), shape, sh, vis, s);
}

public IDatatype zeroOrMorePath(IDatatype shape, IDatatype s, IDatatype p, IDatatype inv) {
  return rec(shape, s, p, list(s), inv);
}

public IDatatype functioncall(IDatatype q, IDatatype shape, IDatatype s, IDatatype m) {
  return funcall(clean(q), shape, s, m);
}

public IDatatype or(IDatatype or, IDatatype s, IDatatype p, IDatatype o, IDatatype shape) {
  return bool(or, s, p, o, shape, DatatypeMap.ONE, DatatypeMap.ZERO).gt(DatatypeMap.ZERO);
}

public IDatatype xone(IDatatype or, IDatatype s, IDatatype p, IDatatype o, IDatatype shape) {
  return bool(or, s, p, o, shape, DatatypeMap.ONE, DatatypeMap.ZERO).eq(DatatypeMap.ONE);
}

public IDatatype rec(IDatatype shape, IDatatype s, IDatatype p, IDatatype res, IDatatype inv) {
  IDatatype l = path(shape, s, p, inv);
  if (size(l).eq(DatatypeMap.ZERO).booleanValue()) {
    return res;
  }
  else {
    for (IDatatype e : l.getValueList()) {
      if (not(member(e, res)).booleanValue()) {
        add(res, e);
        rec(shape, e, p, res, inv);
        
      }
      else {
        self(DatatypeMap.TRUE);
      }
    }
    return res;
    
  }
}

public IDatatype hasPath(IDatatype shape, IDatatype sh, IDatatype vis, IDatatype s, IDatatype p) {
  return getPluginTransform().transform(DatatypeMap.TRUE, path(), shape, sh, vis, s, p);
}

public IDatatype path(IDatatype shape, IDatatype sh, IDatatype vis, IDatatype s, IDatatype p) {
  return getPluginTransform().transform(DatatypeMap.TRUE, path(), shape, sh, vis, s, p);
}

public IDatatype bool(IDatatype sh, IDatatype s, IDatatype shape, IDatatype suc, IDatatype fail) {
  IDatatype _let_9 = get(kgram(_cst_120, _cst_121, sh, _cst_94, s, _cst_86, shape, _cst_122, suc, _cst_123, fail), DatatypeMap.ZERO);
  IDatatype count = gget(_let_9, _cst_124, DatatypeMap.ZERO);
  return count;
}

public IDatatype and(IDatatype and, IDatatype s, IDatatype p, IDatatype o, IDatatype shape) {
  return bool(and, s, p, o, shape, DatatypeMap.ZERO, DatatypeMap.ONE).eq(DatatypeMap.ZERO);
}

public IDatatype report(IDatatype name, IDatatype sh, IDatatype shape, IDatatype foc, IDatatype suc, IDatatype vis) {
  if (and(vis, not(suc)).booleanValue()) {
    result(name, sh, shape, foc, _cst_2, _cst_2);
    getPluginTransform().visit(name, foc, suc);
    
  }
  else {
    self(DatatypeMap.TRUE);
  }
  return DatatypeMap.TRUE;
  
}

public IDatatype hasPath(IDatatype shape, IDatatype sh, IDatatype vis, IDatatype s, IDatatype p, IDatatype o) {
  return getPluginTransform().transform(DatatypeMap.TRUE, path(), shape, sh, vis, s, p, o);
}

public IDatatype result(IDatatype name, IDatatype sh, IDatatype shape, IDatatype foc, IDatatype p, IDatatype o) {
  IDatatype g = kgram(_cst_125, _cst_126, name, _cst_121, sh, _cst_86, shape, _cst_127, foc, _cst_95, p, _cst_99, o);
  getPluginTransform().visit(_cst_77, _cst_78, g);
  return DatatypeMap.TRUE;
  
}

public IDatatype result2(IDatatype name, IDatatype sh, IDatatype shape, IDatatype foc, IDatatype s, IDatatype p, IDatatype o) {
  return DatatypeMap.TRUE;
}

public IDatatype bool(IDatatype sh, IDatatype s, IDatatype p, IDatatype o, IDatatype shape, IDatatype suc, IDatatype fail) {
  IDatatype _let_8 = get(kgram(_cst_128, _cst_121, sh, _cst_94, s, _cst_95, p, _cst_99, o, _cst_86, shape, _cst_122, suc, _cst_123, fail), DatatypeMap.ZERO);
  IDatatype count = gget(_let_8, _cst_124, DatatypeMap.ZERO);
  return count;
}

public IDatatype report(IDatatype name, IDatatype sh, IDatatype shape, IDatatype foc, IDatatype p, IDatatype o, IDatatype suc, IDatatype vis) {
  if (and(vis, not(suc)).booleanValue()) {
    result(name, sh, shape, foc, p, o);
    getPluginTransform().visit(name, foc, suc);
    
  }
  else {
    self(DatatypeMap.TRUE);
  }
  return DatatypeMap.TRUE;
  
}

}
