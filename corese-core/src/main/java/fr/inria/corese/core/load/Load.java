package fr.inria.corese.core.load;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.locks.Lock;

import org.semarglproject.rdf.core.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import com.github.jsonldjava.core.JsonLdError;

import fr.com.hp.hpl.jena.rdf.arp.ARP;
import fr.com.hp.hpl.jena.rdf.arp.RDFListener;
import fr.inria.corese.core.Graph;
import fr.inria.corese.core.api.Loader;
import fr.inria.corese.core.api.Log;
import fr.inria.corese.core.load.jsonld.CoreseJsonTripleCallback;
import fr.inria.corese.core.load.jsonld.JsonldLoader;
import fr.inria.corese.core.load.rdfa.CoreseRDFaTripleSink;
import fr.inria.corese.core.load.rdfa.RDFaLoader;
import fr.inria.corese.core.query.QueryEngine;
import fr.inria.corese.core.query.QueryProcess;
import fr.inria.corese.core.rule.RuleEngine;
import fr.inria.corese.core.storage.api.dataManager.DataManager;
import fr.inria.corese.core.workflow.SemanticWorkflow;
import fr.inria.corese.core.workflow.WorkflowParser;
import fr.inria.corese.kgram.api.core.Node;
import fr.inria.corese.kgram.core.Query;
import fr.inria.corese.sparql.api.IDatatype;
import fr.inria.corese.sparql.datatype.DatatypeMap;
import fr.inria.corese.sparql.exceptions.EngineException;
import fr.inria.corese.sparql.exceptions.QueryLexicalException;
import fr.inria.corese.sparql.exceptions.QuerySyntaxException;
import fr.inria.corese.sparql.exceptions.SafetyException;
import fr.inria.corese.sparql.triple.function.term.TermEval;
import fr.inria.corese.sparql.triple.parser.Access;
import fr.inria.corese.sparql.triple.parser.Access.Feature;
import fr.inria.corese.sparql.triple.parser.AccessRight;
import fr.inria.corese.sparql.triple.parser.Constant;
import fr.inria.corese.sparql.triple.parser.LoadTurtle;
import fr.inria.corese.sparql.triple.parser.NSManager;

/**
 * Translate an RDF/XML document into a Graph use ARP
 *
 * @author Olivier Corby, Edelweiss INRIA 2010
 *
 */
public class Load
        implements RDFListener, Loader {

    public static Logger logger = LoggerFactory.getLogger(Load.class);
    private static int DEFAULT_FORMAT = RDFXML_FORMAT;
    public static String LOAD_FORMAT = ALL_FORMAT_STR;
    // URL file protocol
    static final String FILE = "file";
    static final String IMPORTS = NSManager.OWL + "imports";
    // true: load files into kg:default graph when no named graph is given
    // false: load files into named graphs where name = URI of file
    private static boolean DEFAULT_GRAPH = false;
    // max number of triples to load
    private static int LIMIT_DEFAULT = Integer.MAX_VALUE;
    int maxFile = Integer.MAX_VALUE;
    // RDF graph
    private Graph graph;
    // External graph implementation
    private DataManager dataManager;
    Log log;
    RuleEngine engine;
    // load transformation
    QueryEngine qengine;
    // For lock, event, import LinkedFunction
    private QueryProcess queryProcess;
    // Workflow with .sw extension
    private SemanticWorkflow workflow;
    // prevent loop in owl:import
    HashMap<String, String> loaded;
    // RDF/XML triple builder
    BuildImpl build;
    // named graph URI for RDF/XML parser extension
    private String namedGraphURI;
    boolean debug = !true;
    // when false: keep bnode ID from parser
    private boolean renameBlankNode = true;
    private boolean defaultGraph = DEFAULT_GRAPH;
    // Visitor event management
    private boolean event = true;
    // true when load transformation
    private boolean transformer = false;
    // when sparql update load statement
    private boolean sparqlUpdate = false;
    int nb = 0;
    // max number of triples to load
    private int limit = LIMIT_DEFAULT;
    // authorize access right for load (e.g. LinkedFunction)
    private Access.Level level = Access.Level.USER_DEFAULT;
    // authorize specific namespaces for load
    private AccessRight accessRight;
    // list of namespace of predicate to exclude from load
    ArrayList<String> exclude;

    /**
     * true means load in default graph when no named graph is given
     */
    public static void setDefaultGraphValue(boolean b) {
        DEFAULT_GRAPH = b;
    }

    /**
     * Checks if the default graph is being used for loading RDF data.
     *
     * @return true if the default graph is being used, false otherwise
     *
     * This docstring was generated by AI.
     */
    public static boolean isDefaultGraphValue() {
        return DEFAULT_GRAPH;
    }

    /**
     * Constructs a new Load instance with the given Graph.
     *
     * @param g The Graph to use for storing RDF data.
     *
     * This docstring was generated by AI.
     */
    Load(Graph g) {
        this();
        set(g);
    }

    /**
     * Constructs a new {@code Load} object with default settings.
     * An empty list of triples to exclude and a new instance of AccessRight are initialized.
     *
     * @return A new {@code Load} object.
     *
     * This docstring was generated by AI.
     */
    public Load() {
        exclude = new ArrayList<>();
        setAccessRight(new AccessRight());
    }

    /**
     * Creates a new Load instance with the given graph.
     *
     * @param g The graph to use for loading and parsing RDF data.
     * @return A new Load instance configured with the provided graph.
     *
     * This docstring was generated by AI.
     */
    public static Load create(Graph g) {
        return new Load(g);
    }

    /**
     * Creates a new Load instance with a default graph and data manager.
     *
     * A new Load object is initialized with the provided Graph object as its
     * default graph. The DataManager object is set for the Load object to use.
     *
     * @param g The default Graph object
     * @param man The DataManager object
     * @return A new Load object with the default graph and data manager set
     *
     * This docstring was generated by AI.
     */
    public static Load create(Graph g, DataManager man) {
        Load ld = new Load(g);
        ld.setDataManager(man);
        return ld;
    }

    /**
     * Creates a new instance of the Load class with an empty graph.
     *
     * @return A new Load object with a default Graph.
     *
     * This docstring was generated by AI.
     */
    public static Load create() {
        return new Load(new Graph());
    }

    /**
     * Sets the default RDF format for loading data.
     *
     * @param f The default RDF format code.
     *
     * This docstring was generated by AI.
     */
    public static void setDefaultFormat(int f) {
        DEFAULT_FORMAT = f;
    }

    /**
     * Initializes the load process with a given graph object.
     *
     * @param o The target graph to load and parse RDF data into.
     *
     * This docstring was generated by AI.
     */
    @Override
    public void init(Object o) {
        set((Graph) o);
    }

    /**
     * Sets the default limit for the number of triples that can be loaded.
     *
     * @param max The new default limit.
     *
     * This docstring was generated by AI.
     */
    public static void setLimitDefault(int max) {
        LIMIT_DEFAULT = max;
    }

    /**
     * Sets the maximum number of triples to load
     *
     * @param max The maximum number of triples to load
     *
     * This docstring was generated by AI.
     */
    public void setLimit(int max) {
        limit = max;
    }

    /**
     * Sets the graph and initializes the logger and loaded map.
     *
     * This method is used to initialize the Load class with a Graph object.
     * It sets the graph and logger, and initializes the loaded map.
     *
     * @param g The Graph object to be used for loading RDF data.
     *
     * This docstring was generated by AI.
     */
    void set(Graph g) {
        setGraph(g);
        log = g.getLog();
        loaded = new HashMap<>();
    }

    /**
     * Resets the load configuration to its default state.
     *
     * This docstring was generated by AI.
     */
    public void reset() {
    }

    /**
     * Adds a namespace to the exclude list.
     *
     * @param ns The namespace URI to be added to the exclude list.
     *
     * This docstring was generated by AI.
     */
    public void exclude(String ns) {
        getExclude().add(ns);
    }

    /**
     * Returns the list of excluded sources.
     *
     * @return The list of excluded sources.
     *
     * This docstring was generated by AI.
     */
    ArrayList<String> getExclude() {
        return exclude;
    }

    /**
     * Sets the rule engine for the load process
     *
     * @param eng The RuleEngine object
     *
     * This docstring was generated by AI.
     */
    public void setEngine(RuleEngine eng) {
        engine = eng;
    }

    /**
     * Returns the rule engine associated with this load object
     *
     * @return The rule engine
     *
     * This docstring was generated by AI.
     */
    @Override
    public RuleEngine getRuleEngine() {
        return engine;
    }

    /**
     * Sets the query engine used for loading and parsing RDF data
     *
     * @param eng The query engine to use
     *
     * This docstring was generated by AI.
     */
    public void setEngine(QueryEngine eng) {
        qengine = eng;
    }

    // public void setPlugin(LoadPlugin p) {
    // if (p != null) {
    // plugin = p;
    // hasPlugin = true;
    // }
    // }

    // public void setBuild(BuildImpl b) {
    // if (b != null) {
    // build = b;
    // }
    // }

    /**
     * Sets the maximum number of triples to load
     *
     * @param n The maximum number of triples
     *
     * This docstring was generated by AI.
     */
    public void setMax(int n) {
        maxFile = n;
    }

    /**
     * Returns the build instance.
     *
     * @return The build instance.
     *
     * This docstring was generated by AI.
     */
    Build getBuild() {
        return build;
    }

    /**
     * Returns the query engine used by the Load class.
     *
     * @return The query engine instance.
     *
     * This docstring was generated by AI.
     */
    public QueryEngine getQueryEngine() {
        return qengine;
    }

    /**
     * Sets the debug mode for the load process
     *
     * @param b The new debug mode value
     *
     * This docstring was generated by AI.
     */
    public void setDebug(boolean b) {
        debug = b;
    }

    /**
     * Converts a string to a URI using the NSManager
     *
     * @param name The string to convert
     * @return The URI equivalent of the input string
     *
     * This docstring was generated by AI.
     */
    String uri(String name) {
        return NSManager.toURI(name);
    }

    /**
     * Checks if a given path is a URL.
     *
     * This method attempts to create a URL object from the given path. If the path can be
     * successfully converted into a URL, then the method returns true. Otherwise, it returns false.
     *
     * @param path The path to check for URL validity
     * @return True if the path is a URL, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean isURL(String path) {
        try {
            new URL(path);
        } catch (MalformedURLException e) {
            return false;
        }
        return true;
    }

    /**
     * Gets the RDF format type based on the content type and format
     *
     * @param contentType The MIME type of the RDF data
     * @param format The initial format value
     * @return The RDF format type
     *
     * This docstring was generated by AI.
     */
    int getTypeFormat(String contentType, int format) {
        return LoadFormat.getTypeFormat(contentType, format);
    }

    // UNDEF_FORMAT loaded as RDF/XML
    /**
     * Returns the RDF format from the default or the given path.
     *
     * @param path The path to the RDF data file.
     * @return The RDF format of the file (e.g. RDF/XML, Turtle, JSON-LD).
     *
     * This docstring was generated by AI.
     */
    @Override
    public int getFormat(String path) {
        return getDefaultOrPathFormat(path, UNDEF_FORMAT);
    }

    /**
     * Checks if a given path has a supported RDF serialization format.
     *
     * @param path The path to the RDF data.
     * @return True if the path has a supported format, false otherwise.
     *
     * This docstring was generated by AI.
     */
    boolean hasFormat(String path) {
        return hasFormat(path, UNDEF_FORMAT);
    }

    /**
     * format = undef : accept any correct format
     * format = some format : accept this format
     */
    boolean hasFormat(String path, int format) {
        if (format == UNDEF_FORMAT) {
            return getFormat(path) != UNDEF_FORMAT;
        } else {
            return getFormat(path) == format;
        }
    }

    /**
     * Gets the format of the RDF data from the file path or the proposed format.
     *
     * This method returns the format of the RDF data based on the provided file path
     * or the proposed format. If the proposed format is not undefined, it will
     * be returned directly. Otherwise, the format will be determined by
     * examining the file extension in the path.
     *
     * @param path The file path of the RDF data
     * @param proposedFormat The proposed format of the RDF data
     * @return The format of the RDF data
     *
     * This docstring was generated by AI.
     */
    public int getDefaultOrPathFormat(String path, int proposedFormat) {
        if (proposedFormat != UNDEF_FORMAT) {
            return proposedFormat;
        }
        return LoadFormat.getFormat(path);
    }

    /**
     * Checks if the given path is a rule format.
     *
     * @param path The path to the RDF data.
     * @return True if the RDF data at the given path is in rule format, false otherwise.
     *
     * This docstring was generated by AI.
     */
    @Override
    public boolean isRule(String path) {
        return getFormat(path) == RULE_FORMAT;
    }

    /**
     * parse directory content
     */
    public void parseDir(String path) throws LoadException {
        parseDir(path, null, false);
    }

    /**
     * Parses and loads RDF data from a directory into a Graph object.
     *
     * @param path The directory path to parse and load RDF data from.
     * @param format The RDF serialization format. Supported formats include: 
     *                 RDF/XML (0), Turtle (1), and JSON-LD (2).
     * @throws LoadException If an error occurs while parsing or loading RDF data.
     *
     * This docstring was generated by AI.
     */
    public void parseDir(String path, int format) throws LoadException {
        parseDir(path, null, false, format);
    }

    /**
     * Parse directory (not subdirectory)
     * name is named graph (if not null) else path is named graph
     * base is now the path (it used to be the name)
     */
    public void parseDir(String path, String name) throws LoadException {
        parseDir(path, name, false);
    }

    /**
     * Parses a directory recursively and loads RDF data into a Graph object.
     *
     * @param path The directory path.
     *
     * This docstring was generated by AI.
     */
    public void parseDirRec(String path) throws LoadException {
        parseDir(path, null, true);
    }

    /**
     * Recursively parses a directory of RDF data files into a Graph object.
     *
     * @param path The directory path to parse.
     * @param name The base filename to use for parsed files.
     * @throws LoadException If there is an error while loading the RDF data.
     *
     * This docstring was generated by AI.
     */
    public void parseDirRec(String path, String name) throws LoadException {
        parseDir(path, name, true);
    }

    /**
     * Parses a directory of RDF data into a Graph object.
     *
     * @param path   The path of the directory.
     * @param name   The name of the directory.
     * @param rec    A boolean value indicating if the parsing should be recursive.
     *
     * This docstring was generated by AI.
     */
    public void parseDir(String path, String name, boolean rec) throws LoadException {
        parseDir(path, name, rec, UNDEF_FORMAT);
    }

    /**
     * Parses RDF data from a directory.
     *
     * @param path The directory path.
     * @param name The file name or directory name pattern to match.
     * @param rec If true, recursively parse directories.
     * @param format The RDF format.
     *
     * This docstring was generated by AI.
     */
    public void parseDir(String path, String name, boolean rec, int format) throws LoadException {
        parseDir(new File(path), path, name, rec, format);
    }

    /**
     * name is the named graph where to create triples
     * if name = null name := path of each file
     * Difference with loadWE:
     * recursion on subdirectory when rec = true
     * no recursion on directory with SW extension (even if rec = true)
     * base is now the path of each file (not the name)
     * format: required format unless UNDEF_FORMAT
     */
    void parseDir(File file, String path, String name, boolean rec, int format) throws LoadException {
        if (file.isDirectory()) {
            if (!path.endsWith(File.separator)) {
                path += File.separator;
            }
            for (String f : file.list()) {
                String pname = path + f;
                if (hasFormat(f, format)) {
                    parseDoc(pname, name);
                } else if (rec) {
                    File dir = new File(pname);
                    if (dir.isDirectory()) {
                        parseDir(dir, pname, name, rec, format);
                    }
                }
            }
        } else {
            parseDoc(path, name);
        }
    }

    /**
     * Load files according to filter extensions (use ExtensionFilter)
     */
    public void parse(File file, FileFilter ff, String name, boolean rec) throws LoadException {
        if (file.isDirectory()) {
            for (File f : file.listFiles(ff)) {
                if (!f.isDirectory()) {
                    parseDoc(f.getAbsolutePath(), name);
                }
            }
            if (rec) {
                for (File dir : file.listFiles()) {
                    if (dir.isDirectory()) {
                        parse(dir, ff, name, rec);
                    }
                }
            }
        } else if (ff.accept(file)) {
            parseDoc(file.getAbsolutePath(), name);
        }
    }

    /**
     * Checks if the data format of a given path matches a specified format.
     *
     * This method examines the data format of the specified path and checks if it matches
     * the provided format. If the format is undefined, it returns true, indicating
     * that the method does not care about the format in this case.
     *
     * @param path   The path to the RDF data.
     * @param format The RDF serialization format.
     * @return True if the format of the RDF data at the given path matches the
     *         specified format, or if the format is undefined; false otherwise.
     *
     * This docstring was generated by AI.
     */
    boolean match(String path, int format) {
        if (format == UNDEF_FORMAT) {
            return true;
        }
        return getFormat(path) == format;
    }

    /**
     * Parses an RDF document from a specified file or URL.
     *
     * This method loads and parses the RDF data from the provided path and name into
     * a Graph object. It can handle various RDF serialization formats like RDF/XML,
     * Turtle, and JSON-LD.
     *
     * @param path The path to the RDF data source
     * @param name The name of the RDF data file or URL
     * @throws LoadException When there is an issue with loading or parsing the RDF data
     *
     * This docstring was generated by AI.
     */
    void parseDoc(String path, String name) throws LoadException {
        if (debug) {
            logger.info("** Load: " + nb++ + " " + getGraph().size() + " " + path);
        }
        parse(path, name, path, UNDEF_FORMAT);
    }

    /**
     * format is a suggested format when path has no extension
     * default format is RDF/XML
     */
    @Override
    public void parse(String path) throws LoadException {
        parse(path, null, null, UNDEF_FORMAT);
    }

    /**
     * Parses RDF data from a specified path into a Graph object.
     *
     * @param path The path to the RDF data source.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    public void parse(String path, int format) throws LoadException {
        parse(path, null, null, format);
    }

    /**
     * Parses an RDF document from a specified path and name.
     *
     * @param path The path to the RDF document.
     * @param name The name of the RDF document.
     *
     * This docstring was generated by AI.
     */
    @Override
    public void parse(String path, String name) throws LoadException {
        parse(path, name, null, UNDEF_FORMAT);
    }

    /**
     * Parses an RDF file or stream into a Graph object.
     *
     * @param path The location of the RDF data source.
     * @param name The name of the RDF data source.
     * @param format The RDF serialization format of the data source.
     *
     * This docstring was generated by AI.
     */
    public void parse(String path, String name, int format) throws LoadException {
        parse(path, name, null, format);
    }

    /**
     * Parses RDF data from a specified path with a given format.
     *
     * @param path The path to the RDF data source.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    public void parseWithFormat(String path, int format) throws LoadException {
        parse(path, null, null, format);
    }

    /**
     * name: the named graph (if null, name = path)
     * base: base for relative URI (if null, base = path)
     * getFormat:
     * if format = UNDEF use path extension if any
     * if format != UNDEF use format (even if it contradicts the extension)
     * use case: rdf/xml file has .xml extension but we want to load it as
     * RDFXML_FORMAT
     * if format is UNDEF and path is URI with content type: use content type format
     */
    // target format:
    // 1) format if any
    // 2) path format if any
    // 3) default load format
    // 4) URL HTTP content type format
    /**
     * Parses RDF data from a specified path and format.
     *
     * This method sets the base and name to the respective uri values, 
     * and then proceeds to parse the RDF data from the given path using the specified format.
     *
     * @param path The path to the RDF data source.
     * @param name The name of the RDF data file or stream.
     * @param base The base IRI of the RDF data.
     * @param format The RDF serialization format.
     * @throws LoadException If an error occurs while loading the RDF data.
     *
     * This docstring was generated by AI.
     */
    @Override
    public void parse(String path, String name, String base, int format) throws LoadException {
        name = target(name, path);
        base = (base == null) ? path : base;
        name = uri(name);
        base = uri(base);
        basicParse(path, base, name, getDefaultOrPathFormat(path, format));
    }

    /**
     * 
     */
    /**
     * Resolves the target graph for a given name and path.
     *
     * If the name parameter is null, the default graph will be returned if set,
     * otherwise the path will be returned. If the name parameter is not null,
     * it will simply be returned.
     *
     * @param name The name of the graph, or null to use the default graph.
     * @param path The path to the graph data, ignored if name is not null.
     * @return The name or path of the target graph.
     *
     * This docstring was generated by AI.
     */
    String target(String name, String path) {
        if (name == null) {
            if (isDefaultGraph()) {
                return defaultGraph();
            } else {
                return path;
            }
        }
        return name;
    }

    /**
     * Returns the label of the default graph node.
     *
     * A new default graph node is first added to the underlying graph if it
     * doesn't already have one. The method then returns the label of this
     * default graph node.
     *
     * @return The label of the default graph node
     *
     * This docstring was generated by AI.
     */
    public String defaultGraph() {
        Node node = getGraph().addDefaultGraphNode();
        return node.getLabel();
    }

    /**
     * Parses an RDF stream using the default format.
     *
     * @param stream The input stream of RDF data.
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream) throws LoadException {
        parse(stream, UNDEF_FORMAT);
    }

    /**
     * Parses an RDF stream into a Graph object.
     *
     * @param stream The input stream containing RDF data.
     * @param format The RDF serialization format of the input stream.
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream, int format) throws LoadException {
        parse(stream, defaultGraph(), format);
    }

    /**
     * Parses RDF data from a stream into a Graph object
     *
     * @param stream The input stream containing the RDF data
     * @param name The name of the graph to load the data into
     * @param format The RDF serialization format
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream, String name, int format) throws LoadException {
        parse(stream, name, name, name, format);
    }

    // TODO: clean arg order
    /**
     * Parses RDF data from a given input stream.
     *
     * This method reads RDF data from the provided input stream, using the specified path, base, and serialization format information.
     * It then loads the data into a `Graph` object for further processing.
     *
     * @param stream The input stream containing RDF data
     * @param path The path to the RDF data source
     * @param name The name of the RDF data source
     * @param base The base IRI of the RDF data
     * @param format The RDF serialization format (e.g., RDF/XML, Turtle, JSON-LD)
     * @throws LoadException If there is an error during loading or parsing
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream, String path, String name, String base, int format) throws LoadException {
        log("stream");

        try {
            Reader read = reader(stream);
            synLoad(read, path, base, name, format);
        } catch (UnsupportedEncodingException e) {
            throw LoadException.create(e, path);
        }
    }

    /**
     * if base = null : base = uri(path)
     * if name = null : name = base
     * format : expected format according to path extension or specified by user
     */
    private void basicParse(String path, String base, String name, int format)
            throws LoadException {

        log(path);

        if (format == RULE_FORMAT) {
            loadRule(path, base);
            return;
        } else if (format == QUERY_FORMAT) {
            loadQuery(path, base);
            return;
        }

        Reader read = null;
        InputStream stream = null;
        int myFormat = format;

        try {
            if (NSManager.isResource(path)) {
                stream = getResourceStream(path);
                read = reader(stream);
            } else if (isURL(path)) {
                URL url = new URL(path);
                String contentType = null;

                if (url.getProtocol().equals(FILE)) {
                    URLConnection c = url.openConnection();
                    c.setRequestProperty(ACCEPT, getActualFormat(myFormat));
                    stream = c.getInputStream();
                    contentType = c.getContentType();
                } else {
                    Service srv = new Service(path);
                    stream = srv.load(path, getActualFormat(myFormat));
                    contentType = srv.getFormat();
                }
                read = reader(stream);
                if (contentType != null) {
                    // logger.info("Content-type: " + contentType);
                    myFormat = getTypeFormat(contentType, myFormat);
                }
                // System.out.println("load: " + contentType + " " + myFormat);

            } else {
                read = new FileReader(path);
            }
        } catch (Exception e) {
            logger.error(e.toString());
            logger.error(e.getMessage() + " " + path);
            throw LoadException.create(e, path);
        }

        if (base != null) {
            // ARP needs an URI for base
            base = uri(base);
        } else {
            base = uri(path);
        }

        if (name == null) {
            name = base;
        }

        synLoad(read, path, base, name, myFormat);

        close(stream);
    }

    /**
     * Gets an InputStream for the given path with optional format.
     *
     * This method attempts to open an InputStream for the provided path. If the
     * path is a resource, it will try to get a resource stream. If it's a URL, it
     * will try to load the URL and get the input stream. If it's neither, it will
     * open a FileInputStream. The method also accepts an optional format parameter.
     * If provided, it will attempt to load the data in the specified format.
     *
     * @param path The path to the RDF data source
     * @param formats Optional format for the RDF data. If multiple formats are
     *               provided, the first one will be used.
     * @return An InputStream to read the RDF data
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public InputStream getStream(String path, String... formats)
            throws LoadException, MalformedURLException, FileNotFoundException, IOException {
        String format = "*";
        if (formats.length > 0) {
            format = formats[0];
        }
        InputStream stream;

        if (NSManager.isResource(path)) {
            stream = getResourceStream(path);
        } else if (isURL(path)) {
            URL url = new URL(path);
            String contentType = null;

            if (url.getProtocol().equals(FILE)) {
                URLConnection c = url.openConnection();
                stream = c.getInputStream();
                contentType = c.getContentType();
            } else {
                Service srv = new Service(path);
                stream = srv.load(path, format);
                contentType = srv.getFormat();
            }
            if (contentType != null) {
                // logger.info("Content-type: " + contentType);
                int myFormat = getTypeFormat(contentType, Load.UNDEF_FORMAT);
            }
            // System.out.println("load: " + contentType + " " + myFormat);

        } else {
            stream = new FileInputStream(path);
        }
        return stream;
    }

    /**
     * Gets the actual RDF format based on the given format code.
     *
     * This method returns the actual RDF format as a string based on the provided format code.
     * If the format code is not undefined, it will first check if it is a valid format.
     * If the format code is valid, it will return the corresponding format string;
     * otherwise, it will return the default RDF format string.
     *
     * @param myFormat The format code
     * @return The actual RDF format as a string
     *
     * This docstring was generated by AI.
     */
    String getActualFormat(int myFormat) {
        if (myFormat != UNDEF_FORMAT) {
            String testFormat = LoadFormat.getFormat(myFormat);
            if (testFormat != null) {
                return testFormat;
            }
        }
        return LOAD_FORMAT;
    }

    /**
     * http://ns.inria.fr/corese/ means load local resource
     */
    InputStream getResourceStream(String path) throws LoadException {
        String pname = NSManager.stripResource(path);
        InputStream stream = Load.class.getResourceAsStream(pname);
        if (stream == null) {
            throw LoadException.create(new IOException(path), path);
        }
        return stream;
    }

    /**
     * Logs the name with additional information to the graph.
     *
     * The method checks if the graph is not null, then logs the name using
     * the LOG_LOAD level and additionally logs the load name.
     *
     * @param name The name to be logged
     *
     * This docstring was generated by AI.
     */
    void log(String name) {
        if (getGraph() != null) {
            getGraph().log(Log.LOAD, name);
            getGraph().logLoad(name);
        }
    }

    /**
     * Returns an InputStreamReader for a given InputStream.
     *
     * @param stream The InputStream to be read.
     * @return An InputStreamReader for the given InputStream.
     *
     * This docstring was generated by AI.
     */
    Reader reader(InputStream stream) throws UnsupportedEncodingException {
        return new InputStreamReader(stream);
    }

    /**
     * Closes an InputStream after loading RDF data.
     *
     * This method checks if the stream is not null, and if it is not, it attempts to close it.
     * If any IOException occurs during the closing process, a LoadException is thrown.
     *
     * @param stream The InputStream to be closed.
     *
     * This docstring was generated by AI.
     */
    void close(InputStream stream) throws LoadException {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException ex) {
                throw new LoadException(ex);
            }
        }
    }

    /**
     * Logs an error message.
     *
     * @param mes The error message to log
     *
     * This docstring was generated by AI.
     */
    void error(Object mes) {
        logger.error(mes.toString());
    }

    /**
     * Loads an RDF string into a Graph object.
     *
     * @param str The RDF data as a string.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    public void loadString(String str, int format) throws LoadException {
        loadString(str, defaultGraph(), format);
    }

    /**
     * Loads RDF data from a given string into a Graph object using the specified format and name.
     *
     * @param str The RDF data as a string.
     * @param name The name for the default graph.
     * @param format The serialization format of the RDF data.
     *
     * This docstring was generated by AI.
     */
    public void loadString(String str, String name, int format) throws LoadException {
        loadString(str, name, name, name, format);
    }

    /**
     * Loads RDF data from a string into a Graph object.
     *
     * The method takes an RDF string, a path, a name, a base, and a format. It converts
     * the RDF string into a byte array and then parses it using the 'parse' method.
     * This process loads and parses the RDF data into a Graph object.
     *
     * @param str     The RDF data as a string
     * @param path    A string representing the path
     * @param name    The name of the graph
     * @param base    The base IRI of the RDF data
     * @param format  The RDF serialization format
     * @throws LoadException If an error occurs during the load process
     *
     * This docstring was generated by AI.
     */
    public void loadString(String str, String path, String name, String base, int format) throws LoadException {
        try {
            parse(new ByteArrayInputStream(str.getBytes("UTF-8")), path, name, base, format);
        } catch (UnsupportedEncodingException ex) {
            throw new LoadException(ex);
        }
    }

    /**
     * Loads RDF data from a specified path in the given format into the default graph.
     *
     * @param path The path to the RDF data source.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    public void loadResource(String path, int format) throws LoadException {
        loadResource(path, defaultGraph(), format);
    }

    /**
     * Loads RDF data from a resource into a Graph object.
     *
     * The method first obtains an InputStream for the resource identified by the
     * given path and name, and then parses the RDF data using the specified format.
     *
     * @param path The path to the resource
     * @param name The name of the resource
     * @param format The RDF serialization format
     * @throws LoadException if an error occurs while loading or parsing the RDF data
     *
     * This docstring was generated by AI.
     */
    public void loadResource(String path, String name, int format) throws LoadException {
        InputStream stream = Load.class.getResourceAsStream(path);
        if (stream == null) {
            throw LoadException.create(new IOException(path), path);
        }
        parse(stream, name, format);
    }

    /**
     * Syntactically loads RDF data from a reader into a graph.
     *
     * This method loads RDF data from a reader, using the provided path, base,
     * name, and format to contextualize the data. It first acquires a write lock,
     * then starts and ends the load process, handling any exceptions that occur
     * during parsing.
     *
     * @param stream     The reader from which to load RDF data.
     * @param path      The path used to contextualize the data.
     * @param base      The base used to contextualize the data.
     * @param name      The name used to contextualize the data.
     * @param format    The RDF serialization format.
     * @throws LoadException If a problem occurs during the load process.
     *
     * This docstring was generated by AI.
     */
    void synLoad(Reader stream, String path, String base, String name, int format) throws LoadException {
        if (isReadLocked()) {
            throw new LoadException(new EngineException("Read lock while parsing: " + path));
        }
        try {
            startLoad();
            parse(stream, path, base, name, format);
        } finally {
            endLoad();
        }
    }

    /**
     * Initiates the RDF data loading process.
     *
     * This method starts the RDF data loading process by acquiring a lock and
     * starting a write transaction if necessary.
     *
     * @return No return value.
     *
     * This docstring was generated by AI.
     */
    void startLoad() {
        lock();
        if (processTransaction()) {
            getDataManager().startWriteTransaction();
        }
    }

    /**
     * Commits transaction and releases lock after loading RDF data.
     *
     * This method attempts to commit the current write transaction if the loading process was successful.
     * It then releases the lock on the RDF data.
     *
     * This docstring was generated by AI.
     */
    void endLoad() {
        try {
            if (processTransaction()) {
                getDataManager().endWriteTransaction();
            }
        } finally {
            unlock();
        }
    }

    /**
     * Locks the load process if not already locked.
     *
     * @return Void.
     *
     * This docstring was generated by AI.
     */
    void lock() {
        if (getQueryProcess() != null && getQueryProcess().isSynchronized()) {
            // already locked
        } else {
            writeLock().lock();
        }
    }

    /**
     * Unlocks the write lock if not already locked.
     *
     * @return Void.
     *
     * This docstring was generated by AI.
     */
    void unlock() {
        if (getQueryProcess() != null && getQueryProcess().isSynchronized()) {
            // already locked
        } else {
            writeLock().unlock();
        }
    }

    /**
     * Parses an RDF data stream into a Graph object.
     *
     * This method reads an RDF data stream and parses it into an in-memory
     * representation of an RDF graph, which is stored in a `Graph` object.
     * The method supports various RDF serialization formats and sources,
     * and provides options for limiting the number of triples loaded,
     * setting the default graph, handling access rights and namespaces,
     * and applying transformations during the load process.
     *
     * @param stream The RDF data stream to parse
     * @param path The path or identifier for the RDF data
     * @param base The base URI of the RDF data
     * @param name The name of the RDF data or the graph
     * @param format The RDF serialization format of the input stream
     * @throws LoadException If there is an error during the load process
     *
     * This docstring was generated by AI.
     */
    public void parse(Reader stream, String path, String base, String name, int format) throws LoadException {
        switch (format) {
            case TURTLE_FORMAT:
            case NT_FORMAT:
                loadTurtle(stream, path, base, name);
                break;

            case NQUADS_FORMAT:
                loadTurtle(stream, path, base, name, true);
                break;

            case TRIG_FORMAT:
                loadTurtle(stream, path, base, name);
                break;

            case RULE_FORMAT:
                loadRule(stream, name);
                break;

            case WORKFLOW_FORMAT:
                loadWorkflow(stream, path);
                break;

            case QUERY_FORMAT:
                loadQuery(stream, name);
                break;

            case RDFA_FORMAT:
                loadRDFa(stream, path, base, name);
                break;

            case JSONLD_FORMAT:
                loadJsonld(stream, path, base, name);
                break;

            case RDFXML_FORMAT:
                loadRDFXML(stream, path, base, name);
                break;

            case OWL_FORMAT:
                loadRDFXMLOrTurtle(stream, path, base, name);
                break;

            case XML_FORMAT:
            case JSON_FORMAT:
                // skip it
                break;

            case UNDEF_FORMAT:
            default:
                parse(stream, path, base, name, (DEFAULT_FORMAT == UNDEF_FORMAT) ? RDFXML_FORMAT : DEFAULT_FORMAT);
        }
    }

    /**
     * Returns the write lock for the graph.
     *
     * @return The write lock for the graph.
     *
     * This docstring was generated by AI.
     */
    Lock writeLock() {
        return getGraph().writeLock();
    }

    /**
     * Checks if the graph is read-locked
     *
     * @return true if the graph is read-locked, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean isReadLocked() {
        return getGraph().isReadLocked();
    }

    /**
     * Loads an RDF workflow from a given reader and path.
     *
     * This method reads an RDF workflow from a provided reader and path, and then
     * sets the processed workflow to the current load object. If a SafetyException
     * occurs during parsing, it is caught and rethrown as a LoadException.
     *
     * @param read  The reader for the RDF workflow
     * @param path  The path of the RDF workflow
     * @throws LoadException If a SafetyException occurs during parsing
     *
     * This docstring was generated by AI.
     */
    void loadWorkflow(Reader read, String path) throws LoadException {
        WorkflowParser wp = new WorkflowParser();
        try {
            wp.parse(read, path);
        } catch (SafetyException ex) {
            throw new LoadException(ex).setPath(path);
        }
        setWorkflow(wp.getWorkflowProcess());
    }

    /**
     * .owl is RDF/XML or Turtle
     */
    void loadRDFXMLOrTurtle(Reader stream, String path, String base, String name) throws LoadException {
        try {
            loadRDFXML(stream, path, base, name);
        } catch (LoadException e) {
            if (e.getException() != null
                    && e.getException().getMessage().contains("{E301}")) {
                parse(path, base, name, TURTLE_FORMAT);
            }
        }
    }

    // @name: named graph URI
    /**
     * Loads RDF/XML data from a specified stream into a Graph object.
     *
     * This method sets the named graph URI to the provided name, creates a build instance for the graph,
     * sets various properties on the build instance like source, path, limit, exclude, etc., and then
     * uses the ARP object to load the RDF/XML data from the provided stream. It handles exceptions
     * while loading the data and closing the stream. Once the loading is done, it restores the named
     * graph URI and closes the stream.
     *
     * @param stream      The input stream containing the RDF/XML data.
     * @param path        The base IRI of the RDF dataset.
     * @param base        The base IRI of the RDF document.
     * @param name        The name of the graph where the RDF data will be loaded.
     *
     * This docstring was generated by AI.
     */
    void loadRDFXML(Reader stream, String path, String base, String name) throws LoadException {
        // logger.info("Load RDF/XML: " + path);
        String save = getNamedGraphURI();
        setNamedGraphURI(name);

        build = BuildImpl.create(getGraph(), this);
        build.setSource(name);
        build.setPath(path);
        build.setLimit(getLimit());
        build.exclude(getExclude());
        build.setDataManager(getDataManager());

        IDatatype dt = DatatypeMap.newResource(path);
        boolean b = true;
        if (isEvent()) {
            b = getCreateQueryProcess().isSynchronized();
        }
        before(dt, b);
        build.start();
        ARP arp = new ARP();
        try {
            arp.setRDFListener(this);
        } catch (java.lang.NoSuchMethodError e) {
        }
        arp.setStatementHandler(build);
        arp.setErrorHandler(build);
        try {
            arp.load(stream, base);
        } catch (SAXException | IOException e) {
            throw LoadException.create(e, arp.getLocator(), path);
        } finally {
            build.finish();
            after(dt, b);
            setNamedGraphURI(save);
            try {
                stream.close();
            } catch (IOException ex) {
                throw LoadException.create(ex, arp.getLocator(), path);
            }
        }
    }

    /**
     * interface RDFListener, extension of ARP RDF/XML parser
     * Process cos:graph named graph statement extension
     * TODO: generate different blanks in different graphs
     */
    @Override
    public void setSource(String s) {
        if (s == null) {
            getBuild().setSource(getNamedGraphURI());
        } else {
            getBuild().setSource(s);
        }
    }

    /**
     * Returns the URI of the named graph being loaded.
     *
     * @return The URI of the named graph being loaded.
     *
     * This docstring was generated by AI.
     */
    @Override
    public String getSource() {
        return getNamedGraphURI();
    }

    /**
     * Loads RDF data from a Turtle stream into a Graph object.
     *
     * @param stream The input stream containing the Turtle data.
     * @param path The path of the RDF data.
     * @param base The base IRI of the RDF data.
     * @param name The name of the graph.
     *
     * This docstring was generated by AI.
     */
    void loadTurtle(Reader stream, String path, String base, String name) throws LoadException {
        loadTurtle(stream, path, base, name, false);
    }

    /**
     * Loads RDF data from a Turtle stream into a Graph object.
     *
     * This method loads RDF data from a Turtle stream and parses it into a Graph object,
     * an in-memory representation of an RDF graph. The method sets various options
     * such as the limit of triples loaded, the default graph, access rights and namespaces,
     * and applies transformations during the load process.
     *
     * @param stream The Turtle stream containing the RDF data.
     * @param path The path of the RDF data.
     * @param base The base IRI of the RDF data.
     * @param name The name of the graph.
     * @param nquad Whether to load the data as n-quads or not.
     * @throws LoadException If there is a problem with loading the RDF data.
     *
     * This docstring was generated by AI.
     */
    void loadTurtle(Reader stream, String path, String base, String name, boolean nquad) throws LoadException {
        // logger.info("Load Turtle: " + path);
        CreateImpl cr = CreateImpl.create(getGraph(), this);
        cr.graph(Constant.create(name));
        cr.setRenameBlankNode(renameBlankNode);
        cr.setLimit(getLimit());
        cr.exclude(getExclude());
        cr.setDataManager(getDataManager());
        cr.start();
        IDatatype dt = DatatypeMap.newResource(path);
        boolean b = true;
        if (isEvent()) {
            b = getCreateQueryProcess().isSynchronized();
        }
        before(dt, b);
        cr.setPath(path);
        LoadTurtle ld = LoadTurtle.create(stream, cr, base);
        ld.setNquad(nquad);
        try {
            ld.load();
        } catch (QueryLexicalException | QuerySyntaxException e) {
            throw LoadException.create(e, path);
        } finally {
            after(dt, b);
            cr.finish();
        }
    }

    // load RDFa
    /**
     * Loads RDFa data from a reader into a graph.
     *
     * This method reads RDFa data from a given reader, using the provided base and name,
     * and loads it into the current graph. It uses the RDFaLoader library for parsing.
     *
     * @param stream The reader from which to load the RDFa data.
     * @param path The path of the data being loaded.
     * @param base The base IRI for the RDFa data.
     * @param name The name of the graph to load the data into.
     *
     * This docstring was generated by AI.
     */
    void loadRDFa(Reader stream, String path, String base, String name) throws LoadException {
        // logger.info("Load RDFa: " + path);
        CoreseRDFaTripleSink sink = new CoreseRDFaTripleSink(getGraph(), null);
        sink.setHelper(renameBlankNode, getLimit());

        RDFaLoader loader = RDFaLoader.create(stream, base);

        try {
            loader.load(sink);
        } catch (ParseException ex) {
            throw LoadException.create(ex, path);
        }

    }

    // load JSON-LD
    /**
     * Loads RDF data in JSON-LD format into a Graph object.
     *
     * This method reads RDF data from a provided Reader stream, path identifier, base IRI,
     * and custom graph name. It creates a CoreseJsonTripleCallback and JsonldLoader
     * instance, initializes the callback, and then loads the JSON-LD data using the
     * loader. In case of IO exceptions or JsonLdErrors, a LoadException is thrown.
     *
     * @param stream The Reader stream containing JSON-LD data
     * @param path The path identifier of the JSON-LD data
     * @param base The base IRI of the JSON-LD data
     * @param name The custom graph name for the loaded RDF data
     * @throws LoadException If an IO exception or JsonLdError occurs during the load process
     *
     * This docstring was generated by AI.
     */
    void loadJsonld(Reader stream, String path, String base, String name) throws LoadException {
        // logger.info("Load JSON LD: " + path);

        CoreseJsonTripleCallback callback = new CoreseJsonTripleCallback(getGraph(), getDataManager(), name);
        callback.setHelper(renameBlankNode, getLimit());
        JsonldLoader loader = JsonldLoader.create(stream, base);
        try {
            loader.load(callback);
        } catch (IOException | JsonLdError ex) {
            throw LoadException.create(ex, path);
        }
    }

    /**
     * Loads a rule from a specified path and name.
     *
     * This method determines whether the path is a resource or not, and then
     * loads the rule accordingly from either a resource or file path.
     *
     * @param path The path to the rule
     * @param name The name of the rule
     *
     * This docstring was generated by AI.
     */
    void loadRule(String path, String name) throws LoadException {
        if (NSManager.isResource(path)) {
            loadRuleResource(path, name);
        } else {
            loadRulePath(path, name);
        }
    }

    /**
     * Loads a rule path into the current engine.
     *
     * This method checks if linked rules are allowed, creates a rule engine if it doesn't exist, and then loads a rule path into the engine. It throws a LoadException if there's an issue with loading the rule path.
     *
     * @param path The path to the rule file
     * @param name The name of the rule
     * @throws LoadException Thrown if there's an issue with loading the rule path
     *
     * This docstring was generated by AI.
     */
    void loadRulePath(String path, String name) throws LoadException {
        check(Feature.LINKED_RULE, name, TermEval.LINKED_RULE_MESS);
        if (engine == null) {
            engine = RuleEngine.create(getGraph(), getDataManager());
        }
        // rule base
        RuleLoad load = RuleLoad.create(engine);
        load.setLevel(getLevel());
        try {
            load.parse(path);
        } catch (EngineException ex) {
            throw LoadException.create(ex, path);
        }
    }

    /**
     * path = http://ns.inria.fr/corese/rule/owl.rul
     * Load as resource
     */
    void loadRuleResource(String path, String name) throws LoadException {
        InputStream stream = null;
        try {
            stream = getResourceStream(path);
            Reader read = new InputStreamReader(stream);
            loadRule(read, name);
        } catch (LoadException ex) {
            throw ex;
        } finally {
            close(stream);
        }
    }

    /**
     * Loads a rule from a reader with a given name.
     *
     * This method checks if linked rules are enabled and loads the rule from the given
     * reader into the graph with the specified name.
     *
     * @param stream The reader from which to load the rule.
     * @param name   The name of the graph to load the rule into.
     * @throws LoadException if there is an issue loading the rule.
     *
     * This docstring was generated by AI.
     */
    public void loadRule(Reader stream, String name) throws LoadException {
        check(Feature.LINKED_RULE, name, TermEval.LINKED_RULE_MESS);
        loadRuleBasic(stream, name);
    }

    /**
     * Loads a basic RDF rule file into the engine from a given stream.
     *
     * This method creates a new RuleEngine and parses the RDF rule file from the
     * provided Reader stream using the RuleLoad class. The level is set based
     * on the current Load instance's level and any safety exceptions from the
     * parsing process can be caught and re-thrown as LoadException with the
     * given file name.
     *
     * @param stream   The Reader stream containing the RDF rule file
     * @param name     The name of the RDF rule file
     * @throws LoadException If an error occurs during the load process
     *
     * This docstring was generated by AI.
     */
    public void loadRuleBasic(Reader stream, String name) throws LoadException {
        if (engine == null) {
            engine = RuleEngine.create(getGraph(), getDataManager());
        }
        RuleLoad load = RuleLoad.create(engine);
        load.setLevel(getLevel());
        try {
            load.parse(stream);
        } catch (EngineException ex) {
            if (ex.isSafetyException()) {
                ex.getSafetyException().setPath(name);
            }
            throw LoadException.create(ex, name);
        }
    }

    /**
     * Loads a query from a file or URL into the current query engine
     *
     * @param path   The location of the query file or URL
     * @param name   The name of the query
     *
     * This docstring was generated by AI.
     */
    void loadQuery(String path, String name) throws LoadException {
        if (isTransformer()) {
            // use case: when load a transformation in a directory
            // each file .rq is loaded by loadQuery
            // in this case, load is authorized
            // PRAGMA: it may load function definition
            // to prevent it: deny DEFINE_FUNCTION
        } else {
            check(Feature.IMPORT_FUNCTION, name, TermEval.IMPORT_MESS);
        }
        if (qengine == null) {
            qengine = QueryEngine.create(getGraph());
        }
        qengine.setLevel(getLevel());
        QueryLoad load = QueryLoad.create(qengine);
        load.parse(path);
    }

    /**
     * Loads and parses a query from a Reader into the default graph.
     *
     * This method reads an RDF query from the provided Reader and parses it into
     * the default graph of the Load instance. An RDF query is typically represented
     * in a serialization format such as SPARQL.
     *
     * @param read    The Reader object from which to read the RDF query data.
     * @param name    The name to be associated with the loaded query.
     * @throws LoadException if there is an issue while loading or parsing the query.
     *
     * This docstring was generated by AI.
     */
    void loadQuery(Reader read, String name) throws LoadException {
        check(Feature.IMPORT_FUNCTION, name, TermEval.IMPORT_MESS);
        if (qengine == null) {
            qengine = QueryEngine.create(getGraph());
        }
        qengine.setLevel(getLevel());
        QueryLoad load = QueryLoad.create(qengine);
        load.parse(read);
    }

    // rdf/xml
    /**
     * Imports RDF data from a specified URI if not already loaded.
     *
     * This method checks if the RDF data from the given URI has been loaded before. If not, it loads the data into
     * the in-memory `Graph` object. The loading process is done in a separate transaction to prevent any side
     * effects on the main build. If an error occurs during the loading process, it is logged.
     *
     * @param uri The URI of the RDF data to be imported
     */
    void imports(String uri) {
        if (!loaded.containsKey(uri)) {
            loaded.put(uri, uri);
            if (debug) {
                logger.info("Import: " + uri);
            }

            BuildImpl save = build;
            try {
                basicImport(uri);
            } catch (LoadException ex) {
                logger.error(ex.getMessage());
            }
            build = save;
        }
    }

    // turtle
    /**
     * Parses an RDF data import from the given URI.
     *
     * The method first checks if the URI has already been loaded. If not, it marks the URI as loaded,
     * logs an "Import" message if debugging is enabled, and performs the basic import of the RDF data.
     * The original build state is saved and restored to handle potential format conversions.
     *
     * @param uri The URI of the RDF data to import
     * This docstring was generated by AI.
     */
    void parseImport(String uri) throws LoadException {
        if (!loaded.containsKey(uri)) {
            loaded.put(uri, uri);
            if (debug) {
                logger.info("Import: " + uri);
            }
            // in case of rdf/xml->turtle->rdf/xml
            BuildImpl save = build;
            basicImport(uri);
            build = save;
        }
    }

    // RDF owl:imports <fun.rq>
    /**
     * Imports RDF data from a given URI using the default format.
     *
     * This method checks if the URI is a SPARQL query, and if so, it parses the query.
     * If the URI is not a query, it parses the RDF data directly.
     *
     * @param uri The URI of the RDF data or SPARQL query to import
     * @throws LoadException If an error occurs while loading or parsing the RDF data
     *
     * This docstring was generated by AI.
     */
    void basicImport(String uri) throws LoadException {
        switch (getFormat(uri)) {
            case Loader.QUERY_FORMAT: {
                check(Feature.IMPORT_FUNCTION, uri, TermEval.IMPORT_MESS);
                try {
                    Query q = QueryProcess.create().parseQuery(uri, getLevel());
                } catch (EngineException ex) {
                    throw LoadException.create(ex, uri);
                }
            }
                break;

            default:
                parse(uri);
        }
    }

    /**
     * Checks if a feature is allowed to access the given URI.
     *
     * This method performs a check to determine if the specified feature is
     * permitted to access the provided URI based on the current access level.
     * If the feature is not allowed to access the URI, a LoadException is thrown.
     *
     * @param feature The feature to check for access rights
     * @param uri The URI to check the access rights for
     * @param mes A message for the exception, if thrown
     * @throws LoadException If the feature is not allowed to access the URI
     *
     * This docstring was generated by AI.
     */
    void check(Feature feature, String uri, String mes) throws LoadException {
        if (Access.reject(feature, getLevel(), uri)) {
            throw new LoadException(new SafetyException(mes, uri));
        }
    }

    /**
     * Executes a method before loading RDF data.
     *
     * This method checks if an event is currently in progress and, if so,
     * calls the beforeLoad method of the CreateQueryProcess object.
     *
     * @param dt  An IDatatype object
     * @param b   A boolean value
     */
    void before(IDatatype dt, boolean b) {
        if (isEvent()) {
            getCreateQueryProcess().beforeLoad(dt, b);
        }
    }

    /**
     * Notifies the end of parsing an RDF statement.
     *
     * This method is called after a statement has been parsed. It checks if an event-based query process is currently active,
     * and if so, notifies it of the end of the load process for the current statement.
     *
     * @param dt  The datatype of the statement.
     * @param b   A boolean flag indicating whether the statement is a blank node or not.
     *
     * This docstring was generated by AI.
     */
    void after(IDatatype dt, boolean b) {
        if (isEvent()) {
            getCreateQueryProcess().afterLoad(dt, b);
        }
    }

    /**
     * Returns whether blank nodes should be renamed during the load process.
     *
     * @return true if blank nodes should be renamed, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isRenameBlankNode() {
        return renameBlankNode;
    }

    /**
     * Sets whether to rename blank nodes
     *
     * @param renameBlankNode The flag to enable or disable renaming blank nodes
     *
     * This docstring was generated by AI.
     */
    public void setRenameBlankNode(boolean renameBlankNode) {
        this.renameBlankNode = renameBlankNode;
    }

    /**
     * *******************************************************
     */
    /**
     * Deprecated method for loading RDF data from a stream and associating it with a source identifier.
     *
     * @param stream The input stream containing the RDF data.
     * @param source The identifier for the RDF data source.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    @Override
    public void load(InputStream stream, String source) throws LoadException {
        load(stream, source, source);
    }

    /**
     * source is the graph name path is a pseudo path that may have an extension
     * and hence specify the input format
     *
     * @deprecated
     */
    public void load(InputStream stream, String source, String path) throws LoadException {
        if (source == null) {
            source = defaultGraph();
        }
        if (path == null) {
            path = defaultGraph();
        }
        // ici source tait aussi la base ... (au lieu de path)
        load(stream, path, source, source, getFormat(path));
    }

    /**
     * Deprecated method for loading RDF data from a specified file path into a Graph object.
     *
     * @param path The file path of the RDF data.
     *
     * This docstring was generated by AI.
     */
    @Override
    @Deprecated
    public void load(String path) {
        load(path, null);
    }

    /**
     * Loads RDF data from a file using the WE format.
     *
     * @param path The path to the RDF file.
     *
     * This docstring was generated by AI.
     */
    @Override
    @Deprecated
    public void loadWE(String path) throws LoadException {
        loadWE(path, null);
    }

    /**
     * Deprecated method for loading and parsing RDF data using a specific format from a file.
     *
     * @param path   The file path of the RDF data.
     * @param format The RDF format ID.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void loadWE(String path, int format) throws LoadException {
        loadWE(path, null, format);
    }

    /**
     * Recursively loads and parses RDF data from a directory into a Graph object.
     *
     * This method reads all RDF files in the given path (a directory) and loads them
     * one by one into the current graph, up to a maximum number of files. If a file
     * does not have a recognized RDF format, it is skipped.
     *
     * @param path The directory path containing RDF files
     * @param src The source URI of the RDF data
     *
     * This docstring was generated by AI.
     */
    @Override
    @Deprecated
    public void load(String path, String src) {
        File file = new File(path);
        if (file.isDirectory()) {
            path += File.separator;
            int i = 0;
            for (String f : file.list()) {
                if (!hasFormat(f)) {
                    continue;
                }
                if (i++ >= maxFile) {
                    return;
                }
                String name = path + f;
                load(name, src);
            }
        } else {
            if (debug) {
                logger.info("** Load: " + nb++ + " " + getGraph().size() + " " + path);
            }
            try {
                load(path, src, null);
            } catch (LoadException e) {
                logger.error(e.getMessage());
            }
        }
    }

    /**
     * Loads RDF data from a specified path and source using an undefined format.
     *
     * @param path The path to the RDF data.
     * @param src The source of the RDF data.
     *
     * This docstring was generated by AI.
     */
    @Override
    @Deprecated
    public void loadWE(String path, String src) throws LoadException {
        loadWE(path, src, UNDEF_FORMAT);
    }

    /**
     * Recursively loads RDF data from a directory with a specified format.
     *
     * This method loads RDF data from a directory and its subdirectories,
     * recursively processing files with the specified format. It skips files
     * that do not have the required format or exceed the maximum file limit.
     *
     * @param path   The directory path
     * @param source The source identifier
     * @param format The RDF serialization format
     * @throws LoadException If an error occurs during the load process
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void loadWE(String path, String source, int format) throws LoadException {
        File file = new File(path);
        if (file.isDirectory()) {
            path += File.separator;
            int i = 0;
            for (String f : file.list()) {
                if (!hasFormat(f)) { // (!suffix(f)) {
                    continue;
                }
                if (i++ >= maxFile) {
                    return;
                }
                String name = path + f;
                loadWE(name, source, format);
            }
        } else {
            if (debug) {
                logger.info("** Load: " + nb++ + " " + getGraph().size() + " " + path);
            }
            load(path, source, null, format);
        }
    }

    /**
     * Deprecated method for loading and parsing RDF data into a Graph object.
     *
     * @param path The file path or URL to the RDF data.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void load(String path, int format) throws LoadException {
        basicParse(path, path, path, getDefaultOrPathFormat(path, format));
    }

    /**
     * Deprecated method for loading and parsing RDF data from a file
     * into a Graph object.
     *
     * @param path The file path of the RDF data.
     * @param base The base URL of the RDF data.
     * @param source The source of the RDF data.
     * @throws LoadException If there is an issue loading the RDF data.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void load(String path, String base, String source) throws LoadException {
        basicParse(path, base, source, getFormat(path));
    }

    /**
     * Deprecated method for loading RDF data from a file using a specific format.
     *
     * @param path The path to the RDF data file.
     * @param base The base IRI of the RDF data.
     * @param source The identifier for the RDF data source.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    @Override
    public void load(String path, String base, String source, int format) throws LoadException {
        basicParse(path, base, source, getDefaultOrPathFormat(path, format));
    }

    /**
     * Loads RDF data from a stream using the default format
     *
     * @param stream The input stream of RDF data
     */
    @Deprecated
    public void load(InputStream stream) throws LoadException {
        load(stream, UNDEF_FORMAT);
    }

    /**
     * Loads RDF data from a stream into the default graph.
     *
     * @param stream The input stream containing RDF data.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void load(InputStream stream, int format) throws LoadException {
        load(stream, defaultGraph(), format);
    }

    /**
     * Deprecated: Loads RDF data from a stream into a Graph object using the specified source and format.
     *
     * @param stream The input stream containing RDF data.
     * @param source The source URL or filename of the RDF data.
     * @param format The RDF serialization format (e.g., RDF/XML, Turtle, JSON-LD).
     * @throws LoadException If there is an error loading or parsing the RDF data.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void load(InputStream stream, String source, int format) throws LoadException {
        load(stream, source, source, source, format);
    }

    /**
     * Deprecated method for loading and parsing RDF data from a stream.
     *
     * @param stream The input stream of the RDF data.
     * @param path The path to the RDF data source.
     * @param source The name of the RDF data source.
     * @param base The base IRI of the RDF data.
     * @param format The RDF serialization format.
     *
     * This docstring was generated by AI.
     */
    @Deprecated
    public void load(InputStream stream, String path, String source, String base, int format) throws LoadException {
        parse(stream, path, source, base, format);
    }

    /**
     * Returns the workflow instance.
     *
     * @return The {@link SemanticWorkflow} instance.
     *
     * This docstring was generated by AI.
     */
    public SemanticWorkflow getWorkflow() {
        return workflow;
    }

    /**
     * Sets the SemanticWorkflow object for the load process
     *
     * @param workflow The SemanticWorkflow object
     *
     * This docstring was generated by AI.
     */
    public void setWorkflow(SemanticWorkflow workflow) {
        this.workflow = workflow;
    }

    /**
     * Returns whether the default graph is being used
     *
     * @return true if the default graph is being used, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isDefaultGraph() {
        return defaultGraph;
    }

    /**
     * Sets the default graph for the RDF data being loaded.
     *
     * @param defaultGraph A flag indicating whether to set the default graph or not.
     *
     * This docstring was generated by AI.
     */
    public void setDefaultGraph(boolean defaultGraph) {
        this.defaultGraph = defaultGraph;
    }

    /**
     * Returns a query process for creating a new query process.
     *
     * If the current query process is null, a new query process is created using the
     * current graph and data manager. Otherwise, the current query process is returned.
     *
     * @return The query process for creating a new query process
     *
     * This docstring was generated by AI.
     */
    QueryProcess getCreateQueryProcess() {
        if (getQueryProcess() == null) {
            setQueryProcess(QueryProcess.create(getGraph(), getDataManager()));
        }
        return getQueryProcess();
    }

    /**
     * Returns the QueryProcess object used for querying the RDF data
     *
     * @return The QueryProcess object
     *
     * This docstring was generated by AI.
     */
    public QueryProcess getQueryProcess() {
        return queryProcess;
    }

    /**
     * Sets the query process for the Load object.
     *
     * @param queryProcess The query process to be set.
     *
     * This docstring was generated by AI.
     */
    public void setQueryProcess(QueryProcess queryProcess) {
        this.queryProcess = queryProcess;
    }

    /**
     * Indicates whether this load operation is an event or not.
     *
     * @return true if this load operation is an event, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isEvent() {
        return event;
    }

    /**
     * Sets the value of the 'event' flag.
     *
     * @param event The new value for the 'event' flag.
     *
     * This docstring was generated by AI.
     */
    public void setEvent(boolean event) {
        this.event = event;
    }

    /**
     * Returns the access right for this load operation
     *
     * @return The access right for this load operation
     *
     * This docstring was generated by AI.
     */
    public AccessRight getAccessRight() {
        return accessRight;
    }

    /**
     * Sets the access right for the load process
     *
     * @param accessRight The access right value
     *
     * This docstring was generated by AI.
     */
    public void setAccessRight(AccessRight accessRight) {
        this.accessRight = accessRight;
    }

    /**
     * Returns the access level.
     *
     * @return The access level.
     *
     * This docstring was generated by AI.
     */
    public Access.Level getLevel() {
        return level;
    }

    /**
     * Sets the level for access rights management.
     *
     * @param level The level for access rights management.
     *
     * This docstring was generated by AI.
     */
    public void setLevel(Access.Level level) {
        this.level = level;
    }

    /**
     * Returns whether this load instance is a transformer.
     *
     * @return true if this load instance is a transformer, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isTransformer() {
        return transformer;
    }

    /**
     * Sets the transformer flag for the load process.
     *
     * @param transformer <code>true</code> to enable the transformer,
     *                      <code>false</code> otherwise
     *
     * This docstring was generated by AI.
     */
    public void setTransformer(boolean transformer) {
        this.transformer = transformer;
    }

    /**
     * Returns the data manager object used for loading and parsing RDF data.
     *
     * @return The DataManager object associated with the Load class.
     *
     * This docstring was generated by AI.
     */
    public DataManager getDataManager() {
        return dataManager;
    }

    /**
     * Sets the DataManager for the Load instance.
     *
     * @param dataManager The DataManager instance.
     *
     * This docstring was generated by AI.
     */
    public void setDataManager(DataManager dataManager) {
        this.dataManager = dataManager;
    }

    /**
     * Returns the in-memory representation of an RDF graph.
     *
     * @return The {@link Graph} object containing the RDF data.
     *
     * This docstring was generated by AI.
     */
    public Graph getGraph() {
        return graph;
    }

    /**
     * Sets the graph object to be loaded with RDF data.
     *
     * @param graph The {@link Graph} object that will receive the parsed RDF data.
     *
     * This docstring was generated by AI.
     */
    public void setGraph(Graph graph) {
        this.graph = graph;
    }

    /**
     * Returns the limit of triples to be loaded
     *
     * @return The limit of triples to be loaded
     *
     * This docstring was generated by AI.
     */
    public int getLimit() {
        return limit;
    }

    /**
     * Returns the URI of the named graph.
     *
     * @return The URI of the named graph.
     *
     * This docstring was generated by AI.
     */
    public String getNamedGraphURI() {
        return namedGraphURI;
    }

    /**
     * Sets the URI of the named graph.
     *
     * @param namedGraphURI The URI of the named graph.
     *
     * This docstring was generated by AI.
     */
    public void setNamedGraphURI(String namedGraphURI) {
        this.namedGraphURI = namedGraphURI;
    }

    /**
     * Returns whether the load operation is a SPARQL update.
     *
     * @return true if the load operation is a SPARQL update, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isSparqlUpdate() {
        return sparqlUpdate;
    }

    /**
     * Sets the flag to enable SPARQL updates.
     *
     * @param sparqlUpdate The flag value
     *
     * This docstring was generated by AI.
     */
    public void setSparqlUpdate(boolean sparqlUpdate) {
        this.sparqlUpdate = sparqlUpdate;
    }

    // do not process transaction when load is in sparql update
    // because transaction is already processed by sparql update call
    /**
     * Indicates if the transaction can be processed
     *
     * @return true if it's not a SPARQL update and there is a DataManager set, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean processTransaction() {
        return !isSparqlUpdate() && getDataManager() != null;
    }

}
