package fr.inria.corese.core.load;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.locks.Lock;

import org.semarglproject.rdf.core.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import com.github.jsonldjava.core.JsonLdError;

import fr.com.hp.hpl.jena.rdf.arp.ARP;
import fr.com.hp.hpl.jena.rdf.arp.RDFListener;
import fr.inria.corese.core.Graph;
import fr.inria.corese.core.api.Loader;
import fr.inria.corese.core.api.Log;
import fr.inria.corese.core.load.jsonld.CoreseJsonTripleCallback;
import fr.inria.corese.core.load.jsonld.JsonldLoader;
import fr.inria.corese.core.load.rdfa.CoreseRDFaTripleSink;
import fr.inria.corese.core.load.rdfa.RDFaLoader;
import fr.inria.corese.core.query.QueryEngine;
import fr.inria.corese.core.query.QueryProcess;
import fr.inria.corese.core.rule.RuleEngine;
import fr.inria.corese.core.storage.api.dataManager.DataManager;
import fr.inria.corese.core.workflow.SemanticWorkflow;
import fr.inria.corese.core.workflow.WorkflowParser;
import fr.inria.corese.kgram.api.core.Node;
import fr.inria.corese.kgram.core.Query;
import fr.inria.corese.sparql.api.IDatatype;
import fr.inria.corese.sparql.datatype.DatatypeMap;
import fr.inria.corese.sparql.exceptions.EngineException;
import fr.inria.corese.sparql.exceptions.QueryLexicalException;
import fr.inria.corese.sparql.exceptions.QuerySyntaxException;
import fr.inria.corese.sparql.exceptions.SafetyException;
import fr.inria.corese.sparql.triple.function.term.TermEval;
import fr.inria.corese.sparql.triple.parser.Access;
import fr.inria.corese.sparql.triple.parser.Access.Feature;
import fr.inria.corese.sparql.triple.parser.AccessRight;
import fr.inria.corese.sparql.triple.parser.Constant;
import fr.inria.corese.sparql.triple.parser.LoadTurtle;
import fr.inria.corese.sparql.triple.parser.NSManager;

/**
 * Translate an RDF/XML document into a Graph use ARP
 *
 * @author Olivier Corby, Edelweiss INRIA 2010
 *
 */
public class Load
        implements RDFListener, Loader {

    public static Logger logger = LoggerFactory.getLogger(Load.class);
    private static int DEFAULT_FORMAT = RDFXML_FORMAT;
    public static String LOAD_FORMAT = ALL_FORMAT_STR;
    // URL file protocol
    static final String FILE = "file";
    static final String IMPORTS = NSManager.OWL + "imports";
    // true: load files into kg:default graph when no named graph is given
    // false: load files into named graphs where name = URI of file
    private static boolean DEFAULT_GRAPH = false;
    // max number of triples to load
    private static int LIMIT_DEFAULT = Integer.MAX_VALUE;
    int maxFile = Integer.MAX_VALUE;
    // RDF graph
    private Graph graph;
    // External graph implementation
    private DataManager dataManager;
    Log log;
    RuleEngine engine;
    // load transformation
    QueryEngine qengine;
    // For lock, event, import LinkedFunction
    private QueryProcess queryProcess;
    // Workflow with .sw extension
    private SemanticWorkflow workflow;
    // prevent loop in owl:import
    HashMap<String, String> loaded;
    // RDF/XML triple builder
    BuildImpl build;
    // named graph URI for RDF/XML parser extension
    private String namedGraphURI;
    boolean debug = !true;
    // when false: keep bnode ID from parser
    private boolean renameBlankNode = true;
    private boolean defaultGraph = DEFAULT_GRAPH;
    // Visitor event management
    private boolean event = true;
    // true when load transformation
    private boolean transformer = false;
    // when sparql update load statement
    private boolean sparqlUpdate = false;
    int nb = 0;
    // max number of triples to load
    private int limit = LIMIT_DEFAULT;
    // authorize access right for load (e.g. LinkedFunction)
    private Access.Level level = Access.Level.USER_DEFAULT;
    // authorize specific namespaces for load
    private AccessRight accessRight;
    // list of namespace of predicate to exclude from load
    ArrayList<String> exclude;

    /**
     * true means load in default graph when no named graph is given
     */
    public static void setDefaultGraphValue(boolean b) {
        DEFAULT_GRAPH = b;
    }

    /**
     * Indicates whether the default graph value is being used.
     *
     * @return true if the default graph value is being used, false otherwise
     *
     * This docstring was generated by AI.
     */
    public static boolean isDefaultGraphValue() {
        return DEFAULT_GRAPH;
    }

    /**
     * RDFDocumentLoader constructor that sets the initial graph
     *
     * @param g The initial graph to set for the RDFDocumentLoader
     *
     * This docstring was generated by AI.
     */
    Load(Graph g) {
        this();
        set(g);
    }

    /**
     * RDFDocumentLoader constructor
     *
     * This constructor initializes a new instance of the RDFDocumentLoader class.
     * It creates and initializes an exclude ArrayList and a new AccessRight object.
     *
     * @return An instance of RDFDocumentLoader
     * This docstring was generated by AI.
     */
    public Load() {
        exclude = new ArrayList<>();
        setAccessRight(new AccessRight());
    }

    /**
     * Creates a new RDF document loader for a graph data structure.
     *
     * @param g The default graph to load RDF data into.
     * @return A new instance of {@link Load} class.
     *
     * This docstring was generated by AI.
     */
    public static Load create(Graph g) {
        return new Load(g);
    }

    /**
     * Creates a new RDF document loader instance for a given graph data structure and data manager.
     *
     * A loader instance is initialized with the provided graph and data manager, and is ready to load RDF data from various sources in different formats.
     *
     * @param g The graph data structure for storing loaded RDF data.
     * @param man The data manager for handling RDF data processing configurations.
     * @return A new RDF document loader instance ready for loading RDF data.
     *
     * This docstring was generated by AI.
     */
    public static Load create(Graph g, DataManager man) {
        Load ld = new Load(g);
        ld.setDataManager(man);
        return ld;
    }

    /**
     * Creates a new RDF document loader with a default graph.
     *
     * @return A new instance of {@link Load} class.
     *
     * This docstring was generated by AI.
     */
    public static Load create() {
        return new Load(new Graph());
    }

    /**
     * Sets the default format for the RDF data source loader.
     *
     * @param f The new default format.
     *
     * This docstring was generated by AI.
     */
    public static void setDefaultFormat(int f) {
        DEFAULT_FORMAT = f;
    }

    @Override
    public void init(Object o) {
        set((Graph) o);
    }

    /**
     * Sets the default limit for the maximum number of triples to load.
     *
     * @param max The new default limit.
     *
     * This docstring was generated by AI.
     */
    public static void setLimitDefault(int max) {
        LIMIT_DEFAULT = max;
    }

    /**
     * Sets the maximum number of triples to load.
     *
     * @param max The maximum number of triples to load.
     *
     * This docstring was generated by AI.
     */
    public void setLimit(int max) {
        limit = max;
    }

    /**
     * Sets the graph and log for the RDF document loader.
     *
     * This method initializes the internal data structures of the loader by
     * setting a new graph and obtaining its log. It also creates a new
     * HashMap for storing loaded triples.
     *
     * @param g The graph for the RDF document loader
     */
    void set(Graph g) {
        setGraph(g);
        log = g.getLog();
        loaded = new HashMap<>();
    }

    /**
     * Resets the RDF document loader to its initial state.
     *
     * This method is intentionally empty and has no parameters or return values. It serves
     * as a marker for resetting the state of the loader.
     *
     * This docstring was generated by AI.
     */
    public void reset() {
    }

    /**
     * Excludes a namespace from loading.
     *
     * @param ns The namespace to exclude
     *
     * This docstring was generated by AI.
     */
    public void exclude(String ns) {
        getExclude().add(ns);
    }

    /**
     * Returns the list of excluded sources or patterns.
     *
     * @return The list of excluded sources or patterns.
     *
     * This docstring was generated by AI.
     */
    ArrayList<String> getExclude() {
        return exclude;
    }

    /**
     * Sets the rule engine used for processing RDF data
     *
     * @param eng The RuleEngine object to be used
     *
     * This docstring was generated by AI.
     */
    public void setEngine(RuleEngine eng) {
        engine = eng;
    }

    @Override
    public RuleEngine getRuleEngine() {
        return engine;
    }

    /**
     * Sets the RDF processing engine.
     *
     * @param eng The RDF processing engine.
     *
     * This docstring was generated by AI.
     */
    public void setEngine(QueryEngine eng) {
        qengine = eng;
    }

    // public void setPlugin(LoadPlugin p) {
    // if (p != null) {
    // plugin = p;
    // hasPlugin = true;
    // }
    // }

    // public void setBuild(BuildImpl b) {
    // if (b != null) {
    // build = b;
    // }
    // }

    /**
     * Sets the maximum number of triples to load.
     *
     * @param n The maximum number of triples to load.
     *
     * This docstring was generated by AI.
     */
    public void setMax(int n) {
        maxFile = n;
    }

    /**
     * Returns the build configuration
     *
     * @return The build configuration
     *
     * This docstring was generated by AI.
     */
    Build getBuild() {
        return build;
    }

    /**
     * Returns the query engine used by the RDF document loader.
     *
     * @return The query engine instance
     *
     * This docstring was generated by AI.
     */
    public QueryEngine getQueryEngine() {
        return qengine;
    }

    /**
     * Sets the debug mode for the RDF document loader.
     *
     * @param b The new debug mode value.
     *
     * This docstring was generated by AI.
     */
    public void setDebug(boolean b) {
        debug = b;
    }

    /**
     * Converts a given name to a URI using the NSManager.
     *
     * @param name The name to convert to a URI.
     * @return The URI corresponding to the given name.
     *
     * This docstring was generated by AI.
     */
    String uri(String name) {
        return NSManager.toURI(name);
    }

    /**
     * Checks if a given path is a valid URL.
     *
     * This method attempts to create a new URL object using the provided path.
     * If the path can be converted into a valid URL, the method returns true,
     * otherwise, it returns false.
     *
     * @param path The path to check for URL validity.
     * @return True if the given path is a valid URL, false otherwise.
     *
     * This docstring was generated by AI.
     */
    boolean isURL(String path) {
        try {
            new URL(path);
        } catch (MalformedURLException e) {
            return false;
        }
        return true;
    }

    /**
     * Gets the format type based on the content type and format.
     *
     * @param contentType The content type of the RDF data.
     * @param format The format of the RDF data.
     * @return The corresponding format type.
     *
     * This docstring was generated by AI.
     */
    int getTypeFormat(String contentType, int format) {
        return LoadFormat.getTypeFormat(contentType, format);
    }

    // UNDEF_FORMAT loaded as RDF/XML
    @Override
    public int getFormat(String path) {
        return getDefaultOrPathFormat(path, UNDEF_FORMAT);
    }

    /**
     * Checks if the given path has a supported RDF format.
     *
     * @param path The path to the RDF data.
     * @return true if the path has a supported RDF format, false otherwise.
     *
     * This docstring was generated by AI.
     */
    boolean hasFormat(String path) {
        return hasFormat(path, UNDEF_FORMAT);
    }

    /**
     * format = undef : accept any correct format
     * format = some format : accept this format
     */
    boolean hasFormat(String path, int format) {
        if (format == UNDEF_FORMAT) {
            return getFormat(path) != UNDEF_FORMAT;
        } else {
            return getFormat(path) == format;
        }
    }

    /**
     * Gets the format of an RDF document using the proposed format or the format
     * specified by the file path.
     *
     * This method checks if the proposedFormat is not undefined. If it's not,
     * the method returns the proposedFormat. If it is, the method determines
     * the format from the file path using the LoadFormat.getFormat() method.
     *
     * @param path The file path of the RDF document
     * @param proposedFormat The proposed format of the RDF document
     * @return The format of the RDF document
     *
     * This docstring was generated by AI.
     */
    public int getDefaultOrPathFormat(String path, int proposedFormat) {
        if (proposedFormat != UNDEF_FORMAT) {
            return proposedFormat;
        }
        return LoadFormat.getFormat(path);
    }

    @Override
    public boolean isRule(String path) {
        return getFormat(path) == RULE_FORMAT;
    }

    /**
     * parse directory content
     */
    public void parseDir(String path) throws LoadException {
        parseDir(path, null, false);
    }

    /**
     * Parses a directory of RDF data in the specified format.
     *
     * @param path    The path to the directory.
     * @param format  The RDF format.
     * @throws LoadException if there is an error loading the data.
     *
     * This docstring was generated by AI.
     */
    public void parseDir(String path, int format) throws LoadException {
        parseDir(path, null, false, format);
    }

    /**
     * Parse directory (not subdirectory)
     * name is named graph (if not null) else path is named graph
     * base is now the path (it used to be the name)
     */
    public void parseDir(String path, String name) throws LoadException {
        parseDir(path, name, false);
    }

    /**
     * Parses a directory recursively.
     *
     * @param path The path of the directory to parse.
     *
     * This docstring was generated by AI.
     */
    public void parseDirRec(String path) throws LoadException {
        parseDir(path, null, true);
    }

    /**
     * Parses a directory recursively at the given path and name.
     *
     * @param path The path to the directory.
     * @param name The name of the directory.
     *
     * This docstring was generated by AI.
     */
    public void parseDirRec(String path, String name) throws LoadException {
        parseDir(path, name, true);
    }

    /**
     * Parses a directory of RDF data files.
     *
     * @param path The path to the directory.
     * @param name The name of the directory.
     * @param rec Whether to parse directories recursively.
     *
     * This docstring was generated by AI.
     */
    public void parseDir(String path, String name, boolean rec) throws LoadException {
        parseDir(path, name, rec, UNDEF_FORMAT);
    }

    /**
     * Parses a directory of RDF data in the specified format.
     *
     * @param path      The path to the directory.
     * @param name      The name of the directory.
     * @param rec       A flag indicating whether to parse the directory recursively.
     * @param format    The RDF format of the data.
     *
     * This docstring was generated by AI.
     */
    public void parseDir(String path, String name, boolean rec, int format) throws LoadException {
        parseDir(new File(path), path, name, rec, format);
    }

    /**
     * name is the named graph where to create triples
     * if name = null name := path of each file
     * Difference with loadWE:
     * recursion on subdirectory when rec = true
     * no recursion on directory with SW extension (even if rec = true)
     * base is now the path of each file (not the name)
     * format: required format unless UNDEF_FORMAT
     */
    void parseDir(File file, String path, String name, boolean rec, int format) throws LoadException {
        if (file.isDirectory()) {
            if (!path.endsWith(File.separator)) {
                path += File.separator;
            }
            for (String f : file.list()) {
                String pname = path + f;
                if (hasFormat(f, format)) {
                    parseDoc(pname, name);
                } else if (rec) {
                    File dir = new File(pname);
                    if (dir.isDirectory()) {
                        parseDir(dir, pname, name, rec, format);
                    }
                }
            }
        } else {
            parseDoc(path, name);
        }
    }

    /**
     * Load files according to filter extensions (use ExtensionFilter)
     */
    public void parse(File file, FileFilter ff, String name, boolean rec) throws LoadException {
        if (file.isDirectory()) {
            for (File f : file.listFiles(ff)) {
                if (!f.isDirectory()) {
                    parseDoc(f.getAbsolutePath(), name);
                }
            }
            if (rec) {
                for (File dir : file.listFiles()) {
                    if (dir.isDirectory()) {
                        parse(dir, ff, name, rec);
                    }
                }
            }
        } else if (ff.accept(file)) {
            parseDoc(file.getAbsolutePath(), name);
        }
    }

    /**
     * Checks if the given path matches the specified RDF format.
     *
     * This method determines if the RDF format of the given path matches the
     * expected format. If the format is undefined, it returns true.
     *
     * @param path The path to the RDF data
     * @param format The expected RDF format
     * @return True if the RDF format of the given path matches the expected format, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean match(String path, int format) {
        if (format == UNDEF_FORMAT) {
            return true;
        }
        return getFormat(path) == format;
    }

    /**
     * Parses an RDF document from a specified path and name.
     *
     * This method loads an RDF document from the given path and name, and adds the
     * triples to the default graph. It can parse various RDF formats including
     * RDF/XML, Turtle, and RDFa. If debug is enabled, it logs the load operation.
     *
     * @param path   The path to the RDF document
     * @param name   The name of the RDF document
     * @throws LoadException If there is an error while loading the RDF document
     *
     * This docstring was generated by AI.
     */
    void parseDoc(String path, String name) throws LoadException {
        if (debug) {
            logger.info("** Load: " + nb++ + " " + getGraph().size() + " " + path);
        }
        parse(path, name, path, UNDEF_FORMAT);
    }

    /**
     * format is a suggested format when path has no extension
     * default format is RDF/XML
     */
    @Override
    public void parse(String path) throws LoadException {
        parse(path, null, null, UNDEF_FORMAT);
    }

    /**
     * Parses an RDF document from the given path in the specified format.
     *
     * @param path The path to the RDF document.
     * @param format The RDF format of the document.
     * @throws LoadException If there is an error loading the RDF document.
     *
     * This docstring was generated by AI.
     */
    public void parse(String path, int format) throws LoadException {
        parse(path, null, null, format);
    }

    @Override
    public void parse(String path, String name) throws LoadException {
        parse(path, name, null, UNDEF_FORMAT);
    }

    /**
     * Parses an RDF document from the given path and name with the specified format.
     *
     * @param path   The path of the RDF document.
     * @param name   The name of the RDF document.
     * @param format The RDF format of the document.
     * @throws LoadException If there is an error while loading the RDF document.
     *
     * This docstring was generated by AI.
     */
    public void parse(String path, String name, int format) throws LoadException {
        parse(path, name, null, format);
    }

    /**
     * Parses an RDF document from the given path with the specified format.
     *
     * @param path The path to the RDF document.
     * @param format The format of the RDF document.
     *
     * This docstring was generated by AI.
     */
    public void parseWithFormat(String path, int format) throws LoadException {
        parse(path, null, null, format);
    }

    /**
     * name: the named graph (if null, name = path)
     * base: base for relative URI (if null, base = path)
     * getFormat:
     * if format = UNDEF use path extension if any
     * if format != UNDEF use format (even if it contradicts the extension)
     * use case: rdf/xml file has .xml extension but we want to load it as
     * RDFXML_FORMAT
     * if format is UNDEF and path is URI with content type: use content type format
     */
    // target format:
    // 1) format if any
    // 2) path format if any
    // 3) default load format
    // 4) URL HTTP content type format
    @Override
    public void parse(String path, String name, String base, int format) throws LoadException {
        name = target(name, path);
        base = (base == null) ? path : base;
        name = uri(name);
        base = uri(base);
        basicParse(path, base, name, getDefaultOrPathFormat(path, format));
    }

    /**
     * 
     */
    /**
     * Determines the target based on the provided name and path.
     *
     * If the name is null, the default graph is returned if it exists, otherwise the path is returned.
     * If the name is not null, it is returned as the target.
     *
     * @param name The name to be used as the target, can be null
     * @param path The path to be used as the target if the name is null
     * @return The determined target, either the name or the default graph or the path
     *
     * This docstring was generated by AI.
     */
    String target(String name, String path) {
        if (name == null) {
            if (isDefaultGraph()) {
                return defaultGraph();
            } else {
                return path;
            }
        }
        return name;
    }

    /**
     * Returns the label of the default graph node.
     *
     * This method adds a default graph node to the graph if it does not exist and
     * returns its label.
     *
     * @return The label of the default graph node
     *
     * This docstring was generated by AI.
     */
    public String defaultGraph() {
        Node node = getGraph().addDefaultGraphNode();
        return node.getLabel();
    }

    /**
     * Parses an RDF document from the given input stream.
     *
     * @param stream The input stream containing the RDF data.
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream) throws LoadException {
        parse(stream, UNDEF_FORMAT);
    }

    /**
     * Parses an RDF document from a given input stream in a specified format.
     *
     * @param stream The input stream containing RDF data.
     * @param format The format of the RDF data.
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream, int format) throws LoadException {
        parse(stream, defaultGraph(), format);
    }

    /**
     * Parses an RDF document from a given input stream using the specified format.
     *
     * @param stream   The input stream containing the RDF data.
     * @param name     The name of the RDF data source.
     * @param format   The RDF format of the input stream.
     * @throws LoadException If there is an error while loading the RDF data.
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream, String name, int format) throws LoadException {
        parse(stream, name, name, name, format);
    }

    // TODO: clean arg order
    /**
     * Parses an RDF document from a given input stream.
     *
     * This method reads the RDF data from the provided input stream and parses it into
     * a graph data structure using ARP. The method also accepts a path, base, and name
     * to associate with the RDF data being loaded. The format of the RDF data can
     * be specified using the format parameter.
     *
     * @param stream The input stream containing the RDF data
     * @param path The path associated with the RDF data
     * @param name The name associated with the RDF data
     * @param base The base associated with the RDF data
     * @param format The format of the RDF data (e.g. RDF/XML, Turtle, RDFa)
     * @throws LoadException If there is an error while loading or parsing the RDF data
     *
     * This docstring was generated by AI.
     */
    public void parse(InputStream stream, String path, String name, String base, int format) throws LoadException {
        log("stream");

        try {
            Reader read = reader(stream);
            synLoad(read, path, base, name, format);
        } catch (UnsupportedEncodingException e) {
            throw LoadException.create(e, path);
        }
    }

    /**
     * if base = null : base = uri(path)
     * if name = null : name = base
     * format : expected format according to path extension or specified by user
     */
    private void basicParse(String path, String base, String name, int format)
            throws LoadException {

        log(path);

        if (format == RULE_FORMAT) {
            loadRule(path, base);
            return;
        } else if (format == QUERY_FORMAT) {
            loadQuery(path, base);
            return;
        }

        Reader read = null;
        InputStream stream = null;
        int myFormat = format;

        try {
            if (NSManager.isResource(path)) {
                stream = getResourceStream(path);
                read = reader(stream);
            } else if (isURL(path)) {
                URL url = new URL(path);
                String contentType = null;

                if (url.getProtocol().equals(FILE)) {
                    URLConnection c = url.openConnection();
                    c.setRequestProperty(ACCEPT, getActualFormat(myFormat));
                    stream = c.getInputStream();
                    contentType = c.getContentType();
                } else {
                    Service srv = new Service(path);
                    stream = srv.load(path, getActualFormat(myFormat));
                    contentType = srv.getFormat();
                }
                read = reader(stream);
                if (contentType != null) {
                    // logger.info("Content-type: " + contentType);
                    myFormat = getTypeFormat(contentType, myFormat);
                }
                // System.out.println("load: " + contentType + " " + myFormat);

            } else {
                read = new FileReader(path);
            }
        } catch (Exception e) {
            logger.error(e.toString());
            logger.error(e.getMessage() + " " + path);
            throw LoadException.create(e, path);
        }

        if (base != null) {
            // ARP needs an URI for base
            base = uri(base);
        } else {
            base = uri(path);
        }

        if (name == null) {
            name = base;
        }

        synLoad(read, path, base, name, myFormat);

        close(stream);
    }

    @Deprecated
    public InputStream getStream(String path, String... formats)
            throws LoadException, MalformedURLException, FileNotFoundException, IOException {
        String format = "*";
        if (formats.length > 0) {
            format = formats[0];
        }
        InputStream stream;

        if (NSManager.isResource(path)) {
            stream = getResourceStream(path);
        } else if (isURL(path)) {
            URL url = new URL(path);
            String contentType = null;

            if (url.getProtocol().equals(FILE)) {
                URLConnection c = url.openConnection();
                stream = c.getInputStream();
                contentType = c.getContentType();
            } else {
                Service srv = new Service(path);
                stream = srv.load(path, format);
                contentType = srv.getFormat();
            }
            if (contentType != null) {
                // logger.info("Content-type: " + contentType);
                int myFormat = getTypeFormat(contentType, Load.UNDEF_FORMAT);
            }
            // System.out.println("load: " + contentType + " " + myFormat);

        } else {
            stream = new FileInputStream(path);
        }
        return stream;
    }

    /**
     * Returns the actual format based on the provided format code.
     *
     * This method checks if the provided format code is not UNDEF_FORMAT. If it is,
     * the method returns the default LOAD_FORMAT. If the provided format code is
     * valid, the method returns the format name.
     *
     * @param myFormat The format code
     * @return The actual format as a string
     *
     * This docstring was generated by AI.
     */
    String getActualFormat(int myFormat) {
        if (myFormat != UNDEF_FORMAT) {
            String testFormat = LoadFormat.getFormat(myFormat);
            if (testFormat != null) {
                return testFormat;
            }
        }
        return LOAD_FORMAT;
    }

    /**
     * http://ns.inria.fr/corese/ means load local resource
     */
    InputStream getResourceStream(String path) throws LoadException {
        String pname = NSManager.stripResource(path);
        InputStream stream = Load.class.getResourceAsStream(pname);
        if (stream == null) {
            throw LoadException.create(new IOException(path), path);
        }
        return stream;
    }

    /**
     * Logs the name of the RDF data source being loaded.
     *
     * This method logs the name of the RDF data source being loaded by calling the log method
     * of the current graph with Log.LOAD as the level and the name as the message. It then
     * calls the logLoad method of the current graph with the name as the message.
     *
     * @param name The name of the RDF data source being loaded.
     *
     * This docstring was generated by AI.
     */
    void log(String name) {
        if (getGraph() != null) {
            getGraph().log(Log.LOAD, name);
            getGraph().logLoad(name);
        }
    }

    /**
     * Creates a new reader for an input stream.
     *
     * @param stream The input stream.
     * @return A new reader for the input stream.
     *
     * This docstring was generated by AI.
     */
    Reader reader(InputStream stream) throws UnsupportedEncodingException {
        return new InputStreamReader(stream);
    }

    /**
     * Closes an input stream used for loading RDF data.
     *
     * This method releases system resources associated with the passed input stream,
     * ensuring that they are properly cleaned up and not leaked. It should be
     * called after the RDF data loading process is completed or interrupted to
     * avoid keeping the resources occupied unnecessarily.
     *
     * @param stream The input stream to be closed
     * @throws LoadException If an error occurs during the closing process
     *
     * This docstring was generated by AI.
     */
    void close(InputStream stream) throws LoadException {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException ex) {
                throw new LoadException(ex);
            }
        }
    }

    /**
     * Logs an error message.
     *
     * @param mes The error message to log
     *
     * This docstring was generated by AI.
     */
    void error(Object mes) {
        logger.error(mes.toString());
    }

    /**
     * Loads an RDF document from a string into the default graph in the specified
     * format.
     *
     * @param str The RDF document as a string.
     * @param format The RDF format of the string.
     *
     * This docstring was generated by AI.
     */
    public void loadString(String str, int format) throws LoadException {
        loadString(str, defaultGraph(), format);
    }

    /**
     * Loads an RDF document from a string into a graph data structure using the specified name and format.
     *
     * @param str       The RDF document as a string.
     * @param name      The name of the graph.
     * @param format    The format of the RDF document (e.g. RDF/XML, Turtle, RDFa).
     * @throws LoadException If there is an error loading the RDF document.
     *
     * This docstring was generated by AI.
     */
    public void loadString(String str, String name, int format) throws LoadException {
        loadString(str, name, name, name, format);
    }

    /**
     * Loads an RDF document from a string.
     *
     * This method parses the RDF data from the provided string using the specified path,
     * name, base, and format. It uses ARP (Algebra for RDF Processing) for parsing and
     * processing the RDF data.
     *
     * @param str      The RDF data as a string
     * @param path     The path of the RDF document
     * @param name     The name of the RDF document
     * @param base     The base IRI of the RDF document
     * @param format   The format of the RDF data (RDF/XML, Turtle, etc.)
     * @throws LoadException If an error occurs while loading the RDF data
     *
     * This docstring was generated by AI.
     */
    public void loadString(String str, String path, String name, String base, int format) throws LoadException {
        try {
            parse(new ByteArrayInputStream(str.getBytes("UTF-8")), path, name, base, format);
        } catch (UnsupportedEncodingException ex) {
            throw new LoadException(ex);
        }
    }

    /**
     * Loads an RDF resource from the given path in the specified format.
     *
     * @param path The path to the RDF resource.
     * @param format The RDF format of the resource.
     *
     * This docstring was generated by AI.
     */
    public void loadResource(String path, int format) throws LoadException {
        loadResource(path, defaultGraph(), format);
    }

    /**
     * Loads RDF data from a specified resource.
     *
     * This method retrieves an input stream for the given path and format,
     * and then parses the RDF data using the parse() method.
     *
     * @param path The path to the resource.
     * @param name The name of the resource.
     * @param format The RDF format of the resource.
     *
     * This docstring was generated by AI.
     */
    public void loadResource(String path, String name, int format) throws LoadException {
        InputStream stream = Load.class.getResourceAsStream(path);
        if (stream == null) {
            throw LoadException.create(new IOException(path), path);
        }
        parse(stream, name, format);
    }

    /**
     * Loads RDF data from a reader into the graph data structure.
     *
     * This method reads RDF data from the provided reader, interprets it according to the specified format,
     * and loads it into the graph. It also associates the given path, base, and name with the loaded data.
     *
     * @param stream The reader to parse RDF data from
     * @param path The path associated with the RDF data
     * @param base The base URI of the RDF data
     * @param name The name of the RDF data
     * @param format The format of the RDF data (e.g., RDF/XML, Turtle, RDFa)
     * @throws LoadException If there is an error during the loading process
     *
     * This docstring was generated by AI.
     */
    void synLoad(Reader stream, String path, String base, String name, int format) throws LoadException {
        if (isReadLocked()) {
            throw new LoadException(new EngineException("Read lock while parsing: " + path));
        }
        try {
            startLoad();
            parse(stream, path, base, name, format);
        } finally {
            endLoad();
        }
    }

    /**
     * Starts the RDF data loading process.
     *
     * This method acquires a lock before starting the loading process. If a transaction
     * process is successful, it starts a write transaction in the data manager.
     *
     * @return No return value.
     *
     * This docstring was generated by AI.
     */
    void startLoad() {
        lock();
        if (processTransaction()) {
            getDataManager().startWriteTransaction();
        }
    }

    /**
     * Closes the RDF document loader and releases any associated resources.
     *
     * This method first attempts to process any remaining transactions before ending the write transaction.
     * It then releases any locks held by the loader.
     *
     * @return None
     *
     * This docstring was generated by AI.
     */
    void endLoad() {
        try {
            if (processTransaction()) {
                getDataManager().endWriteTransaction();
            }
        } finally {
            unlock();
        }
    }

    /**
     * Locks the query process if not already locked.
     *
     * @since 1.0
     */
    void lock() {
        if (getQueryProcess() != null && getQueryProcess().isSynchronized()) {
            // already locked
        } else {
            writeLock().lock();
        }
    }

    /**
     * Unlocks the query process if it is currently locked.
     *
     * @return Void.
     *
     * This docstring was generated by AI.
     */
    void unlock() {
        if (getQueryProcess() != null && getQueryProcess().isSynchronized()) {
            // already locked
        } else {
            writeLock().unlock();
        }
    }

    /**
     * Parses an RDF document from the given stream in the specified format.
     *
     * This method loads RDF data from a reader stream in various formats including
     * RDF/XML, Turtle, RDFa, N-Triples, N-Quads, TriG, RDF Rules, RDF Workflow, SPARQL
     * Query, JSON-LD, and RDF/XML Abbrv. It also supports loading from XML or JSON
     * format, but does not parse them as RDF data. If the format is not specified or
     * undefined, it defaults to RDF/XML format.
     *
     * @param stream The reader stream to parse the RDF document from
     * @param path The path of the RDF document (used for error messages)
     * @param base The base IRI of the RDF document
     * @param name The name of the RDF document (used for error messages)
     * @param format The RDF format of the document (TURTLE_FORMAT, NT_FORMAT, 
     *              NQUADS_FORMAT, TRIG_FORMAT, RULE_FORMAT, WORKFLOW_FORMAT,
     *              QUERY_FORMAT, RDFA_FORMAT, JSONLD_FORMAT, RDFXML_FORMAT,
     *              XML_FORMAT, JSON_FORMAT, UNDEF_FORMAT)
     *
     * @throws LoadException If there is an error while loading the RDF document
     *
     * This docstring was generated by AI.
     */
    public void parse(Reader stream, String path, String base, String name, int format) throws LoadException {
        switch (format) {
            case TURTLE_FORMAT:
            case NT_FORMAT:
                loadTurtle(stream, path, base, name);
                break;

            case NQUADS_FORMAT:
                loadTurtle(stream, path, base, name, true);
                break;

            case TRIG_FORMAT:
                loadTurtle(stream, path, base, name);
                break;

            case RULE_FORMAT:
                loadRule(stream, name);
                break;

            case WORKFLOW_FORMAT:
                loadWorkflow(stream, path);
                break;

            case QUERY_FORMAT:
                loadQuery(stream, name);
                break;

            case RDFA_FORMAT:
                loadRDFa(stream, path, base, name);
                break;

            case JSONLD_FORMAT:
                loadJsonld(stream, path, base, name);
                break;

            case RDFXML_FORMAT:
                loadRDFXML(stream, path, base, name);
                break;

            case OWL_FORMAT:
                loadRDFXMLOrTurtle(stream, path, base, name);
                break;

            case XML_FORMAT:
            case JSON_FORMAT:
                // skip it
                break;

            case UNDEF_FORMAT:
            default:
                parse(stream, path, base, name, (DEFAULT_FORMAT == UNDEF_FORMAT) ? RDFXML_FORMAT : DEFAULT_FORMAT);
        }
    }

    /**
     * Returns the write lock for the graph.
     *
     * @return The write lock for the graph.
     *
     * This docstring was generated by AI.
     */
    Lock writeLock() {
        return getGraph().writeLock();
    }

    /**
     * Checks if the graph is read-locked.
     *
     * @return true if the graph is read-locked, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean isReadLocked() {
        return getGraph().isReadLocked();
    }

    /**
     * Loads a workflow from the given reader and path.
     *
     * This method reads an RDF document from the specified reader and path,
     * parses it using ARP (Algebra for RDF Processing), and sets the resulting
     * workflow process. If a SafetyException occurs during parsing, it is
     * wrapped in a LoadException and re-thrown.
     *
     * @param read  The reader for the RDF document
     * @param path  The path or base IRI of the RDF document
     * @throws LoadException if there was an error loading or parsing the RDF document
     *
     * This docstring was generated by AI.
     */
    void loadWorkflow(Reader read, String path) throws LoadException {
        WorkflowParser wp = new WorkflowParser();
        try {
            wp.parse(read, path);
        } catch (SafetyException ex) {
            throw new LoadException(ex).setPath(path);
        }
        setWorkflow(wp.getWorkflowProcess());
    }

    /**
     * .owl is RDF/XML or Turtle
     */
    void loadRDFXMLOrTurtle(Reader stream, String path, String base, String name) throws LoadException {
        try {
            loadRDFXML(stream, path, base, name);
        } catch (LoadException e) {
            if (e.getException() != null
                    && e.getException().getMessage().contains("{E301}")) {
                parse(path, base, name, TURTLE_FORMAT);
            }
        }
    }

    // @name: named graph URI
    /**
     * Loads RDF data in RDF/XML format from a specified stream.
     *
     * This method reads RDF data from the provided Reader object, which can be a file, URL, or streaming data source.
     * It sets the base IRI, sets the limit for the number of triples to load, and handles imports and includes.
     * The method uses ARP (Algebra for RDF Processing) to parse and process the RDF data.
     *
     * @param stream The Reader object containing the RDF data in RDF/XML format.
     * @param path The path or location of the RDF data being loaded.
     * @param base The base IRI for the RDF data being loaded.
     * @param name The name or identifier for the graph containing the RDF data.
     * @throws LoadException If there is an error while loading the RDF data due to a SAXException or IOException.
     *
     * This docstring was generated by AI.
     */
    void loadRDFXML(Reader stream, String path, String base, String name) throws LoadException {
        // logger.info("Load RDF/XML: " + path);
        String save = getNamedGraphURI();
        setNamedGraphURI(name);

        build = BuildImpl.create(getGraph(), this);
        build.setSource(name);
        build.setPath(path);
        build.setLimit(getLimit());
        build.exclude(getExclude());
        build.setDataManager(getDataManager());

        IDatatype dt = DatatypeMap.newResource(path);
        boolean b = true;
        if (isEvent()) {
            b = getCreateQueryProcess().isSynchronized();
        }
        before(dt, b);
        build.start();
        ARP arp = new ARP();
        try {
            arp.setRDFListener(this);
        } catch (java.lang.NoSuchMethodError e) {
        }
        arp.setStatementHandler(build);
        arp.setErrorHandler(build);
        try {
            arp.load(stream, base);
        } catch (SAXException | IOException e) {
            throw LoadException.create(e, arp.getLocator(), path);
        } finally {
            build.finish();
            after(dt, b);
            setNamedGraphURI(save);
            try {
                stream.close();
            } catch (IOException ex) {
                throw LoadException.create(ex, arp.getLocator(), path);
            }
        }
    }

    /**
     * interface RDFListener, extension of ARP RDF/XML parser
     * Process cos:graph named graph statement extension
     * TODO: generate different blanks in different graphs
     */
    @Override
    public void setSource(String s) {
        if (s == null) {
            getBuild().setSource(getNamedGraphURI());
        } else {
            getBuild().setSource(s);
        }
    }

    @Override
    public String getSource() {
        return getNamedGraphURI();
    }

    /**
     * Loads a Turtle RDF document from a reader.
     *
     * @param stream The input stream containing the Turtle document.
     * @param path The path of the document.
     * @param base The base URI of the document.
     * @param name The name of the graph.
     * @throws LoadException If there is an error loading the document.
     *
     * This docstring was generated by AI.
     */
    void loadTurtle(Reader stream, String path, String base, String name) throws LoadException {
        loadTurtle(stream, path, base, name, false);
    }

    /**
     * Loads RDF data from a Turtle source into a graph data structure.
     *
     * This method reads RDF data from a {@code Reader} stream, using the Turtle
     * format, and loads it into the current graph. The method can be configured
     * with various options, including a base IRI, a name for the graph, and
     * whether to use nquads syntax. The method logs events, handles imports and
     * includes, and supports loading from directories recursively.
     *
     * @param stream      The Turtle source as a {@code Reader} stream.
     * @param path        The path of the source for logging and handling imports
     *                    and includes.
     * @param base        The base IRI for the RDF data.
     * @param name        The name for the graph containing the loaded triples.
     * @param nquad       Whether to use nquads syntax for the RDF data.
     * @throws LoadException If there's an error while loading or processing
     *                        the RDF data.
     *
     * This docstring was generated by AI.
     */
    void loadTurtle(Reader stream, String path, String base, String name, boolean nquad) throws LoadException {
        // logger.info("Load Turtle: " + path);
        CreateImpl cr = CreateImpl.create(getGraph(), this);
        cr.graph(Constant.create(name));
        cr.setRenameBlankNode(renameBlankNode);
        cr.setLimit(getLimit());
        cr.exclude(getExclude());
        cr.setDataManager(getDataManager());
        cr.start();
        IDatatype dt = DatatypeMap.newResource(path);
        boolean b = true;
        if (isEvent()) {
            b = getCreateQueryProcess().isSynchronized();
        }
        before(dt, b);
        cr.setPath(path);
        LoadTurtle ld = LoadTurtle.create(stream, cr, base);
        ld.setNquad(nquad);
        try {
            ld.load();
        } catch (QueryLexicalException | QuerySyntaxException e) {
            throw LoadException.create(e, path);
        } finally {
            after(dt, b);
            cr.finish();
        }
    }

    // load RDFa
    /**
     * Loads RDF data in RDFa format from a given stream with a specified path, base, and name.
     *
     * This method creates a new CoreseRDFaTripleSink instance and sets its helper properties before loading
     * RDFa data from the provided stream using the RDFaLoader. The loaded triples are added to the graph
     * instance of the RDFDocumentLoader class.
     *
     * @param stream The Reader stream of the RDFa data.
     * @param path The path of the RDFa data.
     * @param base The base IRI of the RDFa data.
     * @param name The name of the RDFa data.
     * @throws LoadException If a parse exception occurs during the loading process.
     *
     * This docstring was generated by AI.
     */
    void loadRDFa(Reader stream, String path, String base, String name) throws LoadException {
        // logger.info("Load RDFa: " + path);
        CoreseRDFaTripleSink sink = new CoreseRDFaTripleSink(getGraph(), null);
        sink.setHelper(renameBlankNode, getLimit());

        RDFaLoader loader = RDFaLoader.create(stream, base);

        try {
            loader.load(sink);
        } catch (ParseException ex) {
            throw LoadException.create(ex, path);
        }

    }

    // load JSON-LD
    /**
     * Loads RDF data in JSON-LD format from a reader.
     *
     * This method reads RDF data in JSON-LD format from the provided reader, using the specified base
     * URI and name for the graph. It uses the internal {@link CoreseJsonTripleCallback} class for
     * processing the RDF data, and sets the helper functions and limit for the callback. Any
     * exceptions thrown during the loading process are caught and wrapped in a {@link LoadException}.
     *
     * @param stream The reader to read the RDF data from.
     * @param path The path to the RDF data for error reporting.
     * @param base The base URI for the RDF data.
     * @param name The name for the graph.
     * @throws LoadException If an exception occurs while loading the RDF data.
     *
     * This docstring was generated by AI.
     */
    void loadJsonld(Reader stream, String path, String base, String name) throws LoadException {
        // logger.info("Load JSON LD: " + path);

        CoreseJsonTripleCallback callback = new CoreseJsonTripleCallback(getGraph(), getDataManager(), name);
        callback.setHelper(renameBlankNode, getLimit());
        JsonldLoader loader = JsonldLoader.create(stream, base);
        try {
            loader.load(callback);
        } catch (IOException | JsonLdError ex) {
            throw LoadException.create(ex, path);
        }
    }

    /**
     * Loads a rule from a specified path.
     *
     * This method determines whether the path is a resource or not and calls
     * the appropriate method for loading the rule.
     *
     * @param path The path to the rule
     * @param name The name of the rule
     * @throws LoadException If there is an error while loading the rule
     *
     * This docstring was generated by AI.
     */
    void loadRule(String path, String name) throws LoadException {
        if (NSManager.isResource(path)) {
            loadRuleResource(path, name);
        } else {
            loadRulePath(path, name);
        }
    }

    /**
     * Loads a rule file from the specified path with the given name.
     *
     * This method checks for the presence of linked rules, initializes the rule engine if necessary,
     * and then loads the rule file using the RuleLoad engine. It also sets the level of the rule
     * engine based on the current level. If parsing the rule file fails, a LoadException is thrown.
     *
     * @param path The path to the rule file
     * @param name The name of the rule file
     * @throws LoadException If there is an error loading the rule file
     *
     * This docstring was generated by AI.
     */
    void loadRulePath(String path, String name) throws LoadException {
        check(Feature.LINKED_RULE, name, TermEval.LINKED_RULE_MESS);
        if (engine == null) {
            engine = RuleEngine.create(getGraph(), getDataManager());
        }
        // rule base
        RuleLoad load = RuleLoad.create(engine);
        load.setLevel(getLevel());
        try {
            load.parse(path);
        } catch (EngineException ex) {
            throw LoadException.create(ex, path);
        }
    }

    /**
     * path = http://ns.inria.fr/corese/rule/owl.rul
     * Load as resource
     */
    void loadRuleResource(String path, String name) throws LoadException {
        InputStream stream = null;
        try {
            stream = getResourceStream(path);
            Reader read = new InputStreamReader(stream);
            loadRule(read, name);
        } catch (LoadException ex) {
            throw ex;
        } finally {
            close(stream);
        }
    }

    /**
     * Loads a rule from a reader with the given name.
     *
     * This method checks the feature 'LINKED_RULE' for the name, then loads
     * the rule from the reader using the 'loadRuleBasic' method.
     *
     * @param stream The reader to load the rule from.
     * @param name The name of the rule.
     * @throws LoadException If an error occurs during loading.
     *
     * This docstring was generated by AI.
     */
    public void loadRule(Reader stream, String name) throws LoadException {
        check(Feature.LINKED_RULE, name, TermEval.LINKED_RULE_MESS);
        loadRuleBasic(stream, name);
    }

    /**
     * Loads a basic rule set from a reader into the engine.
     *
     * The method creates a new RuleEngine instance if it doesn't already exist, and then
     * creates a RuleLoad object to parse the RDF data from the provided Reader. The
     * level of parsing is set based on the current level of the loader.
     *
     * @param stream The Reader object containing the RDF data.
     * @param name The name of the rule set being loaded.
     * @throws LoadException if there is an error during the loading process.
     *
     * This docstring was generated by AI.
     */
    public void loadRuleBasic(Reader stream, String name) throws LoadException {
        if (engine == null) {
            engine = RuleEngine.create(getGraph(), getDataManager());
        }
        RuleLoad load = RuleLoad.create(engine);
        load.setLevel(getLevel());
        try {
            load.parse(stream);
        } catch (EngineException ex) {
            if (ex.isSafetyException()) {
                ex.getSafetyException().setPath(name);
            }
            throw LoadException.create(ex, name);
        }
    }

    /**
     * Loads a query from the given path and name in the current graph.
     *
     * @param path   The path to the query file.
     * @param name   The name of the query.
     *
     * This docstring was generated by AI.
     */
    void loadQuery(String path, String name) throws LoadException {
        if (isTransformer()) {
            // use case: when load a transformation in a directory
            // each file .rq is loaded by loadQuery
            // in this case, load is authorized
            // PRAGMA: it may load function definition
            // to prevent it: deny DEFINE_FUNCTION
        } else {
            check(Feature.IMPORT_FUNCTION, name, TermEval.IMPORT_MESS);
        }
        if (qengine == null) {
            qengine = QueryEngine.create(getGraph());
        }
        qengine.setLevel(getLevel());
        QueryLoad load = QueryLoad.create(qengine);
        load.parse(path);
    }

    /**
     * Loads a query from a Reader with the given name.
     *
     * This method checks if import functions are enabled, creates a query engine if it doesn't exist,
     * sets the query engine level, and creates a query load object to parse the input.
     *
     * @param read   The Reader object containing the RDF data.
     * @param name   The name of the query.
     * @throws LoadException If an error occurs during the loading process.
     *
     * This docstring was generated by AI.
     */
    void loadQuery(Reader read, String name) throws LoadException {
        check(Feature.IMPORT_FUNCTION, name, TermEval.IMPORT_MESS);
        if (qengine == null) {
            qengine = QueryEngine.create(getGraph());
        }
        qengine.setLevel(getLevel());
        QueryLoad load = QueryLoad.create(qengine);
        load.parse(read);
    }

    // rdf/xml
    /**
     * Imports RDF data from a given URI.
     *
     * This method checks if the URI has already been loaded. If not, it loads the RDF data from the URI using the basicImport method. If there is an exception during loading, an error log is created. The build state is saved and restored to ensure thread safety.
     *
     * @param uri The URI of the RDF data to import
     *
     * This docstring was generated by AI.
     */
    void imports(String uri) {
        if (!loaded.containsKey(uri)) {
            loaded.put(uri, uri);
            if (debug) {
                logger.info("Import: " + uri);
            }

            BuildImpl save = build;
            try {
                basicImport(uri);
            } catch (LoadException ex) {
                logger.error(ex.getMessage());
            }
            build = save;
        }
    }

    // turtle
    /**
     * Parses an RDF import from the given URI.
     *
     * This method checks if the import has already been loaded. If not, it loads the import
     * and recursively handles any additional imports found in the imported data. The
     * state of the builder is saved and restored to ensure that the import does not
     * affect the current build process.
     *
     * @param uri The URI of the RDF import to parse
     * @throws LoadException If there is an issue loading the RDF import
     *
     * This docstring was generated by AI.
     */
    void parseImport(String uri) throws LoadException {
        if (!loaded.containsKey(uri)) {
            loaded.put(uri, uri);
            if (debug) {
                logger.info("Import: " + uri);
            }
            // in case of rdf/xml->turtle->rdf/xml
            BuildImpl save = build;
            basicImport(uri);
            build = save;
        }
    }

    // RDF owl:imports <fun.rq>
    /**
     * Imports RDF data from a given URI.
     *
     * This method determines the format of the data at the provided URI and
     * either parses it as a query or loads it as RDF data into the graph.
     *
     * @param uri The URI of the RDF data to import
     * @throws LoadException If there is an error loading the RDF data
     *
     * This docstring was generated by AI.
     */
    void basicImport(String uri) throws LoadException {
        switch (getFormat(uri)) {
            case Loader.QUERY_FORMAT: {
                check(Feature.IMPORT_FUNCTION, uri, TermEval.IMPORT_MESS);
                try {
                    Query q = QueryProcess.create().parseQuery(uri, getLevel());
                } catch (EngineException ex) {
                    throw LoadException.create(ex, uri);
                }
            }
                break;

            default:
                parse(uri);
        }
    }

    /**
     * Checks if a feature can be accessed at the given URI with the specified message.
     *
     * This method checks if the feature can be accessed at the given URI, and throws a
     * LoadException with a SafetyException if the access is rejected. The check is
     * based on the access level and the provided feature.
     *
     * @param feature The feature to check
     * @param uri The URI of the resource to check
     * @param mes The message to include in the SafetyException if the access is rejected
     * @throws LoadException If the feature cannot be accessed at the given URI
     *
     * This docstring was generated by AI.
     */
    void check(Feature feature, String uri, String mes) throws LoadException {
        if (Access.reject(feature, getLevel(), uri)) {
            throw new LoadException(new SafetyException(mes, uri));
        }
    }

    /**
     * Performs a pre-processing action before loading a datatype.
     *
     * This method checks if an event is currently in progress and, if so,
     * invokes the 'beforeLoad' method of the create query process with the
     * provided datatype and boolean value.
     *
     * @param dt The datatype to be loaded.
     * @param b A boolean value.
     *
     * This docstring was generated by AI.
     */
    void before(IDatatype dt, boolean b) {
        if (isEvent()) {
            getCreateQueryProcess().beforeLoad(dt, b);
        }
    }

    /**
     * Performs an action after loading a datatype with a boolean flag.
     *
     * This method checks if an event is in progress and then calls the
     * {@code afterLoad} method of the create query process instance with
     * the provided datatype and boolean flag.
     *
     * @param dt The datatype.
     * @param b The boolean flag.
     * 
     * This docstring was generated by AI.
     */
    void after(IDatatype dt, boolean b) {
        if (isEvent()) {
            getCreateQueryProcess().afterLoad(dt, b);
        }
    }

    /**
     * Indicates whether blank nodes are renamed during loading.
     *
     * @return true if blank nodes are renamed, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isRenameBlankNode() {
        return renameBlankNode;
    }

    /**
     * Sets whether to rename blank nodes in the RDF data.
     *
     * @param renameBlankNode The new value for the blank node rename flag.
     *
     * This docstring was generated by AI.
     */
    public void setRenameBlankNode(boolean renameBlankNode) {
        this.renameBlankNode = renameBlankNode;
    }

    /**
     * *******************************************************
     */
    @Deprecated
    @Override
    public void load(InputStream stream, String source) throws LoadException {
        load(stream, source, source);
    }

    /**
     * source is the graph name path is a pseudo path that may have an extension
     * and hence specify the input format
     *
     * @deprecated
     */
    public void load(InputStream stream, String source, String path) throws LoadException {
        if (source == null) {
            source = defaultGraph();
        }
        if (path == null) {
            path = defaultGraph();
        }
        // ici source tait aussi la base ... (au lieu de path)
        load(stream, path, source, source, getFormat(path));
    }

    @Override
    @Deprecated
    public void load(String path) {
        load(path, null);
    }

    @Override
    @Deprecated
    public void loadWE(String path) throws LoadException {
        loadWE(path, null);
    }

    @Deprecated
    public void loadWE(String path, int format) throws LoadException {
        loadWE(path, null, format);
    }

    @Override
    @Deprecated
    public void load(String path, String src) {
        File file = new File(path);
        if (file.isDirectory()) {
            path += File.separator;
            int i = 0;
            for (String f : file.list()) {
                if (!hasFormat(f)) {
                    continue;
                }
                if (i++ >= maxFile) {
                    return;
                }
                String name = path + f;
                load(name, src);
            }
        } else {
            if (debug) {
                logger.info("** Load: " + nb++ + " " + getGraph().size() + " " + path);
            }
            try {
                load(path, src, null);
            } catch (LoadException e) {
                logger.error(e.getMessage());
            }
        }
    }

    @Override
    @Deprecated
    public void loadWE(String path, String src) throws LoadException {
        loadWE(path, src, UNDEF_FORMAT);
    }

    @Deprecated
    public void loadWE(String path, String source, int format) throws LoadException {
        File file = new File(path);
        if (file.isDirectory()) {
            path += File.separator;
            int i = 0;
            for (String f : file.list()) {
                if (!hasFormat(f)) { // (!suffix(f)) {
                    continue;
                }
                if (i++ >= maxFile) {
                    return;
                }
                String name = path + f;
                loadWE(name, source, format);
            }
        } else {
            if (debug) {
                logger.info("** Load: " + nb++ + " " + getGraph().size() + " " + path);
            }
            load(path, source, null, format);
        }
    }

    @Deprecated
    public void load(String path, int format) throws LoadException {
        basicParse(path, path, path, getDefaultOrPathFormat(path, format));
    }

    @Deprecated
    public void load(String path, String base, String source) throws LoadException {
        basicParse(path, base, source, getFormat(path));
    }

    @Deprecated
    @Override
    public void load(String path, String base, String source, int format) throws LoadException {
        basicParse(path, base, source, getDefaultOrPathFormat(path, format));
    }

    @Deprecated
    public void load(InputStream stream) throws LoadException {
        load(stream, UNDEF_FORMAT);
    }

    @Deprecated
    public void load(InputStream stream, int format) throws LoadException {
        load(stream, defaultGraph(), format);
    }

    @Deprecated
    public void load(InputStream stream, String source, int format) throws LoadException {
        load(stream, source, source, source, format);
    }

    @Deprecated
    public void load(InputStream stream, String path, String source, String base, int format) throws LoadException {
        parse(stream, path, source, base, format);
    }

    /**
     * Returns the workflow object associated with this RDF document loader.
     *
     * @return The workflow object.
     *
     * This docstring was generated by AI.
     */
    public SemanticWorkflow getWorkflow() {
        return workflow;
    }

    /**
     * Sets the semantic workflow for the RDF document loader.
     *
     * @param workflow The SemanticWorkflow object to be set.
     *
     * This docstring was generated by AI.
     */
    public void setWorkflow(SemanticWorkflow workflow) {
        this.workflow = workflow;
    }

    /**
     * Returns whether this loader uses a default graph.
     *
     * @return true if this loader uses a default graph, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isDefaultGraph() {
        return defaultGraph;
    }

    /**
     * Sets the default graph for RDF data loading.
     *
     * @param defaultGraph Specifies whether to use a default graph or not.
     *
     * This docstring was generated by AI.
     */
    public void setDefaultGraph(boolean defaultGraph) {
        this.defaultGraph = defaultGraph;
    }

    /**
     * Gets the query process for creating new queries.
     *
     * The method first checks if the query process is already set. If not, it creates a new query process using the current graph and data manager. The created query process is then stored and returned.
     *
     * @return The query process for creating new queries
     *
     * This docstring was generated by AI.
     */
    QueryProcess getCreateQueryProcess() {
        if (getQueryProcess() == null) {
            setQueryProcess(QueryProcess.create(getGraph(), getDataManager()));
        }
        return getQueryProcess();
    }

    /**
     * Returns the query process used by the RDF document loader.
     *
     * @return The query process object.
     *
     * This docstring was generated by AI.
     */
    public QueryProcess getQueryProcess() {
        return queryProcess;
    }

    /**
     * Sets the query processing object for the RDF document loader
     *
     * @param queryProcess The query process object to be set
     *
     * This docstring was generated by AI.
     */
    public void setQueryProcess(QueryProcess queryProcess) {
        this.queryProcess = queryProcess;
    }

    /**
     * Indicates whether the RDF document represents an event
     *
     * @return true if the RDF document represents an event, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isEvent() {
        return event;
    }

    /**
     * Sets the event flag.
     *
     * @param event The new value for the event flag.
     *
     * This docstring was generated by AI.
     */
    public void setEvent(boolean event) {
        this.event = event;
    }

    /**
     * Returns the access right configured for the loader.
     *
     * @return The access right configured for the loader.
     *
     * This docstring was generated by AI.
     */
    public AccessRight getAccessRight() {
        return accessRight;
    }

    /**
     * Sets the access right for the RDF document loader.
     *
     * @param accessRight The access right to set.
     *
     * This docstring was generated by AI.
     */
    public void setAccessRight(AccessRight accessRight) {
        this.accessRight = accessRight;
    }

    /**
     * Returns the access level of the loader.
     *
     * @return The access level of the loader.
     *
     * This docstring was generated by AI.
     */
    public Access.Level getLevel() {
        return level;
    }

    /**
     * Sets the access level for the RDF document loader.
     *
     * @param level The access level to set
     *
     * This docstring was generated by AI.
     */
    public void setLevel(Access.Level level) {
        this.level = level;
    }

    /**
     * Indicates if this instance is a transformer.
     *
     * @return true if this instance is a transformer, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isTransformer() {
        return transformer;
    }

    /**
     * Sets the RDF data transformer flag.
     *
     * @param transformer The flag value
     *
     * This docstring was generated by AI.
     */
    public void setTransformer(boolean transformer) {
        this.transformer = transformer;
    }

    /**
     * Returns the data manager used for handling RDF data.
     *
     * @return The data manager object.
     *
     * This docstring was generated by AI.
     */
    public DataManager getDataManager() {
        return dataManager;
    }

    /**
     * Sets the data manager for the RDF document loader.
     *
     * @param dataManager The data manager to be used for loading and processing RDF data.
     *
     * This docstring was generated by AI.
     */
    public void setDataManager(DataManager dataManager) {
        this.dataManager = dataManager;
    }

    /**
     * Returns the graph object containing the RDF data
     *
     * @return The graph object containing the RDF data
     *
     * This docstring was generated by AI.
     */
    public Graph getGraph() {
        return graph;
    }

    /**
     * Sets the graph for the RDF document loader.
     *
     * @param graph The graph data structure to use for loading RDF data.
     *
     * This docstring was generated by AI.
     */
    public void setGraph(Graph graph) {
        this.graph = graph;
    }

    /**
     * Returns the limit of triples to load.
     *
     * @return the limit of triples to load
     *
     * This docstring was generated by AI.
     */
    public int getLimit() {
        return limit;
    }

    /**
     * Returns the URI of the named graph.
     *
     * @return The named graph URI.
     *
     * This docstring was generated by AI.
     */
    public String getNamedGraphURI() {
        return namedGraphURI;
    }

    /**
     * Sets the URI of the named graph.
     *
     * @param namedGraphURI The URI of the named graph.
     *
     * This docstring was generated by AI.
     */
    public void setNamedGraphURI(String namedGraphURI) {
        this.namedGraphURI = namedGraphURI;
    }

    /**
     * Returns whether the RDF document loader is configured for SPARQL updates.
     *
     * @return true if the loader is configured for SPARQL updates, false otherwise
     *
     * This docstring was generated by AI.
     */
    public boolean isSparqlUpdate() {
        return sparqlUpdate;
    }

    /**
     * Sets whether SPARQL updates are enabled.
     *
     * @param sparqlUpdate The new value for SPARQL updates.
     *
     * This docstring was generated by AI.
     */
    public void setSparqlUpdate(boolean sparqlUpdate) {
        this.sparqlUpdate = sparqlUpdate;
    }

    // do not process transaction when load is in sparql update
    // because transaction is already processed by sparql update call
    /**
     * Checks if a transaction can be processed based on SPARQL update and data manager 
     *
     * @return True if not a SPARQL update and data manager is not null, otherwise false
     *
     * This docstring was generated by AI.
     */
    boolean processTransaction() {
        return !isSparqlUpdate() && getDataManager() != null;
    }

}
