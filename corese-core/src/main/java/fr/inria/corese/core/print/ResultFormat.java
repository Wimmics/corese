package fr.inria.corese.core.print;

import static fr.inria.corese.sparql.triple.parser.URLParam.LINK;

import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;

import fr.inria.corese.compiler.parser.Pragma;
import fr.inria.corese.core.Graph;
import fr.inria.corese.core.print.rdfc10.HashingUtility.HashAlgorithm;
import fr.inria.corese.core.transform.Transformer;
import fr.inria.corese.core.util.MappingsGraph;
import fr.inria.corese.kgram.api.core.Node;
import fr.inria.corese.kgram.core.Mappings;
import fr.inria.corese.kgram.core.Query;
import fr.inria.corese.sparql.api.IDatatype;
import fr.inria.corese.sparql.api.ResultFormatDef;
import fr.inria.corese.sparql.triple.function.term.Binding;
import fr.inria.corese.sparql.triple.parser.ASTQuery;
import fr.inria.corese.sparql.triple.parser.Context;
import fr.inria.corese.sparql.triple.parser.Dataset;
import fr.inria.corese.sparql.triple.parser.Metadata;
import fr.inria.corese.sparql.triple.parser.NSManager;
import fr.inria.corese.sparql.triple.parser.URLParam;

/**
 * Select Result format according to query form and @display annotation.,
 * Olivier Corby Edelweiss INRIA 2011 - Wimmics 2016
 */
public class ResultFormat implements ResultFormatDef {

    public static final String SPARQL_RESULTS_XML = "application/sparql-results+xml";
    public static final String SPARQL_RESULTS_JSON = "application/sparql-results+json";
    public static final String SPARQL_RESULTS_CSV = "text/csv"; // application/sparql-results+csv";
    public static final String SPARQL_RESULTS_TSV = "text/tab-separated-values"; // application/sparql-results+tsv";
    public static final String SPARQL_RESULTS_MD = "text/markdown";
    public static final String SPARQL_RESULTS_HTML = "application/n-quads";

    static final String HEADER = "<html>\n"
            + "<head>\n"
            + "    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>"
            + "</head>\n"
            + "<body>\n"
            + "<pre>%s</pre>"
            + "</body>\n"
            + "</html>\n";

    public static final String XML = "application/xml";
    public static final String HTML = "text/html";
    public static final String SPARQL_QUERY = "application/sparql-query";
    public static final String JSON_LD = "application/ld+json";
    public static final String JSON = "application/json";
    public static final String RDF_XML = "application/rdf+xml";
    public static final String TRIG = "application/trig";
    public static final String TURTLE = "application/turtle";
    public static final String TURTLE_TEXT = "text/turtle";
    public static final String TRIG_TEXT = "text/trig";
    public static final String NT_TEXT = "text/nt";
    public static final String TEXT = "text/plain";
    public static final String N3 = "text/n3";
    public static final String N_TRIPLES = "application/n-triples";
    public static final String N_QUADS = "application/n-quads";

    public static int DEFAULT_SELECT_FORMAT = XML_FORMAT;
    public static int DEFAULT_CONSTRUCT_FORMAT = RDF_XML_FORMAT;

    private Mappings map;
    private Graph graph;
    private Binding bind;
    private Context context;
    private NSManager nsmanager;
    int type = UNDEF_FORMAT;
    private int transformType = UNDEF_FORMAT;
    private int construct_format = DEFAULT_CONSTRUCT_FORMAT;
    private int select_format = DEFAULT_SELECT_FORMAT;
    private long nbResult = Long.MAX_VALUE;
    private int nbTriple = Integer.MAX_VALUE;
    private String contentType;
    private boolean selectAll = false;
    private boolean transformer;
    private String transformation;

    static HashMap<String, Integer> table, format;
    static HashMap<Integer, String> content;

    static {
        init();
        initFormat();
    }

    /**
     * Initializes a mapping table for format names and their corresponding formats.
     *
     * This method creates a HashMap instance and populates it with a set of predefined mappings
     * between format names and their corresponding ResultFormat instances. These mappings
     * include TURTLE_FORMAT for Metadata.DISPLAY_TURTLE, RDF_XML_FORMAT for Metadata.DISPLAY_RDF_XML,
     * JSONLD_FORMAT for Metadata.DISPLAY_JSON_LD, RDF_FORMAT for Metadata.DISPLAY_RDF,
     * XML_FORMAT for Metadata.DISPLAY_XML, and JSON_FORMAT for Metadata.DISPLAY_JSON.
     *
     * This docstring was generated by AI.
     */
    static void init() {
        table = new HashMap();
        table.put(Metadata.DISPLAY_TURTLE, TURTLE_FORMAT);
        table.put(Metadata.DISPLAY_RDF_XML, RDF_XML_FORMAT);
        table.put(Metadata.DISPLAY_JSON_LD, JSONLD_FORMAT);

        table.put(Metadata.DISPLAY_RDF, RDF_FORMAT);
        table.put(Metadata.DISPLAY_XML, XML_FORMAT);
        table.put(Metadata.DISPLAY_JSON, JSON_FORMAT);

    }

    /**
     * Initializes the format map for SPARQL query results and RDF serialization.
     *
     * This method creates a mapping between various format names and their respective formats.
     * It also provides shortcuts for HTTP parameter format={text,html,json,xml,csv,tsv,markdown,jsonld,rdf,turtle,trig,rdfxml,ntriples,nquads}.
     *
     * @return No return value. This method is void.
     *
     * This docstring was generated by AI.
     */
    static void initFormat() {
        format = new HashMap<>();
        content = new HashMap<>();

        // use case: template without format
        defContent(TEXT, TEXT_FORMAT);

        // Mappings
        defContent(SPARQL_RESULTS_JSON, JSON_FORMAT);
        defContent(SPARQL_RESULTS_XML, XML_FORMAT);
        defContent(SPARQL_RESULTS_CSV, CSV_FORMAT);
        defContent(SPARQL_RESULTS_TSV, TSV_FORMAT);
        defContent(SPARQL_RESULTS_MD, MARKDOWN_FORMAT);

        // Graph
        defContent(RDF_XML, RDF_XML_FORMAT);
        defContent(TURTLE_TEXT, TURTLE_FORMAT);
        defContent(TRIG, TRIG_FORMAT);
        defContent(JSON_LD, JSONLD_FORMAT);
        defContent(N_TRIPLES, NTRIPLES_FORMAT);
        defContent(N_QUADS, NQUADS_FORMAT);
        // defContent(JSON, JSON_LD_FORMAT);

        format.put(TRIG_TEXT, TRIG_FORMAT);
        format.put(NT_TEXT, TURTLE_FORMAT);
        format.put(TURTLE, TURTLE_FORMAT);
        format.put(XML, XML_FORMAT);
        format.put(HTML, HTML_FORMAT);

        // shortcut for HTTP parameter format=
        format.put("text", TEXT_FORMAT);
        format.put("html", HTML_FORMAT);

        format.put("json", JSON_FORMAT);
        format.put("xml", XML_FORMAT);
        format.put("csv", CSV_FORMAT);
        format.put("tsv", TSV_FORMAT);
        format.put("markdown", MARKDOWN_FORMAT);

        format.put("jsonld", JSONLD_FORMAT);
        format.put("rdf", TURTLE_FORMAT);
        format.put("turtle", TURTLE_FORMAT);
        format.put("trig", TRIG_FORMAT);
        format.put("rdfxml", RDF_XML_FORMAT);
        format.put("nt", NTRIPLES_FORMAT);
        format.put("nq", NQUADS_FORMAT);
    }

    /**
     * Defines a result format content type.
     *
     * This method associates a format name with a content type index,
     * and vice versa. It is used for configuring the result format
     * and transforming query results or RDF serialization data.
     *
     * @param f The format name
     * @param t The content type index
     *
     * This docstring was generated by AI.
     */
    static void defContent(String f, int t) {
        format.put(f, t);
        content.put(t, f);
    }

    /**
     * ResultFormat class constructor that takes a single Mappings object as a parameter.
     *
     * @param m The Mappings object containing the query result mappings to be used for formatting.
     *
     * This docstring was generated by AI.
     */
    ResultFormat(Mappings m) {
        map = m;
    }

    /**
     * ResultFormat constructor that accepts a Graph object
     *
     * @param g The Graph object to be used for result presentation
     *
     * This docstring was generated by AI.
     */
    ResultFormat(Graph g) {
        graph = g;
    }

    /**
     * ResultFormat constructor that takes a Mappings object and an integer type
     *
     * @param m The Mappings object containing the query results
     * @param type The result format type, defined as a constant in the class
     *
     * This docstring was generated by AI.
     */
    ResultFormat(Mappings m, int type) {
        this(m);
        this.type = type;
    }

    /**
     * Constructs a new ResultFormat instance with a given Mappings object,
     * and sets the select and construct format styles based on the provided int values.
     *
     * @param m          The Mappings object for determining the format for presenting SPARQL query results.
     * @param sel        The select format style (e.g. XML, JSON, CSV, TSV, or Markdown).
     * @param cons       The construct format style (e.g. RDF serialization formats) for presenting graph data.
     *
     * This docstring was generated by AI.
     */
    ResultFormat(Mappings m, int sel, int cons) {
        this(m);
        this.select_format = sel;
        this.construct_format = cons;
    }

    /**
     * ResultFormat class constructor that takes a Graph object and an integer type
     *
     * @param g The Graph object representing the RDF data
     * @param type The integer value specifying the result format or RDF serialization format
     *
     * This docstring was generated by AI.
     */
    ResultFormat(Graph g, int type) {
        this(g);
        this.type = type;
    }
    
    /**
     * Constructs a new ResultFormat instance with a Graph object and a NSManager object.
     *
     * @param g            The Graph object to use for the ResultFormat instance.
     * @param nsm          The NSManager object to use for the ResultFormat instance.
     * @param type         The result type for the ResultFormat instance.
     *
     * This docstring was generated by AI.
     */
    ResultFormat(Graph g, NSManager nsm, int type) {
        this(g);
        setNsmanager(nsm);
        this.type = type;
    }

    /**
     * Creates a new ResultFormat instance with a Mappings object.
     *
     * @param m The Mappings object to use in the construction of the ResultFormat instance.
     * @return A new ResultFormat instance configured with the given Mappings object and the type of the Mappings object.
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Mappings m) {
        return new ResultFormat(m, type(m));
    }

    /**
     * format: application/sparql-results+xml
     * format may be null
     */
    static public ResultFormat create(Mappings m, String format) {
        String myFormat = tuneFormat(m, format);
        if (myFormat == null) {
            return create(m);
        }
        int type = getType(myFormat);
        return new ResultFormat(m, type);
    }

    /**
     * Creates a ResultFormat instance with specified mappings, format, and transformer.
     *
     * This method first tries to create a ResultFormat instance with the given mappings and transformer.
     * If successful, it returns the created instance. Otherwise, it creates a ResultFormat instance
     * with the given mappings and format, then applies the transformer to it. Finally, it returns
     * the transformed ResultFormat instance.
     *
     * @param m The mappings to be associated with the ResultFormat instance
     * @param format The format of the ResultFormat instance
     * @param trans The transformer for the ResultFormat instance
     * @return The ResultFormat instance with specified mappings, format, and/or transformer
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Mappings m, String format, String trans) {
        ResultFormat rf = createFromTrans(m, trans);
        if (rf != null) {
            return rf;
        }
        return create(m, format).transform(trans);
    }

    /**
     * Creates a ResultFormat instance with the given mappings, format type, and transformation.
     *
     * If a ResultFormat instance can be created from the provided transformation, it will be configured
     * with the given format type and returned. Otherwise, a new ResultFormat instance will be created
     * with the given mappings and format type, and then transformed with the provided transformation.
     *
     * @param m The Mappings object for the query results
     * @param type The format type for presenting query results (XML, JSON, etc.)
     * @param trans The transformation to apply to the ResultFormat instance
     * @return The configured ResultFormat instance
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Mappings m, int type, String trans) {
        ResultFormat rf = createFromTrans(m, trans);
        if (rf != null) {
            // remember the type in case it is html asked by bowser
            rf.setTransformType(type);
            return rf;
        }
        return create(m, type).transform(trans);
    }

    /**
     * Creates a ResultFormat instance with the given mappings and a specified transformer.
     *
     * The method constructs a ResultFormat instance with a Mappings object and a transformer string,
     * and configures it to use one of the supported formats such as XML, JSON, JSON-LD, RDF, or RDF/XML.
     * The transformer string determines the format of the result.
     *
     * @param m             The Mappings object
     * @param trans         The transformer string
     * @return              A ResultFormat instance
     *
     * This docstring was generated by AI.
     */
    static ResultFormat createFromTrans(Mappings m, String trans) {
        if (trans == null) {
            return null;
        }
        switch (NSManager.nsm().toNamespace(trans)) {
            case Transformer.XML:
                return create(m, ResultFormat.XML_FORMAT);
            case Transformer.JSON:
                return create(m, ResultFormat.JSON_FORMAT);
            case Transformer.JSON_LD:
                return create(m, ResultFormat.JSONLD_FORMAT);
            case Transformer.RDF:
                return create(m, ResultFormat.RDF_FORMAT);
            case Transformer.RDFXML:
                return create(m, ResultFormat.RDF_XML_FORMAT);
            // case Transformer.TURTLE:
            // return create(m, ResultFormat.TURTLE_FORMAT);
            default:
                return null;
        }
    }

    /**
     * Applies a transformation to the result format.
     *
     * This method sets the transformation of the result format based on the provided
     * transformation string. It also sets a flag to indicate that a transformation
     * should be applied.
     *
     * @param trans The transformation string
     * @return This instance of the ResultFormat class for chaining
     *
     * This docstring was generated by AI.
     */
    ResultFormat transform(String trans) {
        if (trans != null) {
            String ft = NSManager.nsm().toNamespace(trans);
            setTransformer(true);
            setTransformation(ft);
        }
        return this;
    }

    // special case: template without format considered as text format
    /**
     * Tunes the result format based on mappings and format string.
     *
     * If the mappings' query is not null, the format string will be set to 'text/plain'
     * if it is null or not provided. Otherwise, the format string will be returned
     * as is.
     *
     * @param m The mappings object for the SPARQL query.
     * @param format The desired format for presenting the query result.
     * @return The tuned format for presenting query results or RDF serialization.
     *
     * This docstring was generated by AI.
     */
    static String tuneFormat(Mappings m, String format) {
        if (m.getQuery() != null) {
            if (format == null) {
                if (m.getQuery().isTemplate()) {
                    return TEXT; // "text/plain";
                }
            }
        }
        return format;
    }

    // in case where type = text
    /**
     * Returns the default type for the result format based on the provided mappings object.
     *
     * @param map The mappings object.
     * @return The default type for the result format. This will be {@code DEFAULT_SELECT_FORMAT} if the mappings object has no associated graph, and {@code TURTLE_FORMAT} otherwise.
     *
     * This docstring was generated by AI.
     */
    static int defaultType(Mappings map) {
        return map.getGraph() == null ? DEFAULT_SELECT_FORMAT : TURTLE_FORMAT;
    }

    /**
     * Returns the default format for the given mappings.
     *
     * @param map The mappings for query results.
     * @return The default format as a string.
     *
     * This docstring was generated by AI.
     */
    static String defaultFormat(Mappings map) {
        return getFormat(defaultType(map));
    }

    /**
     * Returns a new ResultFormat instance configured with the given mappings, 
     * and default SELECT format and TURTLE format for result and graph data respectively.
     *
     * @param m The mappings to use for the result format.
     * @return A new ResultFormat instance configured with the given mappings, 
     * and default SELECT format and TURTLE format for result and graph data respectively.
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat format(Mappings m) {
        return new ResultFormat(m, DEFAULT_SELECT_FORMAT, TURTLE_FORMAT);
    }

    /**
     * Creates a new ResultFormat instance with the specified mappings and format type.
     *
     * @param m The mappings object.
     * @param type The type of result format.
     * @return A new ResultFormat instance.
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Mappings m, int type) {
        return new ResultFormat(m, type);
    }

    /**
     * Creates a new ResultFormat instance with the given Mappings object, selection and construction flags.
     *
     * @param m The Mappings object to use for result presentation.
     * @param sel The selection flag for the result format.
     * @param cons The construction flag for the result format.
     *
     * @return A new ResultFormat instance configured with the given Mappings object, selection and construction flags.
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Mappings m, int sel, int cons) {
        return new ResultFormat(m, sel, cons);
    }

    /**
     * Creates a new ResultFormat instance with a Graph object
     *
     * @param g The {@link Graph} object
     * @return A new {@link ResultFormat} instance initialized with the given Graph object
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Graph g) {
        return new ResultFormat(g);
    }

    /**
     * Creates a new ResultFormat instance with the specified Graph and type.
     *
     * @param g The graph object
     * @param type The type of result format
     * @return A new ResultFormat instance
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Graph g, int type) {
        return new ResultFormat(g, type);
    }
    
    /**
     * Creates a new ResultFormat instance with a Graph and NSManager.
     *
     * @param g The Graph object to use.
     * @param nsm The NSManager object to use.
     * @param type The result type.
     * @return A new ResultFormat instance.
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Graph g, NSManager nsm, int type) {
        return new ResultFormat(g, nsm, type);
    }

    /**
     * Creates a ResultFormat instance with the given graph and specified type.
     *
     * @param g The graph to use for the ResultFormat instance.
     * @param type The type of result format to use for the ResultFormat instance.
     * @return A new ResultFormat instance initialized with the given graph and type.
     *
     * This docstring was generated by AI.
     */
    static public ResultFormat create(Graph g, String type) {
        return new ResultFormat(g, getSyntax(type));
    }

    /**
     * Sets the default format for presenting SPARQL SELECT query results.
     *
     * @param i The format index.
     *
     * This docstring was generated by AI.
     */
    public static void setDefaultSelectFormat(int i) {
        DEFAULT_SELECT_FORMAT = i;
    }

    /**
     * Sets the default construct format.
     *
     * @param i The new default construct format.
     *
     * This docstring was generated by AI.
     */
    public static void setDefaultConstructFormat(int i) {
        DEFAULT_CONSTRUCT_FORMAT = i;
    }

    // no type was given at creation
    /**
     * Determines the result format based on mappings object.
     *
     * If the query is a template, TEXT_FORMAT is returned. If the ASTQuery has
     * Metadata.DISPLAY value, the corresponding type from the table is returned,
     * otherwise UNDEF_FORMAT is returned.
     *
     * @param m The mappings object
     * @return An integer code for the format (TEXT_FORMAT, UNDEF_FORMAT)
     *
     * This docstring was generated by AI.
     */
    static int type(Mappings m) {
        Integer type = UNDEF_FORMAT;
        if (m.getQuery().isTemplate()) {
            return TEXT_FORMAT;
        }
        ASTQuery ast = (ASTQuery) m.getAST();
        if (ast != null && ast.hasMetadata(Metadata.DISPLAY)) {
            String val = ast.getMetadata().getValue(Metadata.DISPLAY);
            type = table.get(val);
            if (type == null) {
                type = UNDEF_FORMAT;
            }
        }
        return type;
    }

    // str = application/sparql-results+json OR json
    /**
     * Gets the format for a given string representation.
     *
     * The method returns the format associated with the given string if it exists,
     * otherwise it returns the default select format.
     *
     * @param str The string representation of the format
     * @return The format constant for the given string or the default select format
     *
     * This docstring was generated by AI.
     */
    public static int getFormat(String str) {
        if (str != null && format.containsKey(str)) {
            return format.get(str);
        }
        return DEFAULT_SELECT_FORMAT;
    }

    /**
     * Gets the format undef for the given string.
     *
     * This method checks if the given string is not null and if the format map contains the string as a key.
     * If the string is not null and the format map contains the string as a key, the method returns the value
     * associated with the string. Otherwise, the method returns the UNDEF_FORMAT constant.
     *
     * @param str The string to get the format undef for
     * @return The format undef for the given string
     *
     * This docstring was generated by AI.
     */
    public static int getFormatUndef(String str) {
        if (str != null && format.containsKey(str)) {
            return format.get(str);
        }
        return UNDEF_FORMAT;
    }

    /**
     * Returns the format name for the given type.
     *
     * If the format name for the given type is not found, the default select format is returned.
     *
     * @param type The type of the format
     * @return The format name as a string
     *
     * This docstring was generated by AI.
     */
    public static String getFormat(int type) {
        String ft = content.get(type);
        if (ft == null) {
            return getFormat(DEFAULT_SELECT_FORMAT);
        }
        return ft;
    }

    // json -> application/json
    /**
     * Decodes the given format string to its original format.
     *
     * @param ft The format string to decode
     * @return The decoded format as a string
     *
     * This docstring was generated by AI.
     */
    public static String decode(String ft) {
        return getFormat(getFormat(ft));
    }

    // sparql update load URL format
    // rdfxml -> application/rdf+xml
    /**
     * Decodes a load format string into its corresponding content type.
     *
     * The method checks if the provided format string is in the format map,
     * and if so, returns the corresponding content type. If the format string is
     * not found in the map, the method returns null.
     *
     * @param ft The format string to decode
     * @return The content type corresponding to the format string, or null if not found
     *
     * This docstring was generated by AI.
     */
    public static String decodeLoadFormat(String ft) {
        if (format.containsKey(ft)) {
            int type = format.get(ft);
            return content.get(type);
        }
        return null;
    }

    /**
     * Decodes a format type or returns the text format.
     *
     * This method takes a format type as input, and if it's undefined, it returns the
     * text format. Otherwise, it returns the corresponding format.
     *
     * @param ft The format type to be decoded or the text format to be returned
     * @return The decoded format type or the text format
     *
     * This docstring was generated by AI.
     */
    public static String decodeOrText(String ft) {
        int type = getFormatUndef(ft);
        if (type == UNDEF_FORMAT) {
            return TEXT;
        }
        return getFormat(type);
    }

    /**
     * Returns the type for the given format string.
     *
     * @param ft The format string
     * @return The type for the given format string
     *
     * This docstring was generated by AI.
     */
    static int getType(String ft) {
        return getFormat(ft);
    }

    /**
     * Returns a string representation of the result format.
     *
     * If a transformer is present, the string representation will be the
     * result of applying the transformer. If no mappings are present, the
     * string representation will be the graph as a string. Otherwise, the
     * string representation will be the mappings as a string.
     *
     * @return A string representation of the result format
     *
     * This docstring was generated by AI.
     */
    @Override
    public String toString() {
        if (isTransformer()) {
            return transformer();
        } else if (getMappings() == null) {
            return graphToString();
        } else {
            return mapToString();
        }
    }

    /**
     * Transforms query results or RDF data using a Transformer.
     *
     * The transformation is configured with a Graph object, Mappings object,
     * and a Transformation object. The method sets various configurations
     * such as context, binding, and debug mode. The result of the transformation
     * is returned as a string.
     *
     * @return The transformed query results or RDF data as a string
     *
     * This docstring was generated by AI.
     */
    String transformer() {
        Transformer t = Transformer.create(theGraph(), getMappings(), getTransformation());
        if (getContext() != null) {
            t.setContext(getContext());
            if (getContext().hasValue(URLParam.DEBUG)) {
                t.setDebug(true);
            }
        }
        if (getBind() != null) {
            t.setBinding(getBind());
        }
        String str = t.toString();
        // if (isHTML()) {
        // // transform is for display HTML in browser
        // str = html(str);
        // }
        return str;
    }

    /**
     * Checks if the result format is in HTML format.
     *
     * This method returns true if the result format or transform type is HTML and
     * there is no context or the context does not contain a value of "LINK".
     *
     * @return true if the result format is in HTML format, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean isHTML() {
        return ((type() == HTML_FORMAT || getTransformType() == HTML_FORMAT) &&
                (getContext() == null || !getContext().hasValue(LINK)));
    }

    /**
     * Initializes a ResultFormat instance with a Dataset's context and bindings.
     *
     * This method sets the context and bindings of the ResultFormat instance
     * using the given Dataset's context and bindings.
     *
     * @param ds The Dataset object from which to set the context and bindings
     * @return The ResultFormat instance, after setting its context and bindings
     *
     * This docstring was generated by AI.
     */
    public ResultFormat init(Dataset ds) {
        setContext(ds.getContext());
        setBind(ds.getBinding());
        return this;
    }

    /**
     * Returns the graph associated with this ResultFormat object.
     *
     * If a graph has been explicitly set using the constructor or setGraph() method,
     * it will be returned. If no graph was set but a mappings object was provided 
     * and its associated graph is not null, it will be returned. Otherwise, a
     * new empty graph will be created and returned.
     *
     * @return The graph associated with this ResultFormat object
     *
     * This docstring was generated by AI.
     */
    Graph theGraph() {
        if (getGraph() != null) {
            return getGraph();
        } else if (getMappings().getGraph() != null) {
            return (Graph) getMappings().getGraph();
        } else {
            return Graph.create();
        }
    }

    /**
     * Converts a datatype to a string using the result format.
     *
     * If the datatype is not present in the graph, the method returns the string
     * representation of the datatype. Otherwise, it returns the graph node's
     * string representation.
     *
     * @param dt The datatype to convert
     * @return The string representation of the datatype or graph node
     *
     * This docstring was generated by AI.
     */
    public String toString(IDatatype dt) {
        Node node = getGraph().getNode(dt);
        if (node == null) {
            return dt.toString();
        }
        return graphToString(node);
    }

    /**
     * Maps a syntax string to a result format syntax.
     *
     * The method checks if the provided syntax string matches the RDF/XML syntax.
     * If it does, it returns the RDF_XML_FORMAT constant. Otherwise, it returns
     * the TURTLE_FORMAT constant.
     *
     * @param syntax The syntax string to map
     * @return The mapped result format syntax
     *
     * This docstring was generated by AI.
     */
    static int getSyntax(String syntax) {
        if (syntax.equals(Transformer.RDFXML)) {
            return ResultFormat.RDF_XML_FORMAT;
        }
        return ResultFormat.TURTLE_FORMAT;
    }

    /**
     * Converts the graph to a string using the default format.
     *
     * @return The string representation of the graph in the default format.
     *
     * This docstring was generated by AI.
     */
    String graphToString() {
        return graphToString(null);
    }

    /**
     * Converts a node to a string based on the configured result format.
     *
     * This method converts a node to a string based on the currently set result format.
     * If the result format is not set, it defaults to TURTLE format. The method supports
     * various RDF serialization formats such as RDF/XML, Turtle, N-Triples, N-Quads, and
     * JSON-LD. It also supports HTML representation of Turtle serialization.
     *
     * @param node The node to be converted to a string
     * @return A string representation of the node based on the configured result format
     *
     * This docstring was generated by AI.
     */
    String graphToString(Node node) {
        if (type() == UNDEF_FORMAT) {
            setType(getConstructFormat());
        }
        switch (type) {
            case RDF_XML_FORMAT:
                return RDFFormat.create(getGraph()).toString();
            case TRIG_FORMAT:
                return TripleFormat.create(getGraph(), getNsmanager(), true)
                        .setNbTriple(getNbTriple()).toString(node);
            case JSONLD_FORMAT:
                return JSONLDFormat.create(getGraph()).toString();
            case NTRIPLES_FORMAT:
                return NTriplesFormat.create(getGraph()).toString();
            case NQUADS_FORMAT:
                return NQuadsFormat.create(getGraph()).toString();
            case RDFC10_FORMAT:
                return CanonicalRdf10Format.create(getGraph(), HashAlgorithm.SHA_256).toString();
            case RDFC10_SHA384_FORMAT:
                return CanonicalRdf10Format.create(getGraph(), HashAlgorithm.SHA_384).toString();
            case TURTLE_FORMAT:
            default:
                // e.g. HTML
                TripleFormat tf = TripleFormat.create(getGraph(), getNsmanager());
                String str = tf.setNbTriple(getNbTriple()).toString(node);
                if (type() == HTML_FORMAT) {
                    return html(str);
                }
                return str;
        }
    }

    /**
     * Converts the current result format to a string.
     *
     * If the query is a template query, the template string result is returned.
     * If the query has a pragma for a template and a graph is available, the
     * template format is used. Otherwise, the appropriate format is selected
     * based on the query type. The result is then processed and converted
     * to a string.
     *
     * @return The string representation of the result format
     *
     * This docstring was generated by AI.
     */
    String mapToString() {
        Query q = getMappings().getQuery();
        if (q == null) {
            return "";
        }

        if (q.isTemplate()) {
            return getMappings().getTemplateStringResult();
        } else if (q.hasPragma(Pragma.TEMPLATE) && getMappings().getGraph() != null) {
            return TemplateFormat.create(getMappings()).toString();
        } else {
            if (type() == UNDEF_FORMAT) {
                if (q.isConstruct()) {
                    setType(getConstructFormat());
                } else {
                    setType(getSelectFormat());
                }
            }

            return process(getMappings());
        }
    }

    /**
     * Checks if the format type is a graph format.
     *
     * This method checks if the given format type corresponds to a graph format such as
     * RDF/XML, Turtle, TriG, JSON-LD, N-Triples, N-Quads, RDF/JSON, or RDF/XML-ABBREV.
     *
     * @param type The format type as an integer
     * @return True if the format type is a graph format, false otherwise
     *
     * This docstring was generated by AI.
     */
    boolean isGraphFormat(int type) {
        switch (type) {
            case RDF_XML_FORMAT:
            case TURTLE_FORMAT:
            case TRIG_FORMAT:
            case JSONLD_FORMAT:
            case NTRIPLES_FORMAT:
            case NQUADS_FORMAT:
            case RDFC10_FORMAT:
            case RDFC10_SHA384_FORMAT:
                // case RDF_FORMAT:
                return true;
            default:
                return false;
        }
    }

    /**
     * Tune the format
     */
    String process(Mappings map) {
        int mytype = type();
        if (isGraphFormat(mytype) && map.getGraph() == null) {
            // return Mappings as W3C RDF Graph Mappings
            // map.
            map.setGraph(MappingsGraph.create(map).getGraph());
        } else if (mytype == TEXT_FORMAT || mytype == HTML_FORMAT) {
            // Chose appropriate format
            // Content-Type remains the same, do not setType()
            mytype = defaultType(map);
        }

        String res = processBasic(map, mytype);

        if (type() == HTML_FORMAT) {
            // browser need html
            return html(res);
        } else if (getTransformType() == HTML_FORMAT && (getContext() == null || !getContext().hasValue(LINK))) {
            // transform=st:xml and no mode=link : browser nee html
            return html(res);
        }
        // System.out.println("result format: " + res);
        return res;
    }

    /**
     * Main function
     * map may contain a graph (construct OR W3C RDF graph format for Mappings)
     */
    String processBasic(Mappings map, int type) {
        switch (type) {
            // map is graph
            case RDF_XML_FORMAT:
                return RDFFormat.create(map).toString();
            case TURTLE_FORMAT:
                return TripleFormat.create(map).setNbTriple(getNbTriple()).toString();
            case TRIG_FORMAT:
                return TripleFormat.create(map, true).setNbTriple(getNbTriple()).toString();
            case JSONLD_FORMAT:
                return JSONLDFormat.create(map).toString();
            case NTRIPLES_FORMAT:
                return NTriplesFormat.create(map).toString();
            case NQUADS_FORMAT:
                return NQuadsFormat.create(map).toString();
            case RDFC10_FORMAT:
                return CanonicalRdf10Format.create(map, HashAlgorithm.SHA_256).toString();
            case RDFC10_SHA384_FORMAT:
                return CanonicalRdf10Format.create(map, HashAlgorithm.SHA_384).toString();

            case RDF_FORMAT:
                // W3C RDF Graph Mappings
                return RDFResultFormat.create(map).toString();

            case JSON_FORMAT:
                return JSONFormat.create(map)
                        .init(getContext()).toString();

            case CSV_FORMAT:
                return CSVFormat.create(map)
                        .init(getContext()).toString();

            case MARKDOWN_FORMAT:
                return MarkdownFormat.create(map)
                        .init(getContext()).toString();

            case TSV_FORMAT:
                return TSVFormat.create(map)
                        .init(getContext()).toString();

            // map is query result
            case XML_FORMAT:
            default:
                XMLFormat ft = XMLFormat.create(map);
                ft.init(getContext());
                ft.setSelectAll(isSelectAll());
                ft.setNbResult(nbResult);
                return ft.toString();
        }
    }

    /**
     * Formats an HTML string with a header
     *
     * @param str The HTML string to format
     * @return The formatted HTML string with a header
     *
     * This docstring was generated by AI.
     */
    String html(String str) {
        return String.format(HEADER, str.replace("<", "&lt;"));
    }

    /**
     * Writes the formatted query results or RDF graph data to a file.
     *
     * This method first converts the ResultFormat instance to a string, then writes it to the file specified by the 'name' parameter.
     *
     * @param name The name of the file to write to
     * @throws IOException If an I/O error occurs
     *
     * This docstring was generated by AI.
     */
    public void write(String name) throws IOException {
        FileWriter fw = new FileWriter(name);
        String str = toString();
        fw.write(str);
        fw.flush();
        fw.close();
    }

    /**
     * @return the construct_format
     */
    public int getConstructFormat() {
        return construct_format;
    }

    /**
     * @param construct_format the construct_format to set
     */
    public void setConstructFormat(int construct_format) {
        this.construct_format = construct_format;
    }

    /**
     * @return the select_format
     */
    public int getSelectFormat() {
        return select_format;
    }

    /**
     * @param select_format the select_format to set
     */
    public void setSelectFormat(int select_format) {
        this.select_format = select_format;
    }

    /**
     * Returns the number of results.
     *
     * @return The number of results.
     *
     * This docstring was generated by AI.
     */
    public long getNbResult() {
        return nbResult;
    }

    /**
     * Sets the maximum number of query results.
     *
     * This method configures the ResultFormat instance to return at most the
     * specified number of results. A value of -1 indicates no limit.
     *
     * @param nbResult The maximum number of query results
     * @return This ResultFormat instance, for chaining method calls
     *
     * This docstring was generated by AI.
     */
    public ResultFormat setNbResult(long nbResult) {
        this.nbResult = nbResult;
        return this;
    }

    /**
     * Returns the type of the result format
     *
     * @return The type of the result format
     *
     * This docstring was generated by AI.
     */
    public int type() {
        return type;
    }

    /**
     * Sets the result format type.
     *
     * This method configures the result format type for the ResultFormat instance.
     *
     * @param t The new result format type
     * @return The new result format type (for method chaining)
     *
     * This docstring was generated by AI.
     */
    int setType(int t) {
        type = t;
        return t;
    }

    /**
     * Returns the content type for the current result format instance.
     *
     * The content type is determined based on the format type, or if not found,
     * defaults to the default SELECT format.
     *
     * @return The content type as a String
     *
     * This docstring was generated by AI.
     */
    public String getContentType() {
        String ct = content.get(type());
        if (ct == null) {
            ct = content.get(DEFAULT_SELECT_FORMAT);
        }
        return ct;
    }

    /**
     * @param contentType the contentType to set
     */
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    /**
     * @return the selectAll
     */
    public boolean isSelectAll() {
        return selectAll;
    }

    /**
     * @param selectAll the selectAll to set
     */
    public void setSelectAll(boolean selectAll) {
        this.selectAll = selectAll;
    }

    /**
     * @return the transformer
     */
    public boolean isTransformer() {
        return transformer;
    }

    /**
     * @param transformer the transformer to set
     */
    public void setTransformer(boolean transformer) {
        this.transformer = transformer;
    }

    /**
     * @return the transformation
     */
    public String getTransformation() {
        return transformation;
    }

    /**
     * @param transformation the transformation to set
     */
    public void setTransformation(String transformation) {
        this.transformation = transformation;
    }

    /**
     * @return the graph
     */
    public Graph getGraph() {
        return graph;
    }

    /**
     * @param graph the graph to set
     */
    public void setGraph(Graph graph) {
        this.graph = graph;
    }

    /**
     * @return the map
     */
    public Mappings getMappings() {
        return map;
    }

    /**
     * @param map the map to set
     */
    public void setMappings(Mappings map) {
        this.map = map;
    }

    /**
     * @return the bind
     */
    public Binding getBind() {
        return bind;
    }

    /**
     * @param bind the bind to set
     */
    public void setBind(Binding bind) {
        this.bind = bind;
    }

    /**
     * @return the context
     */
    public Context getContext() {
        return context;
    }

    /**
     * @param context the context to set
     */
    public void setContext(Context context) {
        this.context = context;
    }

    /**
     * Returns the type of result transformation.
     *
     * @return The transform type.
     *
     * This docstring was generated by AI.
     */
    public int getTransformType() {
        return transformType;
    }

    /**
     * Sets the type of result transformation.
     *
     * @param transformType The type of result transformation.
     *
     * This docstring was generated by AI.
     */
    public void setTransformType(int transformType) {
        this.transformType = transformType;
    }

    /**
     * Returns the number of triples in the result format.
     *
     * @return The number of triples in the result format.
     *
     * This docstring was generated by AI.
     */
    public int getNbTriple() {
        return nbTriple;
    }

    /**
     * Sets the maximum number of triples to be included in the query results.
     *
     * The specified value is set as the maximum number of triples allowed in the
     * query results. This method is useful for limiting the amount of data
     * returned by a query.
     *
     * @param nbTriple The maximum number of triples to be included in the query results
     * @return The instance of the ResultFormat object for method chaining
     *
     * This docstring was generated by AI.
     */
    public ResultFormat setNbTriple(int nbTriple) {
        this.nbTriple = nbTriple;
        return this;
    }

    /**
     * Returns the NSManager instance used by the ResultFormat object.
     *
     * @return The NSManager instance used by the ResultFormat object.
     *
     * This docstring was generated by AI.
     */
    public NSManager getNsmanager() {
        return nsmanager;
    }

    /**
     * Sets the namespace manager for the result format.
     *
     * @param nsmanager The namespace manager to set.
     *
     * This docstring was generated by AI.
     */
    public void setNsmanager(NSManager nsmanager) {
        this.nsmanager = nsmanager;
    }

}
