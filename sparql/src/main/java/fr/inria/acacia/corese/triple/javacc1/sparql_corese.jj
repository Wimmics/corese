// Author: Virginie BOTTOLLIER & Olivier Corby
// 07/11/2005
// This version of the grammar is for SPARQL 1.1 select expression wich needs ()
// select (fun(?x) as ?y) where
// the difference starts at BEGIN SPARQL1.1

options
{
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false ;
  STATIC = false ;
  COMMON_TOKEN_ACTION = true;
// Do \ u processing outside javacc
// JAVA_UNICODE_ESCAPE   = false ;
// UNICODE_INPUT         = true ;
// DEBUG_PARSER          = true ;	// set to true to see calls to functions
// DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(SparqlCorese)
  
  	package fr.inria.acacia.corese.triple.javacc1;

	import org.apache.log4j.Logger;
	
	import java.util.List;
	import java.util.ArrayList;
	import java.util.Vector;
  	import fr.inria.acacia.corese.triple.cst.RDFS;
  	import fr.inria.acacia.corese.triple.parser.*;
  	import fr.inria.acacia.corese.triple.update.*;
  	import fr.inria.acacia.corese.triple.api.Creator;
  	
  
  /**
  * <p>Title: Corese</p>
  * <p>Description: A Semantic Search Engine</p>
  * <p>Copyright: Copyright INRIA (c) 2006</p>
  * <p>Company: INRIA</p>
  * <p>Project: Acacia</p>
  * <br>
  * This file defines the SPARQL/Corese grammar; it's from it, that we create 
  * the 7 others classes, thanks to the JavaCC technology.
  * <br>
  * @author Virginie Bottollier
  */
  public class SparqlCorese {
  
    /** An instanciation of the class Parser */
    //Parser parser;
    /** An instanciation of the class ASTQuery (a graph representing the query) */
    ASTQuery astq, gast;
    ASTUpdate astu;
    Basic prolog;
    Creator create;
    
    /** should we say to the user when he uses something deprecated? (option, sort, or, source, as...) */
    boolean printDeprecated = true;
	
	/** logger from log4j */
	private static Logger logger = Logger.getLogger(SparqlCorese.class);
	
    /** To show some printings */
    boolean show = false;
    /** To show some printings about the part of the parser which deals with Expression */
    boolean debug2 = show && false;
    static final String THIS = "?this";

    static final String SQ1 = "\"";
    static final String SQ3 = "\"\"\"";
    static final String SSQ = "'";
    static final String SSQ3 = "'''";

	public void setASTQuery(ASTQuery aq) {
		astq = aq;
		gast = aq;
	}
	
	public void set(Creator c){
	   create = c;
	}
	
	/**
	* @param s1 = the string deprecated
	* @param s2 = how to replace s1
	*/
	public void deprecated(String s1, String s2) {
		if (printDeprecated) {
			logger.debug("*** \""+s1+"\" is deprecated, you should use \""+s2+"\" instead");
		}
	}
    
    /**
     * @throws JavaccParseException
     * @throws TokenMgrError
     * @return
     */
    public ASTQuery parse() throws JavaccParseException, TokenMgrError {
        Exp ex;
        astu = ASTUpdate.create();
        try {
            //if (astq.isRule()) ex = Rule();
        	//else 
        	ex = Start();
        } catch(ParseException e) {
        	throw new JavaccParseException(e);
        }
        if (show)
        	for (int i = 0; i<ex.size();i++) {
        		logger.debug("sparql-parser - ex.get("+i+"): "+ex.get(i));
        	} 
        
        astq.setBody(ex);
        return astq;
    }   
    
    
     public void load() throws JavaccParseException, TokenMgrError {
        astu = ASTUpdate.create();
        try {
       	  LoadPattern();
       	}
         catch(ParseException e) {
        	throw new JavaccParseException(e);
        }
    }  
    
    
     Triple createTriple(Expression s, Atom p, Expression o) throws ParseException {
 	    if (create != null){
 	    	if (! create.accept(s.getAtom(), p, o.getAtom())){
 	   	 		throw generateParseException();
 	   	 	}
 	    	create.triple(s.getAtom(), p, o.getAtom());
 	    	return null;
 	    }
 	    else {
 	    	return astq.createTriple(s, p, o);
 	    }
     }
    
   Triple createTriple(Atom p, List<Atom> list){
   		if (create != null){
	    	create.triple(p, list);
	    	return null;
	    }
	    else {
			Triple t = astq.createTriple(p, list);
   	   		return t;	    
   	   	}
   }
    
    void graphPattern(Atom g){
       if (create != null){
           create.graph(g.getConstant());
       }
    }
    
    void endGraphPattern(Atom g){
       if (create != null){
           create.endGraph(g.getConstant());
       }
    }
    
    Expression list(Exp stack, List<Expression> l, int arobase){
       RDFList rlist = astq.createRDFList(l, arobase);
    
       if (create != null){
           create.list(rlist);
       }
       else {
           stack.add(rlist);
       }
       
       return rlist.head();
    }
    
    void defNamespace(String p, String ns){
    	astq.defNamespace(p, ns);
    	astu.defNamespace(p, ns);
    }
    
    void defBase(String s){
    	astq.defBase(s);
    	astu.defBase(s);
    }
    
    
    
        /**
	 * Replace escape char by target char
	 * 
	 */
	String remEscapes(String str){
		StringBuilder retval = new StringBuilder();

                // remove leading/trailing " or '
                int start = 1, end = str.length() - 1;
		
                if ((str.startsWith(SQ3)  && str.endsWith(SQ3)) ||
		    (str.startsWith(SSQ3) && str.endsWith(SSQ3))){
                    // remove leading/trailing """ or '''
                    start = 3;
                    end = str.length() - 3;
                }

		for (int i = start; i < end; i++) {
			
                    if (str.charAt(i) == '\\' && i+1 < str.length()){
                             i += 1;       	
                             switch (str.charAt(i)){

                              case 'b':
                                   retval.append('\b');
                                   continue;
                                case 't':
                                   retval.append('\t');
                                   continue;
                                case 'n':
                                   retval.append('\n');
                                   continue;
                                case 'f':
                                   retval.append('\f');
                                   continue;
                                case 'r':
                                   retval.append('\r');
                                   continue;
                                case '"':
                                   retval.append('\"');
                                   continue;
                                case '\'':
                                   retval.append('\'');
                                   continue;
                                case '\\':
                                   retval.append('\\');
                                   continue;
                             }

                     }
                     else {
                             retval.append(str.charAt(i));
                     }
		}
		
		return retval.toString();
	}
    
    
    
}  
  
  
  
  
  
PARSER_END(SparqlCorese)





Exp Start(): { Exp stack; }
{
	{ stack = new And(); }
  	 stack = Query()  <EOF> 
  	{ return stack; }
}

Exp Rule(): { Exp stack; }
{
	{ stack = new And(); }
	Prolog()
  	 stack = GroupGraphPattern()  <EOF> 
  	{ return stack; }
}

Exp Query() : { Exp stack; }
{

	{stack = BasicGraphPattern.create();}
	
  Prolog()
  
  ( 
  	  stack = SelectQuery()    (Defun(stack)) ?
  	| stack = ConstructQuery() (Defun(stack)) ?
  	| stack = DescribeQuery()  (Defun(stack)) ?
  	| stack = AskQuery()       (Defun(stack)) ? 
  	| UpdateQuery()            (Defun(stack)) ? 
  	
  	| stack = TemplateQuery()  (Defun(stack)) ?
        | Defun(stack)     
  	     	
  ) ?
  
  { return stack; }
}

void Defun(Exp stack) : {} {
    ( Function(stack) | Export(stack) ) +   
}

Exp LoadPattern() : {Exp stack;}
{
        {stack = BasicGraphPattern.create();}

	(
          BaseDecl() 
        | PrefixDecl()
        | TriplesSameSubject(stack) ( <DOT> ) ?
	| GraphGraphPattern(stack) 

        ) *

        <EOF>
	{ return stack; }
}

Exp LoadPattern2() : {Exp stack;}
{
	Prolog()
	stack = BodyQuadPattern() <EOF>
	{ return stack; }
}



void Prolog() : {}
{
     
	(  BaseDecl() | PrefixDecl() )*
}

void BaseDecl() : { Token t; String s; Triple triple; }
{
  (<BASE> | <ABASE>)   s = Q_IRI_ref() (<DOT>) ?
  {
	defBase(s);
  }
}

void PrefixDecl() : { Token t1, t2; String s; Triple triple; }
{
    (<PREFIX> | <APREFIX>) t2 = <QNAME_NS> s = Q_IRI_ref() (<DOT>) ?
  {
 	defNamespace(t2.image, s);
  }   
}




// *******************************************************************
 
// Update

void  UpdateQuery() : {  }
{

	{
  		astq.setResultForm(ASTQuery.QT_UPDATE);
  		astq.set(astu);
  		astu.defProlog();
  	}	

	UpdateQuery1()
	
	( Pragma() ) ?
	
	
}


void  UpdateQuery1() : {  }
{
	UpdateQuery2()
	
	( <SEMICOLON> ( 
		Prolog()
		{   		
		astu.defProlog(); }
		UpdateQuery1() ) ? 
	) ?
}




void UpdateQuery2() : { 
	Exp stack; Basic ope;
	Constant graph, uri, target; 
	boolean silent, defaut, named, all;
	}
{
    { astq.reset(); }
    
	{	
		stack = BasicGraphPattern.create();
		graph = null; uri = null; target = null;
		silent = false;
		defaut = false;
		all = false;
		ope = null;
	}
	
	(
		<LOAD> {ope = Basic.create(Update.LOAD);} 
		(<SILENT> 	{ope.setSilent(true);} ) ?  
		uri = IRIrefConst() {ope.setURI(uri);} 
		( <INTO> <GRAPH> graph = IRIrefConst() {ope.setTarget(graph);} ) ?
	|
		(<CLEAR>  	{ope = Basic.create(Update.CLEAR);} | <DROP> {ope = Basic.create(Update.DROP);})
		
		(<SILENT> 	{ope.setSilent(true);} ) ?  
			
		(<GRAPH> 	graph = IRIrefConst() {ope.setGraph(graph);} | 
		
		<DEFAUT> 	{ope.setDefault(true);} | 
		<NAMED> 	{ope.setNamed(true);} |
		<ALL> 		{ope.setAll(true);})

		
	|
		<CREATE> {ope = Basic.create(Update.CREATE);} (<SILENT> {ope.setSilent(true);} ) ?  
		<GRAPH> graph = IRIrefConst() {ope.setGraph(graph);}
	|
		(<ADD>  {ope = Basic.create(Update.ADD);}  | 
		 <MOVE> {ope = Basic.create(Update.MOVE);} | 
		 <COPY> {ope = Basic.create(Update.COPY);})
		
		(<SILENT> {ope.setSilent(true);} ) ?
		   
		((<GRAPH>) ? graph = IRIrefConst()  {ope.setGraph(graph);}    | <DEFAUT> 	{ope.setDefault(true);} )  
		<TO>
		((<GRAPH>) ? graph = IRIrefConst()  {ope.setTarget(graph);}   | <DEFAUT> 	{ope.setDefault(true);} ) 
	
	|	
		LOOKAHEAD(2)
		DeleteInsertData()	
	|	
		DeleteInsertWhere()
	)
	
	{
		if (ope!=null) astu.add(ope);
	}

}



void DeleteInsertData() : {Exp exp; Composite ope, upd;}
{
	
	(
		<INSERT> <DATA>  
		  
		{ astq.setInsertData(true); } 
		
		exp = QuadPattern() 
		
		{astq.setInsertData(false); 
		 ope = Composite.create(Update.INSERT, exp); }
	
	|
	
		<DELETE> 
		(
			<DATA>     exp =   QuadPattern() 
			
			{ope = Composite.create(Update.DELETE, exp);}
			
			|
			<WHERE>    exp = QuadPattern()
			
			{
				upd = Composite.create(Update.COMPOSITE); upd.setBody(exp); 
				ope = Composite.create(Update.DELETE);    ope.setPattern(exp); 
				upd.add(ope);
				ope = upd;
			}
			
		)
	)
	
	{ astu.add(ope); }

}




// create an AST as a whole

void DeleteInsertWhere() : {Exp exp; Composite upd, ope; Constant uri; Values values;}
{
	{upd = Composite.create(Update.COMPOSITE);}
	
	( <WITH> uri = IRIrefConst() 
	
	{upd.setWith(uri);}
	
	) ?
	
	(
		<DELETE> exp = QuadPattern() 			
		
		{ope = Composite.create(Update.DELETE); ope.setPattern(exp); upd.add(ope);}
		
		
		( <INSERT> exp = QuadPattern() 
		
		  {ope = Composite.create(Update.INSERT); ope.setPattern(exp); upd.add(ope);}
		
		) ?
		
		|
		
		<INSERT> exp = QuadPattern()
		
	    {ope = Composite.create(Update.INSERT); ope.setPattern(exp); upd.add(ope);}
		
	)
	
	// from & from named
	
	( <USING> (           uri = IRIrefConst()   { upd.addUsing(uri); } | 
	
	            <NAMED>   uri = IRIrefConst()   { upd.addNamed(uri); }
	          ) 
	) *
	
	<WHERE> exp = GroupGraphPattern()

        (values = ValueBindings() {upd.setValues(values); } ) ?
	
	{ upd.setBody(exp); astu.add(upd); }

}




Exp QuadPattern() : {Exp stack;}
{
	
	<LBRACE>
	
		stack = BodyQuadPattern()
	
	<RBRACE>
	
	{
	    return stack; 
	}

}


Exp BodyQuadPattern() : {Exp stack;} 
{

		{stack = BasicGraphPattern.create();}

		( BlockOfTriples(stack) ) ?
			
		( GraphGraphPattern(stack)  ( BlockOfTriples(stack) ) ? ) *
		
		{return stack; }
}
		
		


// *********************** End Update ********************************************************



Exp TemplateQuery() : { Exp stack; }
{
  {stack = BasicGraphPattern.create();}
  Template(stack)
  ( DatasetClause() )*
  stack = WhereClause()
  SolutionModifier()  
  {
    astq.setTemplate(true);
    return stack; 
  }
}



void Template(Exp stack) : 
{ String str; Variable var; Constant cst; Expression exp, sep; ExpressionList list; 
   List<Variable> varList;}
{
    <TEMPLATE> { cst = null; }
    
    ( <DEBUG> { astq.setDebug(true); } ) ?
    
    ( cst = IRIrefConst() { astq.setName(cst); }    ) ?
 
        

      (<LPAREN>  
 
         var = Var() { astq.defArg(var); }

         (<COMMA> var = Var() { astq.defArg(var); }) *
		   
       <RPAREN>
      ) ? 

      (<LBRACKET>   

         cst = IRIrefConst() { astq.defProfile(cst); }
        		   
       <RBRACKET>
      ) ? 

   
	<LBRACE>
	
		( 		  
                 exp = texp(stack)

                { astq.addTemplate(exp); }
		  
		   
		) *
		
		( <SEMICOLON>  <SEPARATOR>  <EQ>  
                      sep = PrimaryExpression(stack) { astq.setSeparator(sep); }
                ) ?
		
	
	<RBRACE>	
}

Expression texp (Exp stack) : { Expression exp; }
{
( 
                        exp =  XML(stack)  
                  |
                	exp = PrimaryExpression(stack)
                  |                       
                        exp = box(stack)
	          | 
                        exp = group(stack)
                 )
{ return exp; }
}


Expression group(Exp stack) : 
{  Expression box, exp, sep; ExpressionList list; }
{
 <GROUP>           { list = new ExpressionList(); }
		  
	( <DISTINCT>     { list.setDistinct(true); } ) ?
		  		    
	<LBRACE>  
                  ( 
                    exp = texp(stack)
                    { list.add(exp); }
		  ) * 
		  			  
		  ( <SEMICOLON>  <SEPARATOR>  <EQ>  
                   sep = PrimaryExpression(stack) { list.setExpSeparator(sep); } 
                  ) ?  
		  			  
	<RBRACE>
    { 
        exp = astq.createGroup(list); 
        return exp;
    }
		  		  
		  
}



Expression box(Exp stack) : 
{  Expression box, exp, sep; ExpressionList list; Token t; }
{

      ( t = <BOX> | t = <IBOX> | t = <SBOX> )     { list = new ExpressionList(); }

      <LBRACE>  
            (            
            exp = texp(stack)            
            { list.add(exp); }
            ) *
      <RBRACE>

      { 
        box = astq.createBox(list, t.image ); 
        return box;
      }
}

Expression XML(Exp stack) : 
{  Expression box, exp, val, sep; ExpressionList list, attr; Token t; Constant uri = null, str;
    ArrayList<ExpressionList> lattr = null;
}
{

   <AT> uri = IRIrefConst()      
 //  <AT> (t = <SIMPLE_STRING> | t = <QNAME>)  {uri = astq.createConstant(t.image);}

{ list = new ExpressionList(); }

    (        
        (<LPAREN> { lattr = new  ArrayList(); }
            (
                (<LPAREN> 
                    str = RDFLiteral() val = PrimaryExpression(stack)
                    { attr = new  ExpressionList(); attr.add(str); attr.add(val); 
                      lattr.add(attr);
                    }
                 <RPAREN>) + 
              |
                str = RDFLiteral() val = PrimaryExpression(stack)
                    { attr = new  ExpressionList(); attr.add(str); attr.add(val); 
                      lattr.add(attr);
                    }
            )      
        <RPAREN>)
    )?

      <LBRACE>  
            ( 
            exp = texp(stack)
            { list.add(exp); }
            ) *
      <RBRACE>

      { 
        box = astq.createXML(uri, lattr, list); 
        return box;
      }
}

// ********************** END PP Template ******************************


// ---- Query type clauses

Exp SelectQuery() : { Exp stack; }
{

    <SELECT>
    Debug()
    (<NOSORT> {astq.setSorted(false); } )?
    OneMoreListMerge()
    GroupCountSortDisplayVar()
    Max()
    ( DatasetClause() )*
  stack = WhereClause()
  SolutionModifier()  
  {
    astq.setResultForm(ASTQuery.QT_SELECT);
    return stack; 
  }
}


void Debug(): {} 
{
 (<DEBUG> { astq.setDebug(true); } )?
 (<CHECK> { astq.setCheck(true); } )?
}



Exp ConstructQuery() : { Exp stack1, stack2; boolean isRule = false;}
{
  (<RULE> {isRule = true;} )? 
  
  <CONSTRUCT> 
  
  Debug()
  
  (
  (
  // with a construct pattern
  stack1 = ConstructTemplate()
  // corese extension kept for compatibility
  (<SELECT> (SelectVar()) ?) ?    
  ( DatasetClause() )*
  stack2 = WhereClause()
  SolutionModifier()
  
  {	
  astq.setConstruct(stack1); 	
  astq.setRule(astq.isRule() || isRule);
  return stack2; }
  )
  
  |
  
  (
  // without a construct pattern
  ( DatasetClause() )*
  <WHERE> stack2 =  ConstructTemplate2()
  SolutionModifier()
  
  {	astq.duplicateConstruct(stack2); 	return stack2; }
  )
  )
  
  
  
  
  
  
}

Exp DescribeQuery() : { Exp stack; Variable v; String s; Atom at;}
{  
  { stack = new And(); }	
  <DESCRIBE>
  Debug()
  ( 
  	( LOOKAHEAD(2) 
  		( 
  			  at = Var() { astq.setDescribe(at); }
  			| at = IRIrefConst() { astq.setDescribe(at); }
  		) 
  	)+
  	| <STAR> { astq.setDescribeAll(true); }
  )
  ( LOOKAHEAD(2) DatasetClause() )*
  ( LOOKAHEAD(2) stack = WhereClause() )?
  SolutionModifier()  
  { 
    astq.setResultForm(ASTQuery.QT_DESCRIBE);
  	return stack; 
  }
}

Exp AskQuery() : { Exp stack; Values values;}
{
  <ASK>
  Debug()
  ( DatasetClause() )*
  stack = WhereClause()
  (values = ValueBindings()  {astq.setValues(values); } ) ?
  
  {
  	astq.setResultForm(ASTQuery.QT_ASK);
  	return stack;
  }
}

Exp DeleteQuery() : { Exp stack; }
{ 
	<DELETE>
	<STAR>
	stack = WhereClause()
	{ 
		astq.setDelete(true);
		astq.setResultForm(ASTQuery.QT_DELETE);
		return stack; 
	}
}

// ----

// one more list merge in any order and without list and merge being together
void OneMoreListMerge(): {}
{
  One() ( More() ( List() | Merge() )? | List() ( More() )? | Merge() ( More() )? )?
  | More() ( One() ( List() | Merge() )? | List() ( One() )? | Merge() ( One() )? )?
  | ( ( List() | Merge() ) ( One() ( More() )? | More() ( One() )? )? )?
}

void One(): {}
{
  <ONE>
  { astq.setOne(true); }
}

void More(): {}
{
  <S_MORE>
  { astq.setMore(true); }
}

void List(): {}
{
  <LIST>
  { astq.setList(true); }
}

void Merge(): {}
{
  <MERGE>
  { 
  //astq.setMerge(true); 
  }
}

void GroupCountSortDisplayVar(): {}
{
  GroupCountSortDisplay() 
  ( 
  	(<DISTINCT> { astq.setDistinct(true);  } | <REDUCED> { astq.setReduced(true);  } ) 
  	( <SORTED> { astq.setStrictDistinct(false); } )?
  )? 
  ( 
  	SelectVar() 
  	GroupCountSortDisplay() 
  )?
}

// ***************** BEGIN SPARQL1.1

void SelectVar(): { Variable e1; Expression e2; Exp stack; } 
{

	{ stack = BasicGraphPattern.create(); }
	(
		( 
			( 
			LOOKAHEAD(2) 
			e1 = Var() { astq.defSelect(e1, null); } 
				| SelectExp(stack) ) 
		)+
  		| 
  		( 
  			<STAR> { astq.setSelectAll(true); } 
			( 
			SelectExp(stack) )*
 	  	)
	)
}


void SelectExp(Exp stack):{}
{	
	 <LPAREN> FunVar(stack) <RPAREN> 
}


void FunVar(Exp stack): { Expression e2; Variable e1; Variable var;} {
	
		 e2 = Expression(stack)
	
		
                <AS> ( 
			         var = Var() { astq.defSelect(var, e2); } 
			|
			
			// select sql("select a b from table") as (?x, ?y) where
			
			{ var = astq.metaVariable();  }
			       
			<LPAREN> 
			      e1 = Var()  
			      { var.addVariable(e1); } 
			              
				( <COMMA> e1 = Var()  
				  { var.addVariable(e1);   } 
			 	) *
				
			<RPAREN>
			
			{ astq.defSelect(var, e2);}       
		 )
}

// ********************* END SPARQL 1.1


void GroupCountSortDisplay(): {}
{
  ( LOOKAHEAD(2) (
    Group()
    //| Count()
    | Sort() 
    | Display() 
  ) )*  
}

void Group(): { Atom var; }
{
  <GROUP> (<BY>)?
  var = Var()
  { 
  //astq.setGroup(var.getName()); 
  }
}

void Count(): { Atom var; }
{
  <COUNT> var = Var()
  { astq.setCount(var.getName()); }
}

void Sort(): { boolean reverse; Token t; Variable v; String sortby; Expression a; Term tm; Exp stack; }
{
  { reverse = false; stack = new And(); deprecated("sort", "order by"); }
  <SORT> 
  (
  	(<REVERSE> { reverse = true; } )? 
  	( 
  	  v = Var() { astq.setSort(v, reverse); }
  	  | a = BuiltInCall(stack) { astq.setSort(a, reverse); }
  	  | a = BrackettedExpression(stack) { astq.setSort(a, reverse); }
  	  | tm = FunctionCall(stack) { astq.setSort(tm, reverse); }
  	  | LOOKAHEAD(2) tm = FunctionCorese(stack) { astq.setSort(tm, reverse); }
	  | t = <COUNT> { sortby = t.image.toLowerCase(); astq.setSort(sortby, reverse); }
  	  | t = <DISTANCE> { sortby = t.image.toLowerCase(); astq.setSort(sortby, reverse); }       
	)
  )  
}

void Display(): { Token t; }
{
  <DISPLAY> ( 
  			  <D_RDF>  { astq.setRDF(true); }
  			| <D_JSON> { astq.setJSON(true); }  
  			| <D_FLAT> { astq.setFlat(true); }
  			| <D_ASQUERY> { astq.setPQuery(true); }
  			| ( t = <INTEGER> { astq.setMaxDisplay(Integer.parseInt(t.image)); } 
  			  )	
  			| <D_XML> { astq.setXMLBind(true); }
  			| <D_BLANK> { astq.setDisplayBNID(true); } 
  			)
}

void Max(): {}
{
  Projection() ( ( Result() ( Threshold() )? ) | ( Threshold() ( Result() )? ) )?
  | Result() ( ( Projection() ( Threshold() )? ) | ( Threshold() ( Projection() )? ) )? 
  | ( Threshold() ( ( Projection() ( Result() )? ) | ( Result() ( Projection() )? ) )? )?
}

void Projection(): { Token t; }
{
  <PROJECTION> 
  ( t = <INTEGER>
  { astq.setMaxProjection(Integer.parseInt(t.image)); }
  )
}

void Result(): { Token t; }
{
  <RESULT> 
  ( t = <INTEGER>
  { astq.setMaxResult(Integer.parseInt(t.image)); }
  )
}

void Threshold(): { Token t; }
{
  <THRESHOLD> 
  ( t = <INTEGER>
  { astq.setThreshold(Float.parseFloat(t.image)); }
   )
}



// ----

void DatasetClause() : { Constant s; }
{
  <FROM>
  ( 
            s = IRIrefConst()  { astq.setFrom(s); }
  | <NAMED> s = IRIrefConst()  { astq.setNamed(s); } 
  )
}

Exp WhereClause() : { Exp stack; }
{
   (<WHERE> { astq.setWhere(true); } )? 
   //{ stack = BasicGraphPattern.create(); }
   stack = GroupGraphPattern()
   { return stack; }
}

void SolutionModifier() : {Values values;}
{
   (Relax()) ?  
   (OrderGroup()) ? ( LimitOffset()) ? 
   (values = ValueBindings() {astq.setValues(values); } ) ?
   (Display()) * 
   (Pragma()) *
}


Values ValueBindings() : {Values values;}
{
	(
	values = Values()
	|
	values = Bindings()
	)	
	
	{return values;}
}

Values Values() : {Variable var; Constant val; ArrayList<Variable> list = null; ArrayList<Constant>  value; Values values = null;}
{
	{list = new ArrayList<Variable>();
	values = Values.create();}

 <VALUES> 
 
	( 
	(	
		<LPAREN> 
			(var = Var() {list.add(var); }) *
			{ values.setVariables(list); }
		<RPAREN>
			
		<LBRACE> 
		(
			<LPAREN> 
				{ value = new ArrayList<Constant>(); }
				( val = Value() { value.add(val); } ) * 
				{ values.addValues(value); }
			<RPAREN>
		)*
		<RBRACE>
	)

	|
	
	(
		var = Var() {list.add(var); }
			{ values.setVariables(list); }
		
		<LBRACE> 
			(
			{ value = new ArrayList<Constant>(); }
			val = Value() { value.add(val); } 
			{ values.addValues(value); }
			) *
		<RBRACE>
	)
	)
	
	{ return values; }

	
}



Values Bindings() : {Variable var; Constant val; ArrayList<Variable> list; ArrayList<Constant>  value; Values values;}
{
	{list = new ArrayList<Variable>();
	 values = Values.create();
	}

	<BINDINGS> 
	(var = Var() {list.add(var); }) *
	 { values.setVariables(list); }
	<LBRACE> 
	(
		<LPAREN> 
			{ value = new ArrayList<Constant>(); }
			( val = Value() { value.add(val); } ) * 
			{ values.addValues(value); }
		<RPAREN>
	)*
	<RBRACE>
	
	{ return values; }
	
}


Constant Value() : { Constant cst; String s; Token t1;}
{
  	( 
  	  s = Q_IRI_ref() { cst = astq.createURI(s); }
  	| t1 = <QNAME>    { cst = astq.createQName(t1.image);  }
  	| t1 = <QNAME_NS> { cst = astq.createQName(t1.image);  }
  	| t1 = <UNDEF>    { cst = null; }  
  	| cst = RDFLiteral() 
  	| cst = NumericLiteral()
  	| cst = BooleanLiteral()   
  	) 
  	
  { return cst; }
}




void Pragma() : {Exp exp; String uri;}
{
	{uri = null;}
	<PRAGMA> (uri = IRIref()) ?  exp = GroupGraphPattern() 
	{
	astq.setPragma(uri, exp);
	}
	  
}


void Relax() : {Token t1; }
{
	<RELAX> <BY> t1 = <QNAME> 
	{astq.setDistance(t1.image);
	 } 
}


void LimitOffset() : {}
{
	ProjLimitClause()  ( OffsetClause() )? |
	OffsetClause() ( ProjLimitClause() )?

}

void OrderGroup() : {}
{
	GroupClause() (OrderClause())? (Having())? |
	OrderClause() (GroupClause())? (Having())? |
	Having()
}

void GroupClause(): { Variable var; Expression exp; Exp stack;}
{
 	{ 
  		stack = new And();
  		var = null;
  	}
  	
  	 <GROUP> <BY>
  (
  
  ( LOOKAHEAD(2)
  	( 
  	//exp = BrackettedExpression(stack) |
  	
  	  <LPAREN> exp = Expression(stack) (<AS> var = Var() ) ? <RPAREN> |
  	  exp = Var() |
  	  exp = BuiltInCall(stack) |
  	  exp = FunctionCall(stack) |
  	  exp = FunctionCorese(stack)
  	)
  	{ astq.setGroup(exp, var); }
  ) + 
  	
 // 	| <ANY> { astq.setConnex(true); }
  )
}




void Having() : {Exp stack; }
{
	{stack = new And();}
	
  	<HAVING> Filter(stack)
  	
  	{astq.setHaving(stack);}
  
}

void OrderClause() : {}
{
  <ORDER> <BY> 
  ( LOOKAHEAD(2) OrderCondition() )+
}

void OrderCondition() : { boolean reverse; Token t; String sortby; Variable v; Expression a; Term tm; Exp stack; }
{
  	{ 
  		reverse = false; 
  		stack = new And();
  	}
	( 
		v = Var() { astq.setSort(v, reverse); }
	    | a = BuiltInCall(stack) { astq.setSort(a, reverse); }
	    | tm = FunctionCall(stack) { astq.setSort(tm, reverse); }
	    | LOOKAHEAD(2) tm = FunctionCorese(stack) { astq.setSort(tm, reverse); }
		|
    	( 
    		( <ASC> | <DESC> { reverse = true; } )? 
    		( 
    			a = BrackettedExpression(stack) { astq.setSort(a, reverse); }
    			| t = <DISTANCE> { sortby = t.image; astq.setSort(sortby, reverse); }
    			| t = <COUNT> { sortby = t.image; astq.setSort(sortby, reverse); }
    		)
    	)    		
  	)  	
}

void ProjLimitClause() : { Token t; }
{
	Projection() ( LimitClause() ) ? | 
	LimitClause()
}

void LimitClause() : { Token t; }
{
  <LIMIT> 
  t = <INTEGER>
  { astq.setMaxResult(Integer.parseInt(t.image)); }
}

void OffsetClause() : { Token t; }
{
  <OFFSET> 
  t = <INTEGER>
  { astq.setOffset(Integer.parseInt(t.image)); }
}



// **** General Graph Pattern ********************************************



Exp GroupGraphPattern() : {Exp stack;}
{
  { stack = BasicGraphPattern.create(); }
  <LBRACE>  
    (    
  	  SubQuery(stack) |
  	  GraphPattern(stack) 
  	)
  <RBRACE>
  { return stack; }
}
 

void GraphPattern (Exp stack) : {}
{
(
	(
          Function(stack) 
        | Export(stack)
	| TriplesSameSubject(stack) 
	|
	Constraint(stack) 
	|
	GraphPatternNotTriples(stack)
	)
	(<DOT>)?
)*
}


// former GraphPattern
void GP(Exp stack) : {}
{    
	FilteredBasicGraphPattern(stack)
  	(
		GraphPatternNotTriples(stack) 
   	 	(<DOT>   )?
    	GraphPattern(stack)
  	)?  	 
}



void FilteredBasicGraphPattern(Exp stack) : {} 
{
		
	( BlockOfTriples(stack) )? 
	( 
		Constraint(stack) 
    	( <DOT> )? 
		FilteredBasicGraphPattern(stack) 		
	)?
}

void BlockOfTriples(Exp stack) : {boolean b1, b2;}
{   
		(
		TriplesSameSubject(stack) 
				
		( <DOT> ) ?
		)+
		
}




void GraphPatternNotTriples(Exp stack) : {ASTQuery ast; Values values;}
{
      OptionalGraphPattern(stack)
    | MinusGraphPattern(stack)
 	| LOOKAHEAD (2) GroupOrUnionGraphPattern(stack) 
 	| GraphGraphPattern(stack)
 	| ServicePattern(stack)
 	| ScoreGraphPattern(stack)
 	| ScopeGraphPattern(stack)
 	| ExistGraphPattern(stack)
 	| Bind(stack) 
 	| values = Values() { stack.add(values); }
}

void SubQuery(Exp stack) : {ASTQuery ast; Query q; Exp exp;}
{
 { ast = astq; astq = gast.subCreate(); } 
 exp = SelectQuery() 
 { astq.setBody(exp); q = Query.create(astq); stack.add(q); astq = ast; } 
}

Exp SubQueryExp() : { Exp exp; }{
    { exp = BasicGraphPattern.create(); } SubQuery(exp)
    { return exp; }
}

Exp SubConstruct() : {ASTQuery ast; Query q; Exp exp;}
{
 { ast = astq; astq = gast.subCreate(); } 
 exp = ConstructQuery() 
 { astq.setBody(exp); q = Query.create(astq); astq = ast; return q;} 
}


void Bind(Exp stack) : { Expression exp; Exp q; Variable var, vv;}
{
	<BIND> <LPAREN> 
                exp = Expression(stack) 
			
                <AS> ( 
			var = Var() 

			|
			
			// bind( sql("select a b from table") as (?x, ?y))
			
			{ var = astq.metaVariable();  }
			       
			<LPAREN> 
			      vv = Var()  
			      { var.addVariable(vv); } 
			              
				( <COMMA> vv = Var()  
				  { var.addVariable(vv);   } 
			 	) *
				
			<RPAREN>						     
		 )
        <RPAREN> 
	
	{
		q = astq.createBind(exp, var); stack.add(q);
	}
}


// ---- Definitions of each pattern element

void OptionalGraphPattern(Exp stack) : { Exp e; }
{ 
	( <OPTIONAL> | <OPTION> { deprecated("option","optional"); } ) 
  	e = GroupGraphPattern()
  	{ 
  		e= Option.create(e);
  		stack.add(e); 		
  	}
}

void MinusGraphPattern(Exp stack) : { Exp e; }
{ 
	<MINUSP>  e = GroupGraphPattern()
  	{ 
  		e = Minus.create(e);
  		stack.add(e); 		
  	}
}


void ExistGraphPattern(Exp stack) : { Exp e; }
{ 
	 <EXIST> 
  	e = GroupGraphPattern()
  	{ 
  		e= Exist.create(e);
  		stack.add(e); 		
  	}
}

void ScopeGraphPattern(Exp stack) : { Exp e; }
{ 
	 <SCOPE> 
  	e = GroupGraphPattern()
  	{ 
  		e= Scope.create(e);
  		stack.add(e); 		
  	}
}



void GraphGraphPattern(Exp stack) : 
	{ Atom src; Exp e; Source st; 
	  boolean state = false, leaf = false, rec = false;}
{
	
	 <GRAPH>
	 
  	src = VarOrIRIref(stack) 
  	{ graphPattern(src); }
  	e = GroupGraphPattern()
  	{ 
  		st =  Source.create(src, e);
  		if (state) { 
  			st.setState(true); 
  			if (leaf) st.setLeaf(true);
  		}
  		if (rec){
  			st.setRec(true);
  		}
  		stack.add(st);
  	}
  	{ endGraphPattern(src); }
}

void ServicePattern(Exp stack) : 
	{ Atom src; Exp e; Service st; boolean silent;}
{
	{silent = false;}
	 <SERVICE>  (<SILENT> { silent = true;} )?
	 
  	src = VarOrIRIref(stack) 
  	e = GroupGraphPattern()
  	{ 
  		st =  Service.create(src, e, silent);
  		stack.add(st);
  	}
}

void ScoreGraphPattern(Exp stack) : { Atom src; Exp e; }
{
  <SCORE> 
  src = VarOrBlankNodeOrIRIref(stack) 
  e = GroupGraphPattern()
  { 
  	astq.setScore(true);
  	e = Score.create(src, e);
  	stack.add(e);
  }
}

// G (union G)* can be a single group pattern
// or a group pattern as part of an union.
void GroupOrUnionGraphPattern(Exp stack) : { Exp temp, res; }
{
	res = GroupGraphPattern()
  	( 
  	  	( <UNION> | <OR> { deprecated("or","union"); } )
  	  	{ 
  	  		temp = res;
      		res =  Or.create();
      		res.add(temp);
  	  	}
    	temp = GroupGraphPattern()  
    	{ res.add(temp); }  
  	)*  
	{ stack.add(res); }
}

void Constraint(Exp stack) : { }
{
  <FILTER> Filter(stack)
  
}


void Filter(Exp stack) : { Expression expression1; Triple triple; }
{
  expression1 = FilterExp(stack)
  { 
  		if (expression1 != null ) {
	    	triple = astq.createTriple(expression1);
	    	stack.add(triple);    	
	    }
  }
}

Expression FilterExp(Exp stack) : {Expression exp;}
{
  (   exp = BrackettedExpression(stack) 
    | exp = BuiltInCall(stack) 
    | exp = FunctionCorese(stack)
    | exp = FunctionCall(stack) 
  )
  {return exp;}
}



// -------- Construct patterns

Exp ConstructTemplate() : { Exp stack; }
{
  <LBRACE>
  	{ stack = BasicGraphPattern.create(); }
	ConstructTriples(stack)
  <RBRACE>
  { return stack; }
}

void ConstructTriples(Exp stack) : {}
{
  (
  	(TriplesSameSubject(stack) | GraphGraphPattern(stack))
  	(<DOT>)? 
  	ConstructTriples(stack)   	
  )?
}


Exp ConstructTemplate2() : { Exp stack; }
{
  <LBRACE>
  	{ stack = BasicGraphPattern.create(); }
	ConstructTriples2(stack)
  <RBRACE>
  { return stack; }
}

void ConstructTriples2(Exp stack) : {}
{
  (
  	TriplesSameSubject(stack) 
  	(<DOT>)? 
  	ConstructTriples2(stack)   	
  )?
}








// -------- Triple lists with property and object lists
void TriplesSameSubject(Exp stack) : { Expression expression1; }
{
  ( LOOKAHEAD(2)
  	expression1 = VarOrTerm(stack)
	stack = PropertyListNotEmpty(expression1, stack)
  |
  	expression1 = TriplesNode(stack)
  	stack = PropertyList(expression1, stack)
  	
  | stack = tuple(stack)
  )
}


Exp tuple(Exp stack): { Expression expression1, expression2, expressioni; ArrayList<Atom> list; Atom prop; Triple triple; } {
	<TUPLE> <LPAREN> 
	
	prop = Verb2()
	expression1 = GraphNode(stack)
	expression2 = GraphNode(stack)
	{ 
        list = new ArrayList<Atom>();
        list.add(expression1.getAtom());
        list.add(expression2.getAtom());       
	}
	
	(  expressioni = GraphNode(stack)  
	  { list.add(expressioni.getAtom()); } 
	)*
	  
	<RPAREN>
	{ 
	    triple = createTriple(prop, list); 
	    if (triple != null){ stack.add(triple);	}	
		return stack; 
	}
}


  
Exp PropertyList(Expression expression1, Exp stack) : {}
{  
  ( LOOKAHEAD(2) stack = PropertyListNotEmpty(expression1, stack) ) ?
  { return stack; }
}

Exp PropertyListNotEmpty( Expression expression1, Exp stack) : 
{ ExpressionList v; Atom atom; Expression expression2; Exp e1; Triple triple; int n;}
{ 
  atom = Verb2() 
  { n = stack.size(); }  
  // ObjectList() may fill the stack beyond n in case of [prop ?val] 
  // hence we store the index n to add the triple at n	
  v = ObjectList(stack)
  {
  	for (int i=0;i<v.size();i++) {
      	expression2 = v.get(i);
        e1 = createTriple(expression1, atom, expression2);
        if (e1 != null){
        	// add triple at place n (see above for definition of n)
        	stack.add(n++, e1);
        }      
	}
  }
  (
  	<SEMICOLON> 
  	{ stack = PropertyList(expression1, stack); }
  ) ?
  { return stack; }
}

Atom Verb2(): { Atom atom; String[] s; Token t; }
{
  s = PQualifier()
  atom = Verb()
  {
  	if (s[0]!="") { atom.setIsone(true); }
  	if (s[1]!="") { atom.setIsall(true); }
  	if (s[2]!="") { atom.setIsdirect(true); }
  }
 
 
  { return atom; }
}

String[] PQualifier(): { String[] s; String s1, s2, s3; }
{
	{ s1=""; s2=""; s3=""; }
	(
		s1 = One2() ( ( s2 = All2() ( s3 = Direct2() )? ) | ( s3 = Direct2() ( s2 = All2() )? ) )?
	  	| s2 = All2() ( ( s1 = One2() ( s3 = Direct2() )? ) | ( s3 = Direct2() ( s1 = One2() )? ) )? 
	  	| ( s3 = Direct2() ( ( s1 = One2() ( s2 = All2() )? ) | ( s2 = All2() ( s1 = One2() )? ) )? )?
	)
	{ 
		s = new String[3];
		s[0] = s1; // one
		s[1] = s2; // all
		s[2] = s3; // direct
	}
  	{ return s; }
}

String One2(): { Token t; }
{
	( t = <ONE2> | t = <CURRENT> )
	{ return t.image; }
}

String All2(): { Token t; }
{
	t = <ALL2>
	{ return t.image; }
}

String Direct2(): { Token t; }
{
	t = <DIRECT2>
	{ return t.image; }
}

ExpressionList ObjectList(Exp stack): { Expression expression1; ExpressionList v; }
{
  { v = new ExpressionList(); }
  
  expression1 = GraphNode(stack)
  { v.add(expression1); }
  
  ( 
  	 <COMMA> 
     expression1 = GraphNode(stack)
     { v.add(expression1); }
  ) *
  
  { return v; }
}

Atom Verb() : { Atom atom; }
{
  ( 
    atom = PropertyVarOrIRIref() 
    | <KW_A> { atom = astq.createQName(RDFS.qrdftype); }
  )
  { return atom; }
}


Atom PropertyVarOrIRIref(): { Atom atom; Token t1; Variable var; Constant cst; String temp; }
{
  
  ( 
      atom = StdProperty()
      
    | atom = Var()
    
 
  )
  
  
  { return atom; }
}




Atom StdProperty(): {Variable var; Constant cst;  Expression exp;}
{
  	
  	  exp = RegExp()
      
      { cst = astq.createProperty(exp);
      } 
      
      ( 
      	<COLON2> 
      	var = Var() 
      	{ 
      		cst.setVar(var); 
      	} 
      )? 
      
      { return cst; }
      
}


Expression RegExp():{Token t; String s; Expression exp;}
{

(
	   t = <XPATH>   <LPAREN> s = String() <RPAREN>
	   
	  { exp = astq.createFunction(t.image, astq.createConstant(s, null, null)); }  |

	  exp = AddRegExp()   | 
	
	(
		t = <INV> | t = <SHORT> | t = <SHORTALL> | t = <DEPTH> | t = <BREADTH> | t = <DISTINCT> 
	)
	
	  	exp = RegExp()  { exp = astq.createOperator(t.image, exp); }
)
	
	{return exp;}
}



Expression AddRegExp():{Token t; Expression exp1, exp2;}
{
    exp1 = MultRegExp() 
    
    (
    	(
    		 t = <BAR>   exp2 = MultRegExp() 
   		    {exp1 = astq.createAltExpression(exp1, exp2); } 
   			 
   		)
   		|
   		(
   		    t = <SC_OR>   exp2 = MultRegExp() 
   		    {exp1 = astq.createParaExpression(exp1, exp2); } 
   		)
    
    ) *
    
    { return exp1;}

}


Expression MultRegExp():{Token t; Expression exp1, exp2;}
{

	exp1 = UnaryRegExp() 
	
	
	
	( t = <SLASH>  exp2 = UnaryRegExp() 
	
	  {exp1 = astq.createSeqExpression(exp1, exp2); } 
		
	) *

	{ return exp1;}

}


Expression UnaryRegExp():{Token t, t1, t2; Expression exp; Token ope; String s1, s2;}
{
(
	t = <BANG>   
	
	exp = PrimaryRegExp()   { exp = astq.createOperator(t.image, exp); }
	
	
|   t = <BEGIN_WITH>	

	exp = PrimaryRegExp()   { exp = astq.createOperator(t.image, exp);  }
	
//	( ope = OpeRegExp()     { exp = astq.createOperator(ope.image, exp); }  )  ? 

	
|	exp = PrimaryRegExp()  

    (  ope = OpeRegExp()     { exp = astq.createOperator(ope.image, exp); }   
    
    |
        
    
		<LBRACE>  
		  { s1 = null; s2 = null; }
		(
		  t1 = <INTEGER>  {s1 = t1.image; s2 = s1; }  (<COMMA> {s2 = null;} (  t2 = <INTEGER>  {s2 = t2.image;} )? )? 
		  
		  |
		  
   		  <COMMA>    t2 = <INTEGER>  {s2 = t2.image;}
   		)
   		<RBRACE> 
   		
   		{ exp = astq.createOperator(s1, s2, exp); }
    
    )  ? 
)

{ return exp;}

}





Token OpeRegExp() : {Token ope;}
{

(	ope = <STAR>
|	ope = <PLUS>
|	ope = <QM>
)

{ return ope; }

}


Expression PrimaryRegExp():{Token w; Expression exp, test, subject; Exp stack; String t; Constant cst;}
{
	( 
		exp = IRIrefConst() 
		
		|	
	
		<LPAREN> exp = AddRegExp() <RPAREN>
	) 
	
	
	( 	LOOKAHEAD(2)
		<AT> 
		
		(
		
		w = <INTEGER> { exp.setWeight(w.image); }
		
		|
		
		// [ a foaf:Person ]
		
		  { stack = BasicGraphPattern.create(); subject = astq.createVariable(THIS);}
		  		  
		   <LBRACKET>
  			stack = PropertyListNotEmpty(subject, stack)    
  		   <RBRACKET>
		   
		  //test = Expression(stack) 
		  
		  {exp = astq.createRegexTest(exp, stack);} 
		
		|
		
		// { ?this a foaf:Person }
		  stack = GroupGraphPattern()
		  
		 {exp = astq.createRegexTest(exp, stack);} 

		  
		)	
	) ?   
	
	
	{ return exp; }

}



Token Soper(): { Token t; }
{
  ( 
    t = <EQ> | t = <NE> 
  | t = <LT> | t = <GT>
  | t = <LE> | t = <GE>
  | t = <EQ2> | t = <NE2> 
  | t = <TILDE> 
 // | t = <IN> 
  | t = <BEGIN_WITH>
  )
  { return t; }
}

Token Toper(): { Token t; }
{
  ( t = <STRICT_SPEC> | t = <SPEC> | t = <SAME>
  | t = <GENERALISATION> | t = <STRICT_GENERALISATION> )
  { return t; }  
}

// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples

Expression TriplesNode(Exp stack) : { Expression expression1; }
{
  ( 
  	expression1 = Collection(stack) 
  	| expression1 = BlankNodePropertyList(stack) 
  )
  { return expression1; }
}

Expression BlankNodePropertyList(Exp stack) : { Expression expression1; }
{
  { 
  	// [ :p ?y ]
  	expression1 = astq.newBlankNode();
  }
  <LBRACKET>
  stack = PropertyListNotEmpty(expression1, stack)    
  <RBRACKET>
  { return expression1; }
}

// ------- RDF collections
/**
* see: http://www.w3.org/TR/rdf-sparql-query/#collections
*
* exemple 1: The collection ( 1 ?x 2 3 ) generates 8 triples:
* _:b0 rdf:first 1		_:b0 rdf:rest _:b1
* _:b1 rdf:first ?x		_:b1 rdf:rest _:b2
* _:b2 rdf:first 2		_:b2 rdf:rest _:b3
* _:b3 rdf:first 3		_:b3 rdf:rest rdf:nil
*
* exemple 2: The collection ( ?x [ :p 'v' ] ( 3 ) ) generates 9 triples:
* _:b0 rdf:first x		_:b0 rdf:rest _:b1
* _:b1 rdf:first _:b2	_:b1 rdf:rest _:b3		_:b2 :p 'v'
* _:b3 rdf:first _:b4	_:b3 rdf:rest rdf:nil	_:b4 rdf:first 3	_:b4 rdf:rest rdf:nil
*
*/
Expression Collection(Exp stack) : 
{ 
  ArrayList<Expression> list;
  Expression node, head;
  RDFList rlist;
  int arobase = ASTQuery.L_DEFAULT, save = ASTQuery.L_LIST;
}
{
	{
		list = new ArrayList<Expression>();
                save = astq.getListType();
	}
	
	//  @( ) means rewrite as rdf:rest*/rdf:first
	
	( 
                ( 
		 <ATLIST>    { arobase = ASTQuery.L_LIST; astq.setListType(arobase); }  
                )
                |
                (
		  (<AT> | <ATPATH>) { arobase = ASTQuery.L_PATH; astq.setListType(arobase); } 
                ) 
                
	) ?
	
  	<LPAREN>
  	(
  		node = GraphNode(stack)
  		{
  			list.add(node);
  		}   
  	) +
  	<RPAREN>
  	{ 
  	    head = list(stack, list, arobase);
            astq.setListType(save);
  	    return head; 
  	}
}






// -------- Nodes in a graph pattern or template

Expression GraphNode(Exp stack) : { Expression expression1; }
{
  (   LOOKAHEAD(2)
  	  expression1 = VarOrTerm(stack) 
  	| expression1 = TriplesNode(stack)   	
  )
  { return expression1; }
}

Atom VarOrTerm(Exp stack) : { Atom expression1; }
{
  ( expression1 = Var() | expression1 = GraphTerm(stack) )
  { return expression1; }
}

Atom VarOrBlankNodeOrIRIref(Exp stack) : { Atom a; String s; }
{
  ( 
    a = Var() { s = a.getName(); } 
    | a = BlankNode(stack) { s = a.getName(); } 
    | a = IRIrefConst() 
  )
  { return a; }
}

Atom VarOrIRIref(Exp stack) : { Atom a; String s; }
{
  ( 
      a = Var() 
    | a = IRIrefConst() 
  )
  { return a; }
}


Variable Var() : { Token t1; Variable res; String s; boolean isPath = false;}
{
  ( t1 = <VAR1> { s = t1.image; } | 
    t1 = <VAR2> { s = "?"+(t1.image).substring(1,(t1.image).length()); isPath = true;} ) 
  { res = ASTQuery.createVariable(s, astq); res.setPath(isPath);}
  
  { return res; }
}

Atom GraphTerm(Exp stack) : { Constant cst; String s; Token t1; Variable var; Atom a; }
{
  (
  	( 
  	s = Q_IRI_ref() { cst = astq.createURI(s); }
  	| t1 = <QNAME> 
  		{ cst = astq.createQName(t1.image);  }
    	( 
 	   	<COLON2> 
 	   	var = Var() 
 		{ cst.setVar(var); } 
 	    )?
  	| t1 = <QNAME_NS> { cst = astq.createQName(t1.image); }
  	| cst = RDFLiteral() 
  	| // ( <MINUS> | <PLUS> )? 
  	  cst = NumericLiteral()
  	| cst = BooleanLiteral()   
  	| 
 // 		t1 = <NIL> 
  		t1 = <LPAREN>  <RPAREN> 
  	{ cst = astq.createQName(RDFS.qrdfNil); }  
  	) { a = cst; }
  	| a = BlankNode(stack) 
  )
  { return a; }
}

// -------- Constraint syntax

Expression Expression(Exp stack) : { Expression expression1; }
{	
  expression1 = ConditionalOrExpression(stack)
  { return expression1; }
}

Expression ConditionalOrExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = ConditionalAndExpression(stack)
  ( 
    t1 = <SC_OR> 
    expression2 = ConditionalAndExpression(stack) 
    { expression1 = astq.createConditionalOrExpression(t1.image, expression1, expression2); }
  )* 
  { return expression1; }  
}

Expression ConditionalAndExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = ValueLogical(stack)
  ( 
    t1 = <SC_AND> 
    expression2 = ValueLogical(stack) 
    { expression1 = astq.createConditionalAndExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression ValueLogical(Exp stack) : { Expression expression1; }
{
  expression1 = RelationalExpression(stack)
  { return expression1; }
}

Expression RelationalExpression(Exp stack) : { Token t1; Expression expression1, expression2; ExpressionList el; boolean not = false;}
{
  expression1 = NumericExpression(stack)
  ( 
    (   
        t1 = Soper() expression2 = NumericExpression(stack)
//      | t1 = Toper() expression2 = NumericExpression(stack)  
      |  (<NOT> {not = true;} )? 
        t1 = <IN>    el = ArgList(stack) {expression2 = astq.createList(el);}
    ) 
    
    { expression1 = astq.createRelationalExpression(t1.image, expression1, expression2); 
    if (not){
    	expression1 = astq.negation(expression1);
    	}
    }
  )?
  { return expression1; }
}




Expression NumericExpression (Exp stack) : { Expression expression1; }
{
  expression1 = AdditiveExpression(stack)
  { return expression1; }
}

Expression AdditiveExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = MultiplicativeExpression(stack)
  ( 
  	  t1 = <PLUS> expression2 = MultiplicativeExpression(stack) 
  	  { expression1 = astq.createAdditiveExpression(t1.image, expression1, expression2); }
    | t1 = <MINUS> expression2 = MultiplicativeExpression(stack) 
      { expression1 = astq.createAdditiveExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression MultiplicativeExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = UnaryExpression(stack)
  ( 
    ( 
    	t1 = <STAR> expression2 = UnaryExpression(stack) 
      | t1 = <SLASH> expression2 = UnaryExpression(stack) 
    ) 
    { expression1 = astq.createMultiplicativeExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
//   | <REM> UnaryExpression()
}

Expression UnaryExpression(Exp stack) : { Token t1; Expression expression1; }
{
  (   t1 = <BANG> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | t1 = <PLUS> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | t1 = <MINUS> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | expression1 = PrimaryExpression(stack) 
  )
  { return expression1; }
}

Expression BuiltInCall(Exp stack) : { Expression expression1, expression2; Variable var1; Token t1; Term term; }
{
  (
    ( ( 
        t1 = <STR> | 
        t1 = <DTYPE> | t1 = <LANG> | t1 = <IS_IRI> | t1 = <IS_URI> | 
        t1 = <IS_BLANK> | t1 = <IS_LITERAL> ) 
    	<LPAREN> expression1 = Expression(stack) <RPAREN> 
      { term = astq.createFunction(t1.image, expression1); } 
    )
    | t1 = <BOUND> <LPAREN> var1 = Var() <RPAREN> 
      { term = astq.createFunction(t1.image, var1); } 
    | t1 = <LANGMATCHES> <LPAREN> expression1 = Expression(stack) <COMMA> expression2 = Expression(stack) <RPAREN>
      { term =  astq.createFunction(t1.image, expression1); 
        term.add(expression2); } 
    | term = RegexExpression(stack)
    | term = exists()
  )
  { return term; }
}


Term exists() : {Exp exp; Term term; boolean neg;}
{
	{neg = false;}
	       
        ( <NOT> {neg = true;} ) ?  
        <EXIST> exp = GroupGraphPattern()

	{
		term = astq.createExist(exp, neg);
		return term;
	}
}


Term RegexExpression(Exp stack): { Term term; Token t; Expression expression1, expression2; }
{
  t = <REGEX> 
  <LPAREN>
      expression1 = Expression(stack) <COMMA> expression2 = Expression(stack)
      { term = astq.createFunction(t.image, expression1);
      term.add(expression2); }
      ( <COMMA> expression2 = Expression(stack) { term.add(expression2); } ) ?
  <RPAREN>
  { return term; }
}

Term FunctionCorese(Exp stack): { Token t; Term term = null; ExpressionList v; Constant cst; }
{	
	// distance namespace isMulti sqrt depth cardinality isuri occurence
  ((
	( t = <SIMPLE_STRING> | t = <DISTANCE> | t = <SCORE> | t = <COUNT> | t = <XPATH> )
	v = ArgList(stack)
	{ 
		term = astq.createFunction(t.image, v); 
	}
  )
  | term = IfThenElse(stack)
  | term = Let(stack)
  | term = Set(stack)
  | term = For(stack)
  )

  { return term; }
}


Term IfThenElse (Exp stack) : {Expression test, e1, e2 = null;}
{
    <IF> <LPAREN> test = Expression(stack)

    (
     <COMMA> e1 = Expression(stack) <COMMA> e2 = Expression(stack) <RPAREN>  
    |
     <RPAREN>
//     <LBRACE> e1 = Expression(stack) <RBRACE>  
       e1 = Body(stack)
     (<ELSE> 
        (
//          <LBRACE> e2 = Expression(stack) <RBRACE>
            e2 = Body(stack)
          |
          e2 = IfThenElse (stack)
        )
     ) ?     
    )
    { return astq.ifThenElse(test, e1, e2); }
}


Term For (Exp stack) : 
{Exp sub; Term t; Expression exp, body ; Variable var; ExpressionList arg; }
{
    <FOR> <LPAREN> var = Var() <IN> 
    (
        exp = Expression(stack) 
        |
        sub = SubQueryExp() { exp = astq.toExist(sub); }
        |
        sub = SubConstruct() { exp = astq.toExist(BasicGraphPattern.create(sub)); }
    )
    <RPAREN>   
    body = Body(stack)
    
    { t = astq.loop(var, exp, body); 
      return t;}
}

Term Let (Exp stack) : 
{ Expression exp ; Expression arg; ExpressionList list; }
{
        <LET>
        <LPAREN> { list = new ExpressionList(); }
               arg = LetDef(stack) { list.add(arg); }
               ( <COMMA> arg = LetDef(stack) { list.add(arg); } )*
        <RPAREN>
        exp = Body(stack)
    
      { return astq.let(list, exp); }
}

Term Set (Exp stack) : { Expression exp ; Variable var;}
{
        <SET>
        <LPAREN> 
            var = Var()
            <EQ>
            exp = Expression(stack)            
        <RPAREN>
           
      { return astq.set(var, exp); }
}


Expression LetDef(Exp stack) : 
{ Variable var = null;   Expression exp ; ExpressionList el = null; Exp sub;}
{
  
  ( var = Var() 
    | 
    	       
    <LPAREN> { el = new ExpressionList();  }
	var = Var()  { el.add(var); } 
	( <COMMA> var = Var()  { el.add(var); } ) *					
    <RPAREN>	    					     
  )
  <EQ>
  (  
    exp = Expression(stack) 
    |
    sub = SubQueryExp() { exp = astq.toExist(sub); }
    |
    sub = SubConstruct() { exp = astq.toExist(BasicGraphPattern.create(sub)); }

  )
			
   { return (el == null) ? astq.defLet(var, exp) : astq.defLet(el, exp);  }
 
}

Term FunctionCall(Exp stack) : { Term term1;   ExpressionList v; Constant cst;}
{
  cst = IRIrefConst()
  v = ArgList(stack)
  { 
  	term1 = astq.createFunction(cst, v); 
  }
  { return term1; }
}

// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()

Expression IRIrefOrFunction(Exp stack) : {Expression exp;}
{
     exp = StdIRIrefOrFunction(stack) 
       
    { return exp;}
}

Expression StdIRIrefOrFunction(Exp stack) : { String s1; ExpressionList v; Term term; Expression expression;  Constant cst;}
{
  cst = IRIrefConst() {expression = cst;}
  ( LOOKAHEAD(2)
    v = ArgList(stack)
    { 
    	term = astq.createFunction(cst, v); 
	  	expression = term;
    } 
  )?
  { return expression; } 
}

Term Function(Exp stack) : { Term term;   ExpressionList v; Constant cst; Expression body;}
{
  <FUNCTION> cst = IRIrefConst()
  v = ArgList(stack)
  body = Body(stack)

  { 
  	term = astq.defineFunction(cst, v, body ); 
  }
  { return term; }
}

Expression Body(Exp stack) : { ExpressionList body = new ExpressionList(); Expression exp = null;}
{
 <LBRACE> ( <RBRACE> |        
        exp = Expression(stack) { body.add(exp); } 
        ( <SEMICOLON> exp = Expression(stack) { body.add(exp); } ) *
            <RBRACE>
        ) 
    { return astq.defineBody(body) ; }
}

void Export(Exp stack) : { Term term; }
{
    <EXPORT> 
    <LBRACE> 
        ( term = Function(stack) { astq.exportFunction(term); } ) +
    <RBRACE>
}


ExpressionList ArgList(Exp stack) : { ExpressionList v; Token t; Expression expression1; String str;}
{
  { 
  	// Vector containing either Expression or Variable
  	v = new ExpressionList();
  }
  
  ( 
       	 
  	<LPAREN> 
  	
	  	(<DISTINCT> {v.setDistinct(true);}) ? 
	  	
	  	(
		  	<STAR> 
		  	
		  	|
		   
		              expression1 = Arg(stack) { v.add(expression1); }
		              
		    ( <COMMA> expression1 = Arg(stack) { v.add(expression1); } )*
		    
	    ) ?
	    
    ( <SEMICOLON>  <SEPARATOR>  <EQ>  str = String() { v.setSeparator(str); } ) ?
    
    <RPAREN>
    
  )
  { return v; }
}


Expression Arg(Exp stack) : {Expression exp;}
{
	(
		exp = Expression(stack)  | exp = Array(stack)
	)
	{
		return exp;
	}
}



// fun(?x, [1 2 3])
// return a blank that contains an array (aka pointer !)
Expression Array(Exp stack) : {Expression exp; ExpressionList array;}
{
	{ 
  		array = new ExpressionList(); 
    }
  
	<LBRACKET> 
		          exp = Arg(stack) { array.add(exp); }
		( <COMMA> exp = Arg(stack) { array.add(exp); } ) * 
		
	<RBRACKET>
		
	{
		exp = astq.newArray(array);
		return exp;
	}
}



Expression BrackettedExpression(Exp stack) : { Expression expression1; }
{
	<LPAREN> expression1 = Expression(stack) <RPAREN>
	{ 
		return expression1; 
	}
}

Expression PrimaryExpression(Exp stack) : { Expression expression1; }
{
  ( 
   expression1 = BrackettedExpression(stack)	// Expression
   | expression1 = BuiltInCall(stack)		// Expression
   | expression1 = FunctionCorese(stack)	// Term
   | expression1 = Var()				// Variable
   | expression1 = RDFLiteral()			// Constant
   | expression1 = NumericLiteral()		// Constant
   | expression1 = BooleanLiteral()		// Constant
   | expression1 = BlankNode(stack) 			// Constant
   | expression1 = IRIrefOrFunction(stack)   // Expression
   // NOT  |  VarOrTerm()        
   // Because of IRIrefOrFunction
  )
  { return expression1; }
}

Constant NumericLiteral() : { Token t; String datatype; }
{
   ( t = <INTEGER> { datatype = RDFS.qxsdInteger; } 
   | t = <DECIMAL> { datatype = RDFS.qxsdDecimal; } 
   | t = <DOUBLE>  { datatype = RDFS.qxsdDouble; } )
   { return astq.createConstant(t.image, datatype, null); }
}

Constant RDFLiteral() : { Constant res; String iriref, s, lang; Token t; }
{
  s = String()
  { iriref = null; lang=null; }
  (
    t = <LANGTAG> { lang = t.image.substring(1,t.image.length()); }
    | ( t = <DATATYPE> iriref = IRIref() )  
  )?
  { res = astq.createConstant(s, iriref, lang); }
  { return res; }
}

Constant BooleanLiteral() : { Token t1, t2; Constant cst; String iriref, lang;}
{
  ( t1 = <TRUE> | t1 = <FALSE> )  
  { iriref = RDFS.qxsdBoolean; lang=null; }
  
  { 
  	cst = astq.createConstant(t1.image.toLowerCase(), iriref, lang);
  	return cst; 
  } 
}

String String() : { Token t; }
{
  (  t = <STRING_LITERAL1>
  |  t = <STRING_LITERAL2>       
  |  t = <STRING_LITERAL_LONG1>
  |  t = <STRING_LITERAL_LONG2> 
  )
  { return remEscapes(t.image); }
}

String IRIref() : { String res; }
{
   ( res = Q_IRI_ref() 
   | res = QName() )
   { return res; }
}


Constant IRIrefConst() : { String res; Constant cst;}
{
   ( res = Q_IRI_ref() {cst = astq.createURI(res);}
   | res = QName()     {cst = astq.createQName(res);}
   )
   { return cst; }
}



String QName(): { Token t; }
{
  ( t = <QNAME> | t = <QNAME_NS> )
  { return t.image; }
}

Variable BlankNode(Exp stack): { Token t; Variable v; }
{
  ( 
 	t = <BLANK_NODE_LABEL> 
	{
 		// check if the blank node is already in the table
  		v = astq.newBlankNode(stack, t.image);
		
  	}
  	| t = <ANON>   	
  	{ 
  		// create a new blank node
  		v = astq.newBlankNode(); 
  	}
  )
  { 
  	return v; 
  }
}


String Q_IRI_ref() : { Token t; String s; }
{
   	t = <Q_IRIref>
	{ 
		s = t.image;
      	s = s.substring(1,s.length()-1); 
      	s = astq.defURI(s);
   	  	return s; 
   	}
}


// ------------------------------------------
// Tokens
// ------------------------------------------

TOKEN_MGR_DECLS:{
		
	void CommonTokenAction(Token token) {
		//System.out.println(token+" ");
	}
}

// Comments and whitespace

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN: { <#WS: " " | "\t" | "\n" | "\r" | "\f"> }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

// Main tokens */

TOKEN:
{
   // Includes # for relative URIs
   <Q_IRIref: "<" (~[">","<","\u0000"-"\u0020"])* ">" > 
   
| <QNAME_NS: (<NCNAME_PREFIX>)? ":" >

| <QNAME: (<NCNAME_PREFIX>)? ":" (<NCNAME>)? >

//| <BLANK_NODE_LABEL:   "_:"   ( ["0"-"9"]  | <NCNAME> )   ( (<NCNAME> | ".")* <NCNAME> ) ?   >


| <BLANK_NODE_LABEL:   "_:"   ( ["0"-"9"]  | <BLANKNAME> )   ( (<BLANKNAME> | ".")* <BLANKNAME> ) ?   >



| <VAR1: "?" <VARNAME> >
| <VAR2: "$" <VARNAME> >
| <ABASE:   "@base">
| <APREFIX: "@prefix">
| <ATLIST: "@list" >
| <ATPATH: "@path" >
| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >	
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
}

// -------------------------------------------------
// Keyworks : includes operators that are words and should be
// before general things like IDENTIFIER which swallow almost
// anything

TOKEN : { 

	<KW_A: "a" > 
|	<INV: "i" >
|	<SHORT:    "s"   >
|	<SHORTALL: ("sa" | "short")>
|	<DEPTH: "d" >
| <BREADTH: "b">
| <LIST: "list" >

} // Before HEX rule!

TOKEN [IGNORE_CASE] :
{
// Prologue
  < BASE: "base" >
| < PREFIX: "prefix" >
// Result forms
| < SELECT: "select" >
| < DESCRIBE: "describe" >
| < CONSTRUCT: "construct" >
| < RULE: "rule" >
| < ASK: "ask" >
| < TEMPLATE: "template" >

| < DISTINCT: "distinct" >
| < SEPARATOR: "separator" >

| < REDUCED: "reduced" >
| < LIMIT: "limit" >
| < OFFSET: "offset" >
| < ORDER: "order" >
| < BY: "by" >
//| < ANY: "any" >
| < RELAX: "relax" >

| < ASC: "asc" >
| < DESC: "desc" >

// Dataset
| < NAMED: "named" >
| < FROM: "from" >

// Graph pattern operators 
| < WHERE: "where" >
| < AND: "and" >
| < GRAPH: "graph" >
| < SERVICE: "service" >
| < REC : "rec" >
| < STATE : "state" >
| < LEAF : "leaf" >
| < OPTIONAL: "optional" >
| < UNION: "union" >
| < MINUSP: "minus" >
| < NOT: "not">
| < SCOPE: "scope">
| < LET: "let">
| < SET: "set">
| < FOR: "for">
| < IF: "if">
| < THEN: "then">
| < ELSE: "else">
| < EXIST: "exists">
| < FILTER: "filter" >


// UPDATE

| < LOAD: "load">
| < CLEAR: "clear">
| < DROP: "drop">
| < CREATE: "create">
| < ADD: "add" >
| < TO: "to"> 
| < MOVE: "move">
| < COPY: "copy">
| < INSERT: "insert">
| < DELETE: "delete">
| < WITH: "with">
| < USING: "using">
| < DEFAUT: "default">
| < ALL: "all">
| < INTO: "into">
| < SILENT: "silent">
| < DATA: "data">


// Expression operators
| < BOUND: "bound" >
| < STR: "str" >
// |  < URI:         "uri" >
| < DTYPE: "datatype" >
| < LANG: "lang" >
| < LANGMATCHES: "langmatches" >
//|  < IS_IRI:      ("isIRI"|"isURI") >
| < IS_URI: "isURI" >
| < IS_IRI: "isIRI" >
| < IS_BLANK: "isBlank" >
| < IS_LITERAL: "isLiteral" >
| < REGEX: "regex" >

| <TRUE: "true" >
| <FALSE: "false" >
}

// -------------------------------------------------
// Rajouts pour CORESE
// -------------------------------------------------

TOKEN [IGNORE_CASE] :
{
  <ONE: "one" >
| <S_MORE: "more" >
| <MERGE: "merge" >
| <DISPLAY: "display" >
| <PRAGMA: "pragma" >
| <D_RDF: "rdf" >
| <D_JSON: "json" >
| <D_FLAT: "flat" >
| <D_ASQUERY: "asquery" >
| <D_XML: "xml" >
| <D_BLANK: "blank" >
//| <D_TABLE: "table" >
| <THRESHOLD: "threshold" >
| <RESULT: "result" >
| <PROJECTION: "projection" >
| <GROUP: "group" >
| <BOX: "box" >
| <IBOX: "ibox" >
| <SBOX: "sbox" >
| <HAVING: "having" >
| <BINDINGS: "bindings" >
| <VALUES: "values"  >
| <BIND: "bind">
| <UNDEF: "undef">
| <COUNT: "count" >
| <SOURCE: "source" >
| <SCORE: "score" >
| <AS: "as" >
| <SORT: "sort" >
| <REVERSE: "reverse" >
| <OR: "or" >
| <OPTION: "option" >
| <SORTED: "sorted" >
| <ALL2: "all::" >
| <CURRENT: "current::" >
| <ONE2: "one::">
| <DIRECT2: "direct::" >
| <COLON2: "::" >
| <DISTANCE: "distance">
| <DEBUG: "debug">
| <CHECK: "check">
| <NOSORT: "nosort">
| <TUPLE: "tuple">
| <XPATH: "xpath">
| <FUNCTION: "function">
| <EXPORT: "export">
}

TOKEN [IGNORE_CASE] :
{
  <IN: "in">
}

TOKEN :
{
  <EQ2: "==">
| <NE2: "!==">
| <BEGIN_WITH: "^">
| <STRICT_SPEC: "<:">
| <SPEC: "<=:">
| <SAME: "=:">
| <GENERALISATION: ">=:">
| <STRICT_GENERALISATION: ">:">
| <EQ_LANG: "~=">
}

TOKEN [IGNORE_CASE] :
{
  <SIMPLE_STRING: <NCNAME> >  
}

// -------------------------------------------------

TOKEN :
{
   < INTEGER: (["-"])? <DIGITS> >
|
   < DECIMAL: (["-"])? (<DIGITS>)+ "." (<DIGITS>)* | "." (<DIGITS>)+ >
      // Required exponent.
| < DOUBLE:
      (["-"])?
      (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
      | "." (["0"-"9"])+ (<EXPONENT>)
      | (["0"-"9"])+ <EXPONENT>
      >

   // Optional exponent.
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">
| <ECHAR: "\\" ("t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'")>

| < STRING_LITERAL1:
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" >
      
| < STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >
      
| < STRING_LITERAL_LONG1:
     <QUOTE_3S>
      ( ( "'" | "''" ) ?     ( ~["'", "\\"] |  <ECHAR> ) )*
     <QUOTE_3S> >
     
| < STRING_LITERAL_LONG2:
     <QUOTE_3D>
      ( ( "\"" | "\"\"" ) ?  ( ~["\"", "\\"] |  <ECHAR> ) )*
     <QUOTE_3D> >    
          
 
  
     
     
| < DIGITS: (["0"-"9"])+>
| <HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >

// I don't know why white space is needed to be included here but not ANON
//| <NIL: <LPAREN> (<WS>)* <RPAREN> >

| < LBRACE: "{" >
| < RBRACE: "}" >

| < LBRACKET: "[" >
| < RBRACKET: "]" >
// (<WS>)* is not needed but is in NIL
| < ANON: <LBRACKET> (<WS>)* <RBRACKET> >

| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Operator

TOKEN :
{
  < EQ: "=" >
| < NE: "!=" >
| < GT: ">" >
| < LT: "<" >
| < LE: "<=" > // Maybe: | "=>" >
| < GE: ">=" > // Maybe: | "=<" >

| < BANG: "!" >
| <TILDE: "~">
| < COLON: ":" >

| < SC_OR: "||" >
| < SC_AND: "&&" >

| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < QM: "?" >
| < BAR: "|" >


//| < AMP: "&" >
//| < REM: "%" >

| < DATATYPE: "^^">
| < AT: "@">
}

// See XML chars.txt for notes

TOKEN:
{
  // XML 1.1 NCNameStartChar without "_"
  <#NCCHAR1p:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFDCF"] | ["\uFDF0"-"\uFFFD"] >
          //["\u10000"-"\uEFFFF"] >
|
  <#NCCHAR1: <NCCHAR1p> | "_" >

// No trailing DOTs in qnames.
|
  // #NCCHAR without "."
  <#NCCHAR: (<NCCHAR1> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  // NCNAME but no leading "_", no trailing ".", can have dot inside prefix name.
  <#NCNAME_PREFIX: <NCCHAR1p> ((<NCCHAR> | "."   )* <NCCHAR>)? >
|
  // With a leading "_", no dot at end of local name.
    
    <#NCNAME:  <NCCHAR1>   ((<NCCHAR> | "." | ":" | "_" | <LOCAL_ESC> | <PERCENT> )*     (<NCCHAR> | ":" | <LOCAL_ESC> | <PERCENT> ))? > 
|


    <#BLANKNAME:  <NCCHAR1>   ((<NCCHAR> | "." |  "_"  )*     (<NCCHAR>) )? > 


|
  // NCNAME without "-" and ".", allowing leading digits.
  <#VARNAME: ( <NCCHAR1> | ["0"-"9"] )
             ( <NCCHAR1> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
               
               
| <#LOCAL_ESC:  "\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "\"" | "(" | ")" | "*" | "+" | "," | ";" | "=" |  "/" | "?" | "#" | "@" | "%" )  >



| <#PERCENT: "%" <HEX> <HEX> >

}

/*
 * (c) Copyright 2004, 2005 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
