// Author: Virginie BOTTOLLIER & Olivier Corby
// 07/11/2005
// This version of the grammar is for SPARQL 1.1 select expression wich needs ()
// select (fun(?x) as ?y) where
// the difference starts at BEGIN SPARQL1.1

options
{
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true ;
  STATIC = false ;
  COMMON_TOKEN_ACTION = true;
// Do \ u processing outside javacc
// JAVA_UNICODE_ESCAPE   = false ;
// UNICODE_INPUT         = true ;
// DEBUG_PARSER          = true ;	// set to true to see calls to functions
// DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(SparqlCorese)
  
  	package fr.inria.corese.sparql.triple.javacc1;

        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;
	
	import java.util.List;
	import java.util.ArrayList;
	import java.util.Vector;
  	import fr.inria.corese.sparql.triple.cst.RDFS;
  	import fr.inria.corese.sparql.triple.parser.*;
  	import fr.inria.corese.sparql.triple.function.script.*;
  	import fr.inria.corese.sparql.triple.update.*;
  	import fr.inria.corese.sparql.triple.api.Creator;
  	import fr.inria.corese.sparql.api.IDatatype;
  	import fr.inria.corese.sparql.datatype.DatatypeMap;
  	
  
  /**
  * <p>Title: Corese</p>
  * <p>Description: A Semantic Search Engine</p>
  * <p>Copyright: Copyright INRIA (c) 2006</p>
  * <p>Company: INRIA</p>
  * <p>Project: Acacia</p>
  * <br>
  * This file defines the SPARQL/Corese grammar; it's from it, that we create 
  * the 7 others classes, thanks to the JavaCC technology.
  * <br>
  * @author Virginie Bottollier
  */
  public class SparqlCorese {
  
    /** An instanciation of the class Parser */
    //Parser parser;
    /** An instanciation of the class ASTQuery (a graph representing the query) */
    ASTQuery astq, gast;
    ASTUpdate astu;
    ASTTemplate astt;
    Basic prolog;
    Creator create;
    ParserHandler handler;
    
    /** should we say to the user when he uses something deprecated? (option, sort, or, source, as...) */
    boolean printDeprecated = true;
	
	/** logger from log4j */
	//private static Logger logger = LogManager.getLogger(SparqlCorese.class);
	private static Logger logger = LoggerFactory.getLogger(SparqlCorese.class);

    /** To show some printings */
    boolean show = false;
    /** To show some printings about the part of the parser which deals with Expression */
    boolean debug2 = show && false;
    static final String THIS = "?this";

	public void setASTQuery(ASTQuery aq) {
		astq = aq;
		gast = aq;
	}
	
	public void set(Creator c){
	    create = c;
            if (handler != null) {
                handler.setCreator(c);
            }
	}

        public void setHandler(ParserHandler h) {
            handler = h;
            handler.setParser(this);
        }

        public ParserHandler getHandler() {
            return handler;
        }
	
	/**
	* @param s1 = the string deprecated
	* @param s2 = how to replace s1
	*/
	public void deprecated(String s1, String s2) {
		if (printDeprecated) {
			logger.debug("*** \""+s1+"\" is deprecated, you should use \""+s2+"\" instead");
		}
	}

  // Method for converting Unicode escape sequences \\uxxxx and \\Uxxxxxxxx
  String convertUnicodeSequences(String str) {
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < str.length(); i++) {
          char ch = str.charAt(i);
          // Checks whether the current character is a backslash and whether there is another character before it
          if (ch == '\\' && i + 1 < str.length()) {
              // Checks whether it is a literal escape sequence (preceded by a backslash)
              if (i > 0 && str.charAt(i - 1) == '\\') {
                  sb.append(ch);
                  continue;
              }
              
              char nextCh = str.charAt(i + 1);
              if (nextCh == 'u' && i + 5 < str.length()) { // Manage \\uxxxx
                  int code = Integer.parseInt(str.substring(i + 2, i + 6), 16);
                  sb.append(Character.toChars(code));
                  i += 5; // Skip escape sequence
                  
              } else if (nextCh == 'U' && i + 9 < str.length()) { // Manage \\Uxxxxxxxx
                  int code = Integer.parseInt(str.substring(i + 2, i + 10), 16);
                  for (char c : Character.toChars(code)) {
                      sb.append(c);
                  }
                  i += 9; // Skip escape sequence
              } else {
                  sb.append(ch); // If this is not an escape sequence, add the character as is
              }
          } else {
              // Handles the case where a literal backslash is immediately followed by another character (not 'u' or 'U')
              if (ch == '\\' && i > 0 && str.charAt(i - 1) == '\\') {
                  // Do nothing here to avoid adding the literal backslash a second time
              } else {
                  sb.append(ch);
              }
          }
      }
      return sb.toString();
  }


        public ParseException createStopException() {
            return new ParseException("stop");
        }
    
    /**
     * @throws JavaccParseException
     * @throws TokenMgrError
     * @return
     */
    public ASTQuery parse() throws JavaccParseException, TokenMgrError {
        Exp ex;
        astu = ASTUpdate.create();
        try {
        	ex = Start();
        } catch (ParseException e) {
        	throw new JavaccParseException(e);
        }
        catch (Error e) {
            throw new JavaccParseException(e);
        }
        if (show)
        	for (int i = 0; i<ex.size();i++) {
        		logger.debug("sparql-parser - ex.get("+i+"): "+ex.get(i));
        	} 
        
        astq.setBody(ex);
        return astq;
    }   
    
    
    public ASTQuery load() throws JavaccParseException, TokenMgrError {
        astu = ASTUpdate.create();
        try {
       	  Exp exp = LoadPattern();
          astq.setBody(exp);
       	}
        catch(ParseException e) {
            if (e.getMessage().equals("stop")) {
                throw new JavaccParseException();
            }
            throw new JavaccParseException(e);
        }
        return astq;
    }

    public ASTQuery nquad() throws JavaccParseException, TokenMgrError {
        astu = ASTUpdate.create();
        try {
       	  Exp exp = nquadPattern();
          astq.setBody(exp);
       	}
        catch(ParseException e) {
            throw new JavaccParseException(e);
        }
        return astq;
    }

    boolean isLoad() {
        return create != null;
    } 
                 
    void defNamespace(String p, String ns){
    	astq.defNamespace(p, ns);
    	astu.defNamespace(p, ns);
    }
    
    void defBase(String s){
    	astq.defBase(s);
    	astu.defBase(s);
    }

    Metadata metadata(Metadata global, Metadata local) {
        if (local == null) {
            return global;
        }
        else {
            local.setMetadata(global);
            return local;
        }
    }
  
    
}  
  
 
PARSER_END(SparqlCorese)





Exp Start(): { Exp stack; }
{
	{ stack = new And(); }
  	 stack = Query()  <EOF> 
  	{ return stack; }
}

Exp Rule(): { Exp stack; }
{
	{ stack = new And(); }
	Prolog()
  	 stack = GroupGraphPattern()  <EOF> 
  	{ return stack; }
}

Exp Query() : { Exp stack; Metadata global=null, la = null;}
{

	{stack = BasicGraphPattern.create();}
	  
  Prolog()
    (     la = Annotate()
       ( 
            ( {astq.setAnnotation(la);}  stack = SelectQuery(la)    
            | stack = ConstructQuery(la) 
            | stack = DescribeQuery(la)  
            | stack = AskQuery(la)        
            | UpdateQuery(la)            	
            | stack = TemplateQuery(la)
            )  (Defun()) 
        |  
            ( Function(global, la) | Package(la) ) Defun()
        )
  	     	
  ) ?
  
  { return stack; }
}

void Defun() : { Metadata global = null, la = null;} {
    ( 
        la = Annotate() (Function(global, la) | Package(la)) 
    ) *
}

Exp nquadPattern() : {Exp stack; Atom subject, predicate, object, graph=null;}
{
        {stack = BasicGraphPattern.create();}

	(BaseDecl())? 
        (PrefixDecl())?
        ( { graph = null; }
         subject   = nquadTerm(stack) 
         predicate = GraphTerm(stack)     
         object    = nquadTerm(stack)
         (graph    = GraphTerm(stack))?
        <DOT>
         { handler.createNquad(subject, predicate, object, graph); }
        ) *    
        <EOF>

	{ return stack; }
}

Atom nquadTerm(Exp stack) : {Atom at;}
{
    (at = GraphTerm(stack) | at = StarTriple(stack))
    {return at;}
}



Exp LoadPattern() : {Exp stack;}
{
        {stack = BasicGraphPattern.create();}

	(
          BaseDecl() 
        | PrefixDecl()
        | LOOKAHEAD(2) TriplesSameSubject(stack) ( <DOT> ) ?
        | (<GRAPH>)? BasicGraphGraphPattern(stack) 

        ) *

        <EOF>
	{ return stack; }
}

Exp LoadPattern2() : {Exp stack;}
{
	Prolog()
	stack = BodyQuadPattern() <EOF>
	{ return stack; }
}



void Prolog() : {}
{
     
   (  BaseDecl() | PrefixDecl() )*
}

void BaseDecl() : { Token t; String s; Triple triple; }
{
  (<BASE> | <ABASE>)   s = Q_IRI_ref() (<DOT>) ?
  {
	defBase(s);
  }
}


void PrefixDecl() : { Token t1, t2; String s; Triple triple; }
{
    (<PREFIX> | <APREFIX>) t2 = <QNAME_NS> s = Q_IRI_ref() (<DOT>) ?
  {
 	defNamespace(t2.image, s);
  }   
}




// *******************************************************************
 
// Update

void  UpdateQuery(Metadata la) : {  }
{

	{
  		astq.setResultForm(ASTQuery.QT_UPDATE);
  		astq.set(astu);
  		astu.defProlog();
  	}	

	UpdateQuery1()

        { astq.setAnnotation(la) ;}
	
	( Pragma() ) ?
	
	
}


void  UpdateQuery1() : {  }
{
	UpdateQuery2()
	
	( <SEMICOLON> ( 
		Prolog()
		{   		
		astu.defProlog(); }
		UpdateQuery1() ) ? 
	) ?
}




void UpdateQuery2() : { 
	Exp stack; Basic ope;
	Constant graph, uri, target; 
	boolean silent, defaut, named, all;
	}
{
    { astq.reset(); }
    
	{	
		stack = BasicGraphPattern.create();
		graph = null; uri = null; target = null;
		silent = false;
		defaut = false;
		all = false;
		ope = null;
	}
	
	(
		<LOAD> {ope = Basic.create(Update.LOAD);} 
		(<SILENT> 	{ope.setSilent(true);} ) ?  
		uri = IRIrefConst() {ope.setURI(uri);} 
		( <INTO> <GRAPH> graph = IRIrefConst() {ope.setTarget(graph);} ) ?
	|
		(<CLEAR>  	{ope = Basic.create(Update.CLEAR);} | <DROP> {ope = Basic.create(Update.DROP);})
		
		(<SILENT> 	{ope.setSilent(true);} ) ?  
			
		(<GRAPH> 	graph = IRIrefConst() {ope.setGraph(graph);} | 
		
		<DEFAUT> 	{ope.setDefault(true);} | 
		<NAMED> 	{ope.setNamed(true);} |
		<ALL> 		{ope.setAll(true);})

		
	|
		<CREATE> {ope = Basic.create(Update.CREATE);} (<SILENT> {ope.setSilent(true);} ) ?  
		<GRAPH> graph = IRIrefConst() {ope.setGraph(graph);}
	|
		(<ADD>  {ope = Basic.create(Update.ADD);}  | 
		 <MOVE> {ope = Basic.create(Update.MOVE);} | 
		 <COPY> {ope = Basic.create(Update.COPY);})
		
		(<SILENT> {ope.setSilent(true);} ) ?
		   
		((<GRAPH>) ? graph = IRIrefConst()  {ope.setGraph(graph);}    | <DEFAUT> 	{ope.setDefault(true);} )  
		<TO>
		((<GRAPH>) ? graph = IRIrefConst()  {ope.setTarget(graph);}   | <DEFAUT> 	{ope.setDefault(true);} ) 
	
	|	
		LOOKAHEAD(2)
		DeleteInsertData()	
	|	
		DeleteInsertWhere()
	)
	
	{
		if (ope!=null) astu.add(ope);
	}

}



void DeleteInsertData() : {Exp exp; Composite ope, upd;}
{
	
	(
		<INSERT> <DATA>  
		  
		{ astq.setInsertData(true); } 
		
		exp = QuadPattern() 
		
		{astq.setInsertData(false); 
		 ope = Composite.create(Update.INSERT, exp); }
	
	|
	
		<DELETE> 
		(
			<DATA>  {handler.enterDeleteData();}   
                            exp =   QuadPattern() 
                            {handler.leaveDeleteData();} 

			{ope = Composite.create(Update.DELETE, exp);}
			
			|
			<WHERE>  { handler.enterWhere(); }  exp = QuadPattern() { handler.leaveWhere(); }
			
			{
				upd = Composite.create(Update.COMPOSITE); upd.setBody(exp); 
				ope = Composite.create(Update.DELETE);    ope.setPattern(exp); 
				upd.add(ope);
				ope = upd;
			}
			
		)
	)
	
	{ astu.add(ope); }

}




// create an AST as a whole

void DeleteInsertWhere() : {Exp exp; Composite upd, ope; Constant uri; Values values;}
{
	{upd = Composite.create(Update.COMPOSITE);}
	
	( <WITH> uri = IRIrefConst() 
	
	{upd.setWith(uri);}
	
	) ?
	
	(
		<DELETE> 
                    { handler.enterDelete(); } 
                    exp = QuadPattern() 
                    { handler.leaveDelete(); }
		
		{ope = Composite.create(Update.DELETE); ope.setPattern(exp); upd.add(ope);}
		
		
		( <INSERT> exp = QuadPattern() 
		
		  {ope = Composite.create(Update.INSERT); ope.setPattern(exp); upd.add(ope);}
		
		) ?
		
		|
		
		<INSERT> exp = QuadPattern()
		
	    {ope = Composite.create(Update.INSERT); ope.setPattern(exp); upd.add(ope);}
		
	)
	
	// from & from named
	
	( <USING> (           uri = IRIrefConst()   { upd.addUsing(uri); } | 
	
	            <NAMED>   uri = IRIrefConst()   { upd.addNamed(uri); }
	          ) 
	) *
	
	<WHERE> { handler.enterWhere(); } exp = GroupGraphPattern() { handler.leaveWhere(); }

        (values = Values() {upd.setValues(values); } ) ?
	
	{ upd.setBody(exp); astu.add(upd); }

}




Exp QuadPattern() : {Exp stack;}
{
	
	<LBRACE>
	
		stack = BodyQuadPattern()
	
	<RBRACE>
	
	{
	    return stack; 
	}

}


Exp BodyQuadPattern() : {Exp stack;} 
{

		{stack = BasicGraphPattern.create();}

		( BlockOfTriples(stack) ) ?
			
		( GraphGraphPattern(stack)  ( BlockOfTriples(stack) ) ? ) *
		
		{return stack; }
}
		
		


// *********************** End Update ********************************************************



Exp TemplateQuery(Metadata la) : { Exp stack; }
{
  {stack = BasicGraphPattern.create();}
  Template(stack)
  ( DatasetClause() )*
  stack = WhereClause()
  SolutionModifier()  
  {
    astq.setTemplate(true);
    astq.setAnnotation(la);
    return stack; 
  }
}



void Template(Exp stack) : 
{ String str; Variable var; Constant cst; Expression exp, sep; ExpressionList list; 
   List<Variable> varList;}
{
    <TEMPLATE> { cst = null; astt = astq.defineTemplate(); }
        
    ( cst = IRIrefConst() { astq.setName(cst); }    ) ?
 
        

      (<LPAREN>  
 
         var = Var() { astq.defArg(var); }

         (<COMMA> var = Var() { astq.defArg(var); }) *
		   
       <RPAREN>
      ) ? 

      (<LBRACKET>   

         cst = IRIrefConst() { astq.defProfile(cst); }
        		   
       <RBRACKET>
      ) ? 

   
	<LBRACE>
	
		( 		  
                 exp = texp(stack)

                { astt.addTemplate(exp); }
		  
		   
		) *
		
		( <SEMICOLON>  <SEPARATOR>  <EQ>  
                      sep = PrimaryExpression(stack) { astt.setSeparator(sep); }
                ) ?
		
	
	<RBRACE>	
}

Expression texp (Exp stack) : { Expression exp; }
{
( 
                        exp =  XML(stack)  
                  |
                	exp = PrimaryExpression(stack)
                  |                       
                        exp = TemplateExpression(stack)
)
{ return exp; }
}

Expression TemplateExpression (Exp stack) : { Expression exp; }
{
    (   exp = box(stack)
    | 
        exp = group(stack)
    |
        exp = format(stack)
    )
{ return exp; }
}


Expression group(Exp stack) : 
{  Expression box, exp, sep; ExpressionList list; }
{
 <GROUP>           { list = new ExpressionList(); }
		  
	( <DISTINCT>     { list.setDistinct(true); } ) ?
		  		    
	<LBRACE>  
                  ( 
                    exp = texp(stack)
                    { list.add(exp); }
		  ) * 
		  			  
		  ( <SEMICOLON>  <SEPARATOR>  <EQ>  
                   sep = PrimaryExpression(stack) { list.setExpSeparator(sep); } 
                  ) ?  
		  			  
	<RBRACE>
    { 
        exp = astt.createGroup(list); 
        return exp;
    }
		  		  
		  
}

Expression format(Exp stack) : 
{  Expression box, exp, sep; ExpressionList list; Token t; }
{

      <FORMAT>     { list = new ExpressionList(); }

      <LBRACE>  
            (            
            exp = texp(stack)            
            { list.add(exp); }
            ) *
      <RBRACE>

      { 
        box = astt.createFormat(list); 
        return box;
      }
}

Expression box(Exp stack) : 
{  Expression box, exp, sep; ExpressionList list; Token t; }
{

      ( t = <BOX> | t = <IBOX> | t = <SBOX> )     { list = new ExpressionList(); }

      <LBRACE>  
            (            
            exp = texp(stack)            
            { list.add(exp); }
            ) *
      <RBRACE>

      { 
        box = astt.createBox(list, t.image ); 
        return box;
      }
}

Expression XML(Exp stack) : 
{  Expression box, exp, val, sep; ExpressionList list, attr; Token t; Constant uri = null, str;
    ArrayList<ExpressionList> lattr = null;
}
{

   <AT> uri = IRIrefConst()      

{ list = new ExpressionList(); }

    (        
        (<LPAREN> { lattr = new  ArrayList(); }
            (
                (<LPAREN> 
                    str = RDFLiteral() val = PrimaryExpression(stack)
                    { attr = new  ExpressionList(); attr.add(str); attr.add(val); 
                      lattr.add(attr);
                    }
                 <RPAREN>) + 
              |
                str = RDFLiteral() val = PrimaryExpression(stack)
                    { attr = new  ExpressionList(); attr.add(str); attr.add(val); 
                      lattr.add(attr);
                    }
            )      
        <RPAREN>)
    )?

      <LBRACE>  
            ( 
            exp = texp(stack)
            { list.add(exp); }
            ) *
      <RBRACE>

      { 
        box = astt.createXML(uri, lattr, list); 
        return box;
      }
}

// ********************** END PP Template ******************************


// ---- Query type clauses

Exp SelectQuery(Metadata la) : { Exp stack; }
{

    <SELECT>
    OneMoreListMerge()
    GroupCountSortDisplayVar()
    ( DatasetClause() )*
  stack = WhereClause()
  SolutionModifier()  
  {
    astq.setResultForm(ASTQuery.QT_SELECT);
    return stack; 
  }
}


Exp ConstructQuery(Metadata la) : { Exp stack1, stack2; boolean isRule = false;}
{
  (<RULE> {isRule = true;} )? 
  
  <CONSTRUCT> 
    
  (
  (
  // with a construct pattern
  stack1 = ConstructTemplate()
  // corese extension kept for compatibility
  (<SELECT> (SelectVar()) ?) ?    
  ( DatasetClause() )*
  stack2 = WhereClause()
  SolutionModifier()
  
  {	
  astq.setConstruct(stack1); 
  astq.setAnnotation(la);	
  astq.setRule(astq.isRule() || isRule);
  return stack2; }
  )
  
  |
  
  (
  // without a construct pattern
  ( DatasetClause() )*
  <WHERE> { handler.enterWhere(); } stack2 =  ConstructTemplate2() { handler.leaveWhere(); }
  SolutionModifier()
  
  {	astq.duplicateConstruct(stack2); 
        astq.setAnnotation(la);	
        return stack2; }
  )
  )
  
  
  
  
  
  
}

Exp DescribeQuery(Metadata la) : { Exp stack; Variable v; String s; Atom at;}
{  
  { stack = new And(); }	
  <DESCRIBE>
  ( 
  	( LOOKAHEAD(2) 
  		( 
  			  at = Var() { astq.setDescribe(at); }
  			| at = IRIrefConst() { astq.setDescribe(at); }
  		) 
  	)+
  	| <STAR> { astq.setDescribeAll(true); }
  )
  ( LOOKAHEAD(2) DatasetClause() )*
  ( LOOKAHEAD(2) stack = WhereClause() )?
  SolutionModifier()  
  { 
    astq.setResultForm(ASTQuery.QT_DESCRIBE);
    astq.setAnnotation(la);	
    return stack; 
  }
}

Exp AskQuery(Metadata la) : { Exp stack; Values values;}
{
  <ASK>
  ( DatasetClause() )*
  stack = WhereClause()
  (values = Values()  {astq.setValues(values); } ) ?
  
  {
  	astq.setResultForm(ASTQuery.QT_ASK);
        astq.setAnnotation(la);	
  	return stack;
  }
}

Exp DeleteQuery() : { Exp stack; }
{ 
	<DELETE>
	<STAR>
	stack = WhereClause()
	{ 
		astq.setDelete(true);
		astq.setResultForm(ASTQuery.QT_DELETE);
		return stack; 
	}
}

// ----

// one more list merge in any order and without list and merge being together

void OneMoreListMerge(): {}
{
  (More()) ? 
}




void More(): {}
{
  <S_MORE>
  { astq.setMore(true); }
}


void GroupCountSortDisplayVar(): {}
{
  ( 
  	(<DISTINCT> { astq.setDistinct(true);  } | <REDUCED> { astq.setReduced(true);  } ) 
  	( <SORTED> { astq.setStrictDistinct(false); } )?
  )? 
  ( 
  	SelectVar() 
  )?
}

// ***************** BEGIN SPARQL1.1

void SelectVar(): { Variable e1; Expression e2; Exp stack; } 
{

	{ stack = BasicGraphPattern.create(); }
	(
		( 
			( 
			LOOKAHEAD(2) 
			e1 = Var() { astq.defSelect(e1, null); } 
				| SelectExp(stack) ) 
		)+
  		| 
  		( 
  			<STAR> { astq.setSelectAll(true); } 
			( 
			SelectExp(stack) )*
 	  	)
	)
}


void SelectExp(Exp stack):{}
{	
	 <LPAREN> FunVar(stack) <RPAREN> 
}


void FunVar(Exp stack): { Expression e2; Variable e1; Variable var;} {
	
		 e2 = Expression(stack)
	
		
                <AS> ( 
			         var = Var() { astq.defSelect(var, e2); } 
			|
			
			// select sql("select a b from table") as (?x, ?y) where
			
			{ var = astq.metaVariable();  }
			       
			<LPAREN> 
			      e1 = Var()  
			      { var.addVariable(e1); } 
			              
				( <COMMA> e1 = Var()  
				  { var.addVariable(e1);   } 
			 	) *
				
			<RPAREN>
			
			{ astq.defSelect(var, e2);}       
		 )
}

// ********************* END SPARQL 1.1



void DatasetClause() : { Constant s; }
{
  <FROM>
  ( 
            s = IRIrefConst()  { astq.setFrom(s); }
  | <NAMED> s = IRIrefConst()  { astq.setNamed(s); } 
  )
}

Exp WhereClause() : { Exp stack; }
{
   (<WHERE> { astq.setWhere(true); } )? 
   { handler.enterWhere(); } stack = GroupGraphPattern() { handler.leaveWhere(); }
   { return stack; }
}

void SolutionModifier() : {Values values;}
{
   (Relax()) ?  
   (OrderGroup()) ? ( LimitOffset()) ? 
   (values = Values() {astq.setValues(values); } ) ?
   (Pragma()) *
}


Values Values() : {
    Variable var; Constant val; ArrayList<Variable> list = null; ArrayList<Constant>  value; Values values = null;
    Expression exp;  Exp stack;
}
{
	{list = new ArrayList<Variable>();
	 values = Values.create();
         stack = BasicGraphPattern.create();
        }

 <VALUES>  { handler.setInsideValues(true); }
 
	( 
	(	
		<LPAREN> 
			(var = Var() {list.add(var); }) *
			{ values.setVariables(list); }
		<RPAREN>
			
		<LBRACE> 
                (   // unnest(exp)
                    exp = BuiltInCall(stack) { values.addExp(exp); }
                    |
                    (
			<LPAREN> 
				{ value = new ArrayList<Constant>();}
                                
                                ( val = Value() { value.add(val); } ) *                                                                    

				{ values.addValues(value); }
			<RPAREN>
                    )*
                )
		<RBRACE>
	)

	|
	
	(
		var = Var() 
                { list.add(var); values.setVariables(list); }
		
		<LBRACE> 
                (
                     exp = BuiltInCall(stack) { values.addExp(exp); }
                    |
                    (
			{ value   = new ArrayList<Constant>(); }
			
                        val = Value() { value.add(val); } 
                                                    
			{ values.addValues(value); }
                    ) *                   
                )
		<RBRACE>
	)
	)
	
	{ handler.setInsideValues(false); return astq.complete(values); }

	
}


Constant Value() : { Constant cst = null; String s; Token t1; Exp exp; Atom triple;}
{
  	( 
  	  s = Q_IRI_ref() { cst = astq.createURI(s); }
  	| t1 = <QNAME>    { cst = astq.createQName(t1.image);  }
  	| t1 = <QNAME_NS> { cst = astq.createQName(t1.image);  }
  	| t1 = <UNDEF>    { cst = null; }  
  	| cst = RDFLiteral() 
  	| cst = NumericLiteral()
  	| cst = BooleanLiteral() 
        | { exp = BasicGraphPattern.create(); }
          triple = StarTriple(exp)
          { cst = triple.getConstant(); }
  	) 
  	
  { return cst; }
}




void Pragma() : {Exp exp; String uri;}
{
	{uri = null;}
	<PRAGMA> (uri = IRIref()) ?  exp = GroupGraphPattern() 
	{
	astq.setPragma(uri, exp);
	}
	  
}


void Relax() : {Token t1; }
{
	<RELAX> <BY> t1 = <QNAME> 
	{astq.setDistance(t1.image);
	 } 
}


void LimitOffset() : {}
{
	ProjLimitClause()  ( OffsetClause() )? |
	OffsetClause() ( ProjLimitClause() )?

}

void OrderGroup() : {}
{
	GroupClause() (OrderClause())? (Having())? |
	OrderClause() (GroupClause())? (Having())? |
	Having()
}

void GroupClause(): { Variable var; Expression exp; Exp stack;}
{
 	{ 
  		stack = new And();
  		var = null;
  	}
  	
  	 <GROUP> <BY>
  (
  
  ( LOOKAHEAD(2)
  	(   	
  	  <LPAREN> exp = Expression(stack) (<AS> var = Var() ) ? <RPAREN> |
  	  exp = Var() |
  	  exp = BuiltInCall(stack) |
  	  exp = FunctionCall(stack) |
  	  exp = FunctionCorese(stack)
  	)
  	{ astq.setGroup(exp, var); }
  ) + 
  	
  )
}




void Having() : {Exp stack; }
{
	{stack = new And();}
	
  	<HAVING> Filter(stack)
  	
  	{astq.setHaving(stack);}
  
}

void OrderClause() : {}
{
  <ORDER> <BY> 
  ( LOOKAHEAD(2) OrderCondition() )+
}

void OrderCondition() : { boolean reverse; Token t; String sortby; Variable v; Expression a; Term tm; Exp stack; }
{
  	{ 
  		reverse = false; 
  		stack = new And();
  	}
	( 
		v = Var() { astq.setSort(v, reverse); }
	    | a = BuiltInCall(stack) { astq.setSort(a, reverse); }
	    | tm = FunctionCall(stack) { astq.setSort(tm, reverse); }
	    | LOOKAHEAD(2) tm = FunctionCorese(stack) { astq.setSort(tm, reverse); }
		|
    	( 
    		( <ASC> | <DESC> { reverse = true; } )? 
    		( 
    			a = BrackettedExpression(stack) { astq.setSort(a, reverse); }
    		)
    	)    		
  	)  	
}

void ProjLimitClause() : { Token t; }
{
	LimitClause()
}

void LimitClause() : { Token t; }
{
  <LIMIT> 
  t = <INTEGER>
  { astq.setMaxResult(Integer.parseInt(t.image)); }
}

void OffsetClause() : { Token t; }
{
  <OFFSET> 
  t = <INTEGER>
  { astq.setOffset(Integer.parseInt(t.image)); }
}



// **** General Graph Pattern ********************************************



Exp GroupGraphPattern() : {Exp stack; Metadata meta = null;}
{
  { stack = BasicGraphPattern.create(); }
  <LBRACE>  
    (    
  	  SubQuery(meta, stack) |
  	  GraphPattern(stack) 
  	)
  <RBRACE>
  { return stack; }
}
 

void GraphPattern (Exp stack) : {}
{
(
	(
        TriplesSameSubject(stack) 
	|
	Constraint(stack) 
	|
	GraphPatternNotTriples(stack)
	)
	(<DOT>)?
)*
}


void FilteredBasicGraphPattern(Exp stack) : {} 
{
		
	( BlockOfTriples(stack) )? 
	( 
		Constraint(stack) 
    	( <DOT> )? 
		FilteredBasicGraphPattern(stack) 		
	)?
}

void BlockOfTriples(Exp stack) : {boolean b1, b2;}
{   
		(
		TriplesSameSubject(stack) 
				
		( <DOT> ) ?
		)+
		
}




void GraphPatternNotTriples(Exp stack) : {ASTQuery ast; Values values;}
{
      OptionalGraphPattern(stack)
    | MinusGraphPattern(stack)
 	| LOOKAHEAD (2) GroupOrUnionGraphPattern(stack) 
 	| GraphGraphPattern(stack)
 	| ServicePattern(stack)
 	| ScopeGraphPattern(stack)
 	| ExistGraphPattern(stack)
 	| Bind(stack) 
 	| values = Values() { stack.add(values); }
}

void SubQuery(Metadata meta, Exp stack) : {ASTQuery ast; Query q; Exp exp;}
{
 { ast = astq; astq = gast.subCreate(); } 
 exp = SelectQuery(meta) 
 { astq.setBody(exp); q = Query.create(astq); stack.add(q); astq = ast; } 
}

Exp SubQueryExp(Metadata meta) : { Exp exp; }{
    { exp = BasicGraphPattern.create(); } SubQuery(meta, exp)
    { return exp; }
}

Exp ServiceExp() : {Exp exp, res; ASTQuery tmp; Query q;} {
    { exp = BasicGraphPattern.create(); }
    ServicePattern(exp)
    { tmp = gast.subCreate();
      tmp.setBody(exp);
      tmp.setSelectAll(true);
      q = Query.create(tmp);
      res = BasicGraphPattern.create();
      res.add(q);
      return res;
    }
}

Exp SubConstruct(Metadata meta) : {ASTQuery ast; Query q; Exp exp;}
{
 { ast = astq; astq = gast.subCreate(); } 
 exp  = ConstructQuery(meta) 
 { astq.setBody(exp); q = Query.create(astq); astq = ast; return q;} 
}

Exp SubUpdate(Metadata meta) : {ASTQuery ast; ASTUpdate up, save; Query q; Exp exp; }
{
 { ast = astq; save = astu; astu = astu.subCreate(); astq = gast.subCreate(); astq.set(astu); 
   astq.shareForUpdate(gast);
   astq.setBody(BasicGraphPattern.create()); } 
  UpdateQuery(meta) 
 { q = Query.create(astq); astq = ast; astu = save; return q;} 
}


void Bind(Exp stack) : { Expression exp; Exp q; Variable var, vv;}
{
	<BIND> <LPAREN> 
                exp = Expression(stack) 
			
                <AS> ( 
			var = Var() 

			|
			
			// bind( sql("select a b from table") as (?x, ?y))
			
			{ var = astq.metaVariable();  }
			       
			<LPAREN> 
			      vv = Var()  
			      { var.addVariable(vv); } 
			              
				( <COMMA> vv = Var()  
				  { var.addVariable(vv);   } 
			 	) *
				
			<RPAREN>						     
		 )
        <RPAREN> 
	
	{
		q = astq.createBind(exp, var); stack.add(q);
	}
}


// ---- Definitions of each pattern element

void OptionalGraphPattern(Exp stack) : { Exp e; }
{ 
	<OPTIONAL> 
  	e = GroupGraphPattern()
  	{ 
  		e= Optional.create(e);
  		stack.add(e); 		
  	}
}

void MinusGraphPattern(Exp stack) : { Exp e; }
{ 
	<MINUSP>  e = GroupGraphPattern()
  	{ 
  		e = Minus.create(e);
  		stack.add(e); 		
  	}
}


void ExistGraphPattern(Exp stack) : { Exp e; }
{ 
	 <EXIST> 
  	e = GroupGraphPattern()
  	{ 
  		e= Exist.create(e);
  		stack.add(e); 		
  	}
}

void ScopeGraphPattern(Exp stack) : { Exp e; }
{ 
	 <SCOPE> 
  	e = GroupGraphPattern()
  	{ 
  		e= Scope.create(e);
  		stack.add(e); 		
  	}
}



void GraphGraphPattern(Exp stack) : 
	{ }
{	
	<GRAPH>	 BasicGraphGraphPattern(stack)
        
}

void BasicGraphGraphPattern(Exp stack) : 
	{ Atom src; Exp e; Source st; 
	  boolean state = false, leaf = false, rec = false;}
{	
  	//src = VarOrIRIref(stack) 
        src = VarOrBlankNodeOrIRIref(stack)
  	{ handler.graphPattern(src); }
  	e = GroupGraphPattern()
  	{ 
  		st =  Source.create(src, e);
  		if (state) { 
  			st.setState(true); 
  			if (leaf) st.setLeaf(true);
  		}
  		if (rec){
  			st.setRec(true);
  		}
  		stack.add(st);
  	}
  	{ handler.endGraphPattern(src); }
}

void ServicePattern(Exp stack) : 
	{ Atom src; Exp e; Service st; boolean silent; ArrayList<Atom> list; }
{
	{silent = false; list = new ArrayList<Atom>() ;}
	 <SERVICE>  (<SILENT> { silent = true;} )?
	 
  	(src = VarOrIRIref(stack) 
        { handler.enterService(astq, src); list.add(src); })+

  	e = GroupGraphPattern()
  	{ 
  		st =  Service.create(list, e, silent);
  		stack.add(st);
                handler.leaveService(astq);
  	}
}


// G (union G)* can be a single group pattern
// or a group pattern as part of an union.
void GroupOrUnionGraphPattern(Exp stack) : { Exp temp, res; }
{
	res = GroupGraphPattern()
  	( 
  	  	<UNION> 
  	  	{ 
  	  		temp = res;
      		res =  Union.create();
      		res.add(temp);
  	  	}
    	temp = GroupGraphPattern()  
    	{ res.add(temp); }  
  	)*  
	{ stack.add(res); }
}

void Constraint(Exp stack) : { }
{
  <FILTER> Filter(stack)
  
}


void Filter(Exp stack) : { Expression expression1; Exp filter; }
{
  expression1 = FilterExp(stack)
  { 
  		if (expression1 != null ) {
	    	filter = astq.checkCreateFilter(expression1);
	    	stack.add(filter);    	
	    }
  }
}

Expression FilterExp(Exp stack) : {Expression exp;}
{
  (   exp = BrackettedExpression(stack) 
    | exp = BuiltInCall(stack) 
    | exp = FunctionCorese(stack)
    | exp = FunctionCall(stack) 
  )
  {return exp;}
}



// -------- Construct patterns

Exp ConstructTemplate() : { Exp stack; }
{
  <LBRACE>
  	{ stack = BasicGraphPattern.create(); }
	ConstructTriples(stack)
  <RBRACE>
  { return stack; }
}

void ConstructTriples(Exp stack) : {}
{
  (
  	(TriplesSameSubject(stack) | GraphGraphPattern(stack))
  	(<DOT>)? 
  	ConstructTriples(stack)   	
  )?
}


Exp ConstructTemplate2() : { Exp stack; }
{
  <LBRACE>
  	{ stack = BasicGraphPattern.create(); }
	ConstructTriples2(stack)
  <RBRACE>
  { return stack; }
}

void ConstructTriples2(Exp stack) : {}
{
  (
  	TriplesSameSubject(stack) 
  	(<DOT>)? 
  	ConstructTriples2(stack)   	
  )?
}








// -------- Triple lists with property and object lists
void TriplesSameSubject(Exp stack) : { Expression expression1; }
{
  ( LOOKAHEAD(2)
  	expression1 = VarOrTerm(stack)
	stack       = PropertyListNotEmpty(expression1, stack)
  |
  	expression1 = TriplesNode(stack)
  	stack       = PropertyList(expression1, stack)
  | stack = RDFstar(stack)	
  | stack = tuple(stack)
  )
}

// << s p o >> q v .
Exp RDFstar(Exp stack) : {  Atom ref; }
{
    ref = StarTriple(stack)
    stack  = PropertyListNotEmpty(ref, stack)
    { return stack; }
}

// return Constant with:
// dt=bnode triple reference isTriple() == true
// when sparql: triple = triple(s p o)
// when load:   triple = null, edge created in graph directly
Atom StarTriple(Exp stack) : 
{ Atom sub, obj, ref, pred;  Triple t;}
{
    <LTLT> 
        sub = StarTerm(stack) pred = Verb() obj = StarTerm(stack) 
        { ref = handler.createNestedTripleStar(astq, stack, sub, pred, obj, null);
        }
    <GTGT>
    { return ref; }
}



Atom StarTerm(Exp stack) : { Atom term; }
{
    (
        //term = GraphNode(stack)
        term = VarOrTerm(stack)
      | term = StarTriple(stack)
    )
    { return term; }
}

// tuple(p s o v) triple(s p o v)
Exp tuple(Exp stack): 
{ Atom subject, object, term; Variable var; ArrayList<Atom> list; Atom prop; Triple triple;
  boolean arity = false, isTriple = true;
} {
	( <TUPLE> { isTriple = false; } | <TRIPLE> ) <LPAREN> 
	
	prop = Verb()
	subject = GraphNode(stack)
	object  = GraphNode(stack)
        { if (isTriple) { term = prop; prop = subject; subject = term; } } // triple(subject property objet)
	{ list = new ArrayList<Atom>(); list.add(subject); list.add(object); }
	
	(  term = GraphNode(stack)  { list.add(term); } )*

        ( <BAR> var = Var() { var.setMatchNodeList(true) ; list.add(var); } (<BAR> { var.setMatchCardinality(true) ;} ) ?) ?

        ( <DOT> { arity = true; }) ?
	  
	<RPAREN>
	{ 
	    triple = handler.createTriple(astq, prop, list, arity); 
	    if (triple != null) { stack.add(triple); }	
	    return stack; 
	}
}

  
Exp PropertyList(Expression expression1, Exp stack) : {}
{  
  ( LOOKAHEAD(2) stack = PropertyListNotEmpty(expression1, stack) ) ?
  { return stack; }
}

Exp PropertyListNotEmpty(Expression e1, Exp stack) : 
{ ExpressionList list; Atom p;  Triple triple; int n;}
{ 
  stack = PropertyListNotEmptyElem(e1, stack)

  ( LOOKAHEAD(2) <SEMICOLON> 

   stack = PropertyListNotEmptyElem(e1, stack)

  ) *

  ( LOOKAHEAD(2) <SEMICOLON> ) ?

  { return stack; }
}

Exp PropertyListNotEmptyElem( Expression e1, Exp stack) : 
{ ExpressionList list; Atom p;  Triple triple; int n;}
{
    p = Verb() 
  { n = stack.size(); }  
  // ObjectList() may fill the stack beyond n in case of [prop ?val] 
  // hence we store the index n to add the triple at n	
  list = ObjectList(stack)
  { stack = handler.createTriples(astq, stack, e1, p, list, n);  
    return stack ; }
}



ExpressionList ObjectList(Exp stack): { Expression expression1; ExpressionList v; }
{
  { v = new ExpressionList(); }
  
  expression1 = PropertyValue(stack)
  { v.add(expression1); }
  
  ( 
  	 <COMMA> 
     expression1 = PropertyValue(stack)
     { v.add(expression1); }
  ) *
  
  { return v; }
}


Atom PropertyValue(Exp stack) : 
{ Atom value; Atom tripleRef = null; Exp newStack;}
{
    (
        value = GraphNode(stack)
      | value = StarTriple(stack)
    )

    (LOOKAHEAD(2) 
        { newStack = new And().setStack(true); }
        //tripleRef = AssertedAnnotation(stack)
        tripleRef = AssertedAnnotation(newStack)
        { value.setTripleReference(tripleRef); 
          // value = o in s p o with o.reference = t and o.annotation = (t q v)
          value.setAnnotation(newStack);
        }
    ) ?

    { return value; }
}


// s p o  {| q v |}
// parse {| q v |} with t as subject
// create t q v triples in a fresh stack
Atom AssertedAnnotation(Exp stack) : { Exp exp; Atom tripleRef = null; }
{    
    
    <LBRACE> <BAR> 
        // s p o {| q v |} -> s p o t . t q v
        // create subject t of annotation triple t q v
        { tripleRef = handler.createTripleReference(astq); }
        // annotation triples inserted in stack
          stack = PropertyListNotEmpty(tripleRef, stack) 
    <BAR> <RBRACE> 

    { return tripleRef; }
}




Atom Verb() : { Atom atom; }
{
  ( 
    atom = PropertyVarOrIRIref() 
    | <KW_A> { atom = astq.createQName(RDFS.qrdftype); }
  )
  { return atom; }
}


Atom PropertyVarOrIRIref(): { Atom atom; Token t1; Variable var; Constant cst; String temp; }
{
  
  ( 
      atom = StdProperty()
      
    | atom = Var()
    
 
  )
  
  
  { return atom; }
}




Atom StdProperty(): {Variable var; Constant cst;  Expression exp;}
{
  	
  	  exp = RegExp()
      
      { cst = astq.createProperty(exp);
      } 
      
      ( 
      	<COLON2> 
      	var = Var() 
      	{ 
      		cst.setVar(var); 
      	} 
      )? 
      
      { return cst; }
      
}


Expression RegExp():{Token t; String s; Expression exp;}
{

(
	   t = <XPATH>   <LPAREN> s = String() <RPAREN>
	   
	  { exp = astq.createFunction(t.image, astq.createConstant(s, null, null)); }  |

	  exp = AddRegExp()   
)
	
	{return exp;}
}



Expression AddRegExp():{Token t; Expression exp1, exp2;}
{
    exp1 = MultRegExp() 
    
    (
    	(
    		 t = <BAR>   exp2 = MultRegExp() 
   		    {exp1 = astq.createAltExpression(exp1, exp2); } 
   			 
   		)
   		|
   		(
   		    t = <SC_OR>   exp2 = MultRegExp() 
   		    {exp1 = astq.createParaExpression(exp1, exp2); } 
   		)
    
    ) *
    
    { return exp1;}

}


Expression MultRegExp():{Token t; Expression exp1, exp2;}
{

	exp1 = UnaryRegExp() 
	
	
	
	( t = <SLASH>  exp2 = UnaryRegExp() 
	
	  {exp1 = astq.createSeqExpression(exp1, exp2); } 
		
	) *

	{ return exp1;}

}


Expression UnaryRegExp():{Token t, t1, t2; Expression exp; Token ope; String s1, s2;}
{
(
	t = <BANG>   
	
	exp = PrimaryRegExp()   { exp = astq.createOperator(t.image, exp); }
	
	
|   t = <BEGIN_WITH>	

	exp = PrimaryRegExp()   { exp = astq.createOperator(t.image, exp);  }
	
	
|	exp = PrimaryRegExp()  

    (  ope = OpeRegExp()     { exp = astq.createOperator(ope.image, exp); }   
    
    |
        
    
		<LBRACE>  
		  { s1 = null; s2 = null; }
		(
		  t1 = <INTEGER>  {s1 = t1.image; s2 = s1; }  (<COMMA> {s2 = null;} (  t2 = <INTEGER>  {s2 = t2.image;} )? )? 
		  
		  |
		  
   		  <COMMA>    t2 = <INTEGER>  {s2 = t2.image;}
   		)
   		<RBRACE> 
   		
   		{ exp = astq.createOperator(s1, s2, exp); }
    
    )  ? 
)

{ return exp;}

}





Token OpeRegExp() : {Token ope;}
{

(	ope = <STAR>
|	ope = <PLUS>
|	ope = <QM>
)

{ return ope; }

}


Expression PrimaryRegExp():{Token w; Expression exp, test, subject; Exp stack; String t; Constant cst;}
{
	( 
		exp = IRIrefConst() 
		
		|	
	
		<LPAREN> exp = AddRegExp() <RPAREN>
	) 
	
	
	( 	LOOKAHEAD(2)
		<AT> 
		
		(
		
		w = <INTEGER> { exp.setWeight(w.image); }
		
		|
		
		// [ a foaf:Person ]
		
		  { stack = BasicGraphPattern.create(); subject = astq.createVariable(THIS);}
		  		  
		   <LBRACKET>
  			stack = PropertyListNotEmpty(subject, stack)    
  		   <RBRACKET>
		   
		  //test = Expression(stack) 
		  
		  {exp = astq.createRegexTest(exp, stack);} 
		
		|
		
		// { ?this a foaf:Person }
		  stack = GroupGraphPattern()
		  
		 {exp = astq.createRegexTest(exp, stack);} 

		  
		)	
	) ?   
	
	
	{ return exp; }

}



Token Soper(): { Token t; }
{
  ( 
    t = <EQ> | t = <NE> 
  | t = <LT> | t = <GT>
  | t = <LE> | t = <GE>
  | t = <EQ2> | t = <NE2> 
  | t = <TILDE> 
  | t = <BEGIN_WITH>
  )
  { return t; }
}

Token Toper(): { Token t; }
{
  ( 
    //t = <STRICT_SPEC> | 
    t = <SPEC> | t = <SAME>
  | t = <GENERALISATION> | t = <STRICT_GENERALISATION> )
  { return t; }  
}

// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples

Atom TriplesNode(Exp stack) : { Atom expression1; }
{
  ( 
  	  expression1 = Collection(stack) 
  	| expression1 = BlankNodePropertyList(stack) 
  )
  { return expression1; }
}

Atom BlankNodePropertyList(Exp stack) : { Atom expression1; }
{
  { 
  	// [ :p ?y ]
  	expression1 = astq.newBlankNode();
  }
  <LBRACKET>
  stack = PropertyListNotEmpty(expression1, stack)    
  <RBRACKET>
  { return expression1; }
}

// ------- RDF collections
/**
* see: http://www.w3.org/TR/rdf-sparql-query/#collections
*
* exemple 1: The collection ( 1 ?x 2 3 ) generates 8 triples:
* _:b0 rdf:first 1		_:b0 rdf:rest _:b1
* _:b1 rdf:first ?x		_:b1 rdf:rest _:b2
* _:b2 rdf:first 2		_:b2 rdf:rest _:b3
* _:b3 rdf:first 3		_:b3 rdf:rest rdf:nil
*
* exemple 2: The collection ( ?x [ :p 'v' ] ( 3 ) ) generates 9 triples:
* _:b0 rdf:first x		_:b0 rdf:rest _:b1
* _:b1 rdf:first _:b2	_:b1 rdf:rest _:b3		_:b2 :p 'v'
* _:b3 rdf:first _:b4	_:b3 rdf:rest rdf:nil	_:b4 rdf:first 3	_:b4 rdf:rest rdf:nil
*
*/
Atom Collection(Exp stack) : 
{ 
  ArrayList<Atom> list;
  Atom node, head;
  Exp exp;
  RDFList rlist;
  int arobase = ASTQuery.L_DEFAULT, save = ASTQuery.L_LIST;
}
{
	{
		list = new ArrayList<Atom>();
                save = astq.getListType();
	}
	
	//  @( ) means rewrite as rdf:rest*/rdf:first
	
	( 
                ( 
		 <ATLIST>    { arobase = ASTQuery.L_LIST; astq.setListType(arobase); }  
                )
                |
                (
		  (<AT> | <ATPATH>) { arobase = ASTQuery.L_PATH; astq.setListType(arobase); } 
                ) 
                
	) ?
	
  	<LPAREN>
  	(
  		(node = GraphNode(stack) | 
                 node = StarTriple(stack))
  		{
  			list.add(node);
  		}   
  	) +
  	<RPAREN>
  	{ 
  	    head = handler.list(astq, stack, list, arobase);
            astq.setListType(save);
  	    return head; 
  	}
}






// -------- Nodes in a graph pattern or template

Atom GraphNode(Exp stack) : { Atom expression1; }
{
  (   LOOKAHEAD(2)
  	  expression1 = VarOrTerm(stack) 
        // below: s p [q r] or s p (a b)
  	| expression1 = TriplesNode(stack)   	
  )
  { return expression1; }
}

Atom VarOrTerm(Exp stack) : { Atom expression1; }
{
  ( expression1 = Var() | expression1 = GraphTerm(stack) )
  { return expression1; }
}

Atom VarOrBlankNodeOrIRIref(Exp stack) : { Atom a; String s; }
{
  ( 
    a = Var() { s = a.getName(); } 
    | a = BlankNode(stack) { s = a.getName(); } 
    | a = IRIrefConst() 
  )
  { return a; }
}

Atom VarOrIRIref(Exp stack) : { Atom a; String s; }
{
  ( 
      a = Var() 
    | a = IRIrefConst() 
  )
  { return a; }
}


Variable Var() : { Token t1; Variable res; String s;} 
{
  (   t1 = <VAR1> { s = t1.image; }  
    | t1 = <VAR2> { s = "?"+(t1.image).substring(1,(t1.image).length()); }  
    | t1 = <VAR3> { s = "?"+(t1.image); handler.checkVariable(t1); } 
  ) 
  { res = ASTQuery.createVariable(s, astq); } 
  
  { return res; }
}

Atom GraphTerm(Exp stack) : { Constant cst; String s; Token t1; Variable var; Atom a; }
{
  (
  	( 
  	s = Q_IRI_ref() { cst = astq.createURI(s); }
  	| t1 = <QNAME> 
  		{ cst = astq.createQName(t1.image);  }
    	( 
 	   	<COLON2> 
 	   	var = Var() 
 		{ cst.setVar(var); } 
 	    )?
  	| t1 = <QNAME_NS> { cst = astq.createQName(t1.image); }
  	| cst = RDFLiteral() 
  	| cst = NumericLiteral()
  	| cst = BooleanLiteral()   
  	| <LPAREN>  <RPAREN> 
  	{ cst = astq.createQName(RDFS.qrdfNil); }  
  	) { a = cst; }
  	| a = BlankNode(stack) 
  )
  { return a; }
}

// -------- Constraint syntax

Expression Expression(Exp stack) : { Expression expression1; }
{	
  expression1 = ConditionalOrExpression(stack)
  { return expression1; }
}

Expression ConditionalOrExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = ConditionalAndExpression(stack)
  ( 
    t1 = <SC_OR> 
    expression2 = ConditionalAndExpression(stack) 
    { expression1 = astq.createConditionalOrExpression(t1.image, expression1, expression2); }
  )* 
  { return expression1; }  
}

Expression ConditionalAndExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = ValueLogical(stack)
  ( 
    t1 = <SC_AND> 
    expression2 = ValueLogical(stack) 
    { expression1 = astq.createConditionalAndExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression ValueLogical(Exp stack) : { Expression expression1; }
{
  expression1 = RelationalExpression(stack)
  { return expression1; }
}

Expression RelationalExpression(Exp stack) : { Token t1; Expression expression1, expression2; ExpressionList el; boolean not = false;}
{
  expression1 = NumericExpression(stack)
  ( 
    (   
        t1 = Soper() expression2 = NumericExpression(stack)
      |  (<NOT> {not = true;} )? 
        t1 = <IN>    el = ArgList(stack) {expression2 = astq.createList(el);}
    ) 
    
    { expression1 = astq.createRelationalExpression(t1.image, expression1, expression2); 
    if (not){
    	expression1 = astq.negation(expression1);
    	}
    }
  )?
  { return expression1; }
}




Expression NumericExpression (Exp stack) : { Expression expression1; }
{
  expression1 = AdditiveExpression(stack)
  { return expression1; }
}

Expression AdditiveExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = MultiplicativeExpression(stack)
  ( 
  	  t1 = <PLUS> expression2 = MultiplicativeExpression(stack) 
  	  { expression1 = astq.createAdditiveExpression(t1.image, expression1, expression2); }
    | t1 = <MINUS> expression2 = MultiplicativeExpression(stack) 
      { expression1 = astq.createAdditiveExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression MultiplicativeExpression(Exp stack) : { Token t1; Expression expression1, expression2; }
{
  expression1 = UnaryExpression(stack)
  ( 
    ( 
    	t1 = <STAR> expression2 = UnaryExpression(stack) 
      | t1 = <SLASH> expression2 = UnaryExpression(stack) 
    ) 
    { expression1 = astq.createMultiplicativeExpression(t1.image, expression1, expression2); }
  )*
  { return expression1; }
}

Expression UnaryExpression(Exp stack) : { Token t1; Expression expression1; }
{
  (   t1 = <BANG> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | t1 = <PLUS> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | t1 = <MINUS> expression1 = PrimaryExpression(stack) 
      { expression1 = astq.createUnaryExpression(t1.image, expression1); }
    | expression1 = PrimaryExpression(stack) 
  )
  { return expression1; }
}

Expression BuiltInCall(Exp stack) : { ExpressionList el; Expression exp1 = null, exp2; Variable var1; Token t1; Term term; }
{
  (

    (t1 = <BOUND> <LPAREN> var1 = Var() <RPAREN> 
     { term = astq.createFunction(t1.image, var1); } )

    | 
 
    (
    (
    t1  = <BNODE> | t1 = <ERROR>
    )

    <LPAREN> 
        ( exp1 = Expression(stack) ) ? 
        { term = astq.createFunction(t1.image); 
          if (exp1 != null) { term.add(exp1); }
        } 
    <RPAREN>
    )

    |

    ((
    t1  = <UUID> | t1 = <STRUUID> | t1 = <NOW> | t1 = <RAND> | t1 = <STOP>
    )

    <LPAREN><RPAREN>
    { term = astq.createFunction(t1.image); } 
    )

    |

    ( ( 
          t1 = <STR> | t1 = <URI> | t1 = <IRI>
        | t1 = <DTYPE> | t1 = <LANG> 
        | t1 = <IS_IRI> | t1 = <IS_URI>  
        | t1 = <IS_BLANK> | t1 = <IS_LITERAL> 
        | t1 = <IS_NUMERIC> 
        | t1 = <IS_EXTENSION> 
        | t1 = <IS_SAFE>
        | t1 = <IS_UNDEFINED>
        | t1 = <IS_WELLFORMED>
        | t1 = <STRLEN> | t1 = <UCASE> | t1 = <LCASE> | t1 = <ENCODE_FOR_URI>
        | t1 = <MD5> | t1 = <SHA1> | t1 = <SHA256> | t1 = <SHA384> | t1 = <SHA512>
        | t1 =  <ROUND> | t1 = <FLOOR> | t1 = <CEIL>  | t1 = <ABS> 
        | t1 =  <YEAR> | t1 = <MONTH> | t1 = <DAY> | t1 = <HOURS> | t1 = <MINUTES> | t1 = <SECONDS> | t1 = <TIMEZONE> | t1 = <TZ>
        | t1 = <RETURN> | t1 = <SELF> | t1 = <EVAL> 
        | t1 = <SUBJECT> | t1 = <OBJECT> | t1 = <PREDICATE> | t1 = <IS_TRIPLE>
   )
 

      <LPAREN> exp1 = Expression(stack) <RPAREN> 
      { term = astq.createFunction(t1.image, exp1); } 
    )

    |
 
    (
    (t1 = <AGGREGATE> | t1 = <GROUP_CONCAT> | t1 = <COUNT> | t1 = <SUM> | t1 = <SAMPLE> | t1 = <AVG> | t1 = <MIN> | t1 = <MAX>)
     el = ArgList(stack)  
    { term = astq.createFunction( t1.image, el); }
    )

    |

    (
    (t1 = <LANGMATCHES> | t1 = <POWER> | t1 = <XPATH>
    | t1 = <SAMETERM> | t1 = <STRDT> | t1 = <STRLANG> | t1 = <CONTAINS> 
    | t1 = <STRSTARTS> | t1 = <STRENDS> | t1 = <STRBEFORE>  | t1 = <STRAFTER>
    | t1 = <REDUCE> | t1 = <APPLY> | t1 = <SPARQL_COMPARE>
    )
     <LPAREN> exp1 = Expression(stack) <COMMA> exp2 = Expression(stack) <RPAREN>

      { term =  astq.createFunction(t1.image, exp1); term.add(exp2); }
    )


    |

    (
    ( t1 = <UNNEST> | t1 = <REGEX> | t1 = <COALESCE> | t1 = <CONCAT> | t1 = <SUBSTR> | t1 = <REPLACE>
    | t1 = <METHOD> | t1 = <FUNCALL> | t1 = <MAP> | t1 = <MAPLIST> | t1 = <MAPMERGE>  
    | t1 = <MAPFINDLIST> | t1 = <MAPFIND> | t1 = <MAPANY> | t1 = <MAPEVERY> | t1 = <THROW> | t1 = <TRIPLE> )
    <LPAREN> 
    { term =  astq.createFunction(t1.image); }
      exp1 = Expression(stack) { term.add(exp1); }
      (<COMMA> exp2 = Expression(stack) { term.add(exp2); } )* 
    <RPAREN>
    )

    | term = exists()
  )
  { return term; }
}


Term exists() : {Exp exp; Term term; boolean neg;}
{
	{neg = false;}
	       
        ( <NOT> {neg = true;} ) ?  
        <EXIST> exp = GroupGraphPattern()

	{
		term = astq.createExist(exp, neg);
		return term;
	}
}


Term FunctionCorese(Exp stack): { Token t; Term term = null; ExpressionList v; Constant cst; Exp sub; }
{	
  (
    term = IfThenElse(stack)
  | term = TryCatch(stack)
  | term = Let(stack)
  | term = Set(stack)
  | term = For(stack)
  | term = Lambda()
  | term = QueryExp()
  )

  { return term; }
}

Term QueryExp () : {Expression exp = null; Exp stack; Term term; Exp sub; Metadata meta = null;}
{
   <QUERY> <LPAREN>  
    meta = Annotate()
    (
    sub = SubQueryExp(meta) 
    |
    sub = SubConstruct(meta) { sub = BasicGraphPattern.create(sub); }
    |
    sub = SubUpdate(meta)    { sub = BasicGraphPattern.create(sub); }
    )
    (  <COMMA>
        { stack = BasicGraphPattern.create(); }
        exp = Expression(stack) 
    )?
    <RPAREN> { return astq.term(sub, exp); }
}


Term IfThenElse (Exp stack) : {Expression test, e1, e2 = null;}
{
    <IF> <LPAREN> test = Expression(stack)

    (
     <COMMA> e1 = Expression(stack) <COMMA> e2 = Expression(stack) <RPAREN>  
    |
     <RPAREN>
       e1 = Body(stack)
     (<ELSE> 
        (
            e2 = Body(stack)
          |
          e2 = IfThenElse (stack)
        )
     ) ?     
    )
    { return astq.ifThenElse(test, e1, e2); }
}


Term For (Exp stack) : 
{boolean isLoop = false; Exp sub; Term t; Expression exp, body ; Variable var = null; 
ExpressionList arg, el = null; Metadata meta = null;}
{
    (<FOR> | <LOOP> {isLoop = true;})
    <LPAREN> 
    (
        ( var = Var() 
        | 

            <LPAREN> { el = new ExpressionList();  }
                var = Var()  { el.add(var); } 
                ( (<COMMA>) ? var = Var()  { el.add(var); } ) *					
            <RPAREN>	    					     
        )

        <IN> 
        (
        exp = Expression(stack) 
        |
        exp = LetForExp()
        )

        |
        meta = Annotate()
        sub = SubQueryExp(meta)  { el = new ExpressionList(); exp = astq.term(sub); }
     )
    <RPAREN>   
    body = Body(stack)
    
    { return  astq.defineLoop(var, el, exp, body, isLoop); }
}


Expression LetForExp() : {Exp sub; Expression exp; Metadata meta = null;}
{
meta = Annotate()
(
    sub = SubQueryExp(meta) { exp = astq.term(sub); }
    |
    sub = ServiceExp()  { exp = astq.term(sub); }
    |
    sub = SubConstruct(meta) { exp = astq.term(BasicGraphPattern.create(sub)); }
    |
    sub = SubUpdate(meta)    { exp = astq.term(BasicGraphPattern.create(sub)); }
    | 
    <AT> exp = CstList() 

) 
{ return exp; }
}

Constant CstList() : {IDatatype dt; Constant list;}  {
    dt = ExpList()
    { return astq.createLDSList(dt); }
}

IDatatype ExpList() : { IDatatype dt; ArrayList<IDatatype> list; }
{
    { list = new ArrayList<IDatatype>() ;}
    <LPAREN> (
            (dt = ListTerm() | dt = ExpList()) 
            { list.add(dt); } )* 
    <RPAREN>
    { return DatatypeMap.createList(list); }

}

IDatatype ListTerm() : { String s; Token t1;  Atom a; }
{
  ( 	 
  	  s = Q_IRI_ref() { a = astq.createURI(s); }
  	| t1 = <QNAME>    { a = astq.createQName(t1.image);  }
  	| t1 = <QNAME_NS> { a = astq.createQName(t1.image); }
  	| a = RDFLiteral() 
  	| a = NumericLiteral()
  	| a = BooleanLiteral()     	
  )
  { return a.getDatatypeValue(); }
}

Term TryCatch(Exp stack) : {Variable var; Expression e1, e2;}
{
    <TRY> e1 = Body(stack)
    <CATCH> <LPAREN> var = Var() <RPAREN>
    e2 = Body(stack)
    { return astq.defTryCatch(e1, var, e2); }
}

Term Let (Exp stack) : 
{boolean dynamic = false; Expression exp ; Expression arg; ExpressionList list; }
{
        ( <LET> | <LETDYN> { dynamic = true; })
        <LPAREN> 
               { list = new ExpressionList(); }
               (
                arg = LetDef(stack)           { list.add(arg); }   
                ( <COMMA> arg = LetDef(stack) { list.add(arg); } )*   
               )
        <RPAREN>
        exp = Body(stack)
    
      { return astq.let(list, exp, dynamic); }
}

Term Set (Exp stack) : { Expression exp ; Variable var; boolean stat = false;}
{
        (<SET> | <STATIC> { stat = true;})
        <LPAREN> 
            var = Var()
            <EQ>
            exp = Expression(stack)            
        <RPAREN>
           
      { return astq.set(var, exp, stat); }
}


Expression LetDef(Exp stack) : 
{ Variable var = null;   Expression exp ; ExpressionList el = null; Exp sub; Constant type = null; Metadata meta = null;}
{
( 
  ( (type = IRIrefConst())? var = Var() 
    |    	       
    el = LetArgList()    
  )
  <EQ>
  (  
    exp = Expression(stack) 
    |
    exp = LetForExp()
  )

 |
  // let (select where)
  meta = Annotate()
  sub = SubQueryExp(meta) { el = new ExpressionList(); exp = astq.term(sub); }
)			
   { return (el == null) ? astq.defLet(var, type, exp) : astq.defLet(el, exp);  }
 
}

Term FunctionCall(Exp stack) : { Term term1;   ExpressionList v; Constant cst;}
{
  cst = IRIrefConst()
  v = ArgList(stack)
  { 
  	term1 = astq.createFunction(cst, v); 
  }
  { return term1; }
}

// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()

Expression IRIrefOrFunction(Exp stack) : {Expression exp;}
{
     exp = StdIRIrefOrFunction(stack) 
       
    { return exp;}
}

Expression StdIRIrefOrFunction(Exp stack) : { String s1; ExpressionList v; Term term; Expression expression;  Constant cst;}
{
  cst = IRIrefConst() {expression = cst;}
  ( LOOKAHEAD(2)
    v = ArgList(stack)
    { 
    	term = astq.createFunction(cst, v); 
	  	expression = term;
    } 
  )?
  { return expression; } 
}


Function Function(Metadata global, Metadata local) : 
{Exp stack; Token t = null; Function term;   ExpressionList v; Constant type, name=null; Expression body;}
{
  <FUNCTION>  type = IRIrefConst() (name = IRIrefConst())?
  { stack = BasicGraphPattern.create(); 
    handler.setMetadata(metadata(global, local)) ;
    handler.setFunction(true);
  }
  v = FunArgList()
  body = Body(stack)

  {     
        // type  is optional, name is mandatory
        if (name == null) {
            name = type;
            type = null;
        }
  	term = astq.defineFunction(name, type, v, body, metadata(global, local) ); 
        handler.cleanMetadata();
        handler.setFunction(false);
  }
  { return term; }
}

Function Lambda () : 
{Exp stack; Token t = null; Function term;   ExpressionList v; Constant cst; Expression body;}
{
  (<LAMBDA> | <FUNCTION>)
  { stack = BasicGraphPattern.create();     
  }
  v = LambdaArgList()
  body = Body(stack)

  { 
  	term = gast.defineLambda(v, body, handler.getMetadata()); 
  }
  { return term; }
}


ExpressionList FunArgList() : { ExpressionList list;  Variable var; Constant type; }
{  { list = new ExpressionList(); }          	 
  <LPAREN>   		  	 	  	
     (
	          { type = null; } (type = IRIrefConst()) ? var = Var() { list.add(var); list.defType(var, type); }		              
        ( <COMMA> { type = null; } (type = IRIrefConst()) ? var = Var() { list.add(var); list.defType(var, type); } )*
		    
    ) ?	  
  <RPAREN>    
  
  { return list; }
}


ExpressionList LambdaArgList() : { ExpressionList glist, list;  Variable var; Constant type; }
{
   <LPAREN> 		  	 	  	
    (                           
                  <LPAREN>  { glist = new ExpressionList(); } 
                            list = LambdaVarList()  { glist.add(list); } <RPAREN>
        ( <COMMA> <LPAREN>  list = LambdaVarList()  { glist.add(list); } <RPAREN> )*
        { list = glist; }

    | list = LambdaVarList() 
    )
   <RPAREN>

  { return list; }
}

ExpressionList LambdaVarList() : { ExpressionList list;  Variable var; }
{
    { list = new ExpressionList(); }  
    ( var = Var() { list.add(var);  }	 ( <COMMA>  var = Var() { list.add(var); } )*  ) ?
    { return list; }
}

ExpressionList LetArgList() : { ExpressionList glist, list;  Variable var; Constant type; }
{
   <LPAREN> 		  	 	  	
    ( 
                            list = VarList() 
    |  
                  <LPAREN>  { glist = new ExpressionList(); } 
                            list = VarList()  { glist.add(list); } <RPAREN>
        ( <COMMA> <LPAREN>  list = VarList()  { glist.add(list); } <RPAREN> )*

        { list = glist; }
    )
   <RPAREN>

  { return list; }
}



ExpressionList VarList() : { ExpressionList list; }
{
    { list = new ExpressionList(); } 
 
    (
    FstVar(list) (RstVar(list))? (LstVar(list))? 
    |
    RstVar(list) (LstVar(list))? 
    |
    LstVar(list)
    )

    { return list; }
}

ExpressionList FstVar(ExpressionList list) : {Variable var;}
{
    var = Var() { list.add(var);  } ( (<COMMA>)?  var = Var() { list.add(var); } )* 
    { return list; }
}

ExpressionList RstVar(ExpressionList list) : {Variable var;}
{
    <BAR>       var = Var() { list.add(var); list.setRest(true); } 
    { return list; }
}

ExpressionList LstVar(ExpressionList list) : {Variable var;}
{
    <DOT>       var = Var() { list.add(var); list.setLast(true); }  ( var = Var() { list.add(var);} )* 
    { return list; }
}


Metadata Annotate() : {Token t, v; Metadata list = null; Constant s; }
{
    ( { s = null; }

      (( t = <LANGTAG> | t = <ATPATH> )
            {if (list == null) { list = new Metadata(); } ; list.add(t.image); }
            (  
                (<STAR> { list.add(t.image, "*");}) 
                | 
                (
                    ((s = Constant() { list.add(t.image, s); } ) 
                      |
                     (v = <VAR3>     { list.add(t.image, v.image); })
                    )
                    *
                )   
            )
       )
    )*
 
    { return list; }
}

Expression Body(Exp stack) : { ExpressionList body = new ExpressionList(); Expression exp = null;}
{
 <LBRACE> ( <RBRACE> |        
        (exp = Expression(stack) | exp = TemplateExpression(stack)) { body.add(exp); } 
        ( LOOKAHEAD(2) <SEMICOLON> 
        (exp = Expression(stack) | exp = TemplateExpression(stack)) { body.add(exp); } ) *
          (<SEMICOLON>)?
            <RBRACE>
        ) 
    { return astq.defineBody(body) ; }
}

void Package(Metadata global) : { Function term; Metadata la; }
{
    (<PACKAGE>) ?       
    <LBRACE> 
        ( la = Annotate() term = Function(global, la) 
            //{ astq.annotate(term, list); } 
        ) +
    <RBRACE>
}


ExpressionList ArgList(Exp stack) : { ExpressionList v; Token t; Expression expression1; String str;}
{
  { 
  	// Vector containing either Expression or Variable
  	v = new ExpressionList();
  }
  
  ( 
       	 
  	<LPAREN> 
  	
	  	(<DISTINCT> {v.setDistinct(true);}) ? 
	  	
	  	(
		  	<STAR> 
		  	
		  	|
		   
		              expression1 = Arg(stack) { v.add(expression1); }
		              
		    ( <COMMA> expression1 = Arg(stack) { v.add(expression1); } )*
		    
	    ) ?
	    
    ( <SEMICOLON>  <SEPARATOR>  <EQ>  str = String() { v.setSeparator(str); } ) ?
    
    <RPAREN>
    
  )
  { return v; }
}


Expression Arg(Exp stack) : {Expression exp;}
{
	(
		exp = Expression(stack)  

	)
	{
		return exp;
	}
}






Expression BrackettedExpression(Exp stack) : { Expression expression1; }
{
	<LPAREN> expression1 = Expression(stack) <RPAREN>
	{ 
		return expression1; 
	}
}

Expression PrimaryExpression(Exp stack) : {Exp exp; Expression expression1; }
{
  ( 
     expression1 = BrackettedExpression(stack)	// Expression
   | expression1 = BuiltInCall(stack)		// Expression
   | expression1 = FunctionCorese(stack)	// Term
   | expression1 = Var()				// Variable
   | expression1 = RDFLiteral()			// Constant
   | expression1 = NumericLiteral()		// Constant
   | expression1 = BooleanLiteral()		// Constant
   | expression1 = BlankNode(stack) 			// Constant
   | expression1 = IRIrefOrFunction(stack)   // Expression
   | { exp = BasicGraphPattern.create() ;} 
     expression1 = StarTriple(exp)

   // NOT  |  VarOrTerm()        
   // Because of IRIrefOrFunction
  )
  { return expression1; }
}

Constant Constant() : { Constant c; } 
{
    (c = StringLiteral() | c = NumericLiteral() | c = BooleanLiteral() | c = IRIrefConst())
    { return c;}
}

Constant NumericLiteral() : { Token t; String datatype; }
{
   ( t = <INTEGER> { datatype = RDFS.qxsdInteger; } 
   | t = <DECIMAL> { datatype = RDFS.qxsdDecimal; } 
   | t = <DOUBLE>  { datatype = RDFS.qxsdDouble; } )
   { return astq.createConstant(t.image, datatype, null); }
}

Constant RDFLiteral() : { Constant res; String iriref, s, lang; Token t; }
{
  s = String()
  { iriref = null; lang=null; }
  (
    t = <LANGTAG> { lang = t.image.substring(1,t.image.length()); }
    | ( t = <DATATYPE> iriref = IRIref() )  
  )?
  { res = astq.createConstantWithDatatype(s, iriref, lang); }
  { return res; }
}

Constant StringLiteral() : { String s; }
{
  s = String()  
  { return Constant.createString(s); }
}

Constant BooleanLiteral() : { Token t1, t2; Constant cst; String iriref, lang;}
{
  ( t1 = <TRUE> | t1 = <FALSE> )  
  { iriref = RDFS.qxsdBoolean; lang=null; }
  
  { 
  	cst = astq.createConstant(t1.image.toLowerCase(), iriref, lang);
  	return cst; 
  } 
}

String String() : { Token t; }
{
  (  t = <STRING_LITERAL1>
  |  t = <STRING_LITERAL2>       
  |  t = <STRING_LITERAL_LONG1>
  |  t = <STRING_LITERAL_LONG2> 
  )
  {
    final String SQ3  = "\"\"\"";
    final String SSQ3 = "'''";

    String str = t.image;

    // remove leading/trailing " or '
    int start = 1, end = str.length() - 1;

    if ((str.startsWith(SQ3) && str.endsWith(SQ3))
      || (str.startsWith(SSQ3) && str.endsWith(SSQ3))) {
        // remove leading/trailing """ or '''
        start = 3;
        end = str.length() - 3;
    }

    str = str.substring(start, end);
    
    return handler.remEscapes(convertUnicodeSequences(str));
    }
}

String IRIref() : { String res; }
{
   ( res = Q_IRI_ref() 
   | res = QName() )
   { return res; }
}


Constant IRIrefConst() : { String res; Constant cst;}
{
   ( res = Q_IRI_ref() {cst = astq.createURI(res);}
   | res = QName()     {cst = astq.createQName(res);}
   )
   { return cst; }
}



String QName(): { Token t; }
{
  ( t = <QNAME> | t = <QNAME_NS> )
  { return t.image; }
}

Variable BlankNode(Exp stack): { Token t; Variable v; }
{
  ( 
 	t = <BLANK_NODE_LABEL> 
	{
 		// check if the blank node is already in the table
  		v = astq.newBlankNode(stack, t.image);
                handler.declareBlankNode(t);
		
  	}
  	| t = <ANON>   	
  	{ 
  		// create a new blank node
  		v = astq.newBlankNode(); 
                handler.declareBlankNode(t);
  	}
  )
  { 
  	return v; 
  }
}


String Q_IRI_ref() : { Token t; String s; }
{
    t = <Q_IRIref>
    { 
        s = t.image;
        s = s.substring(1,s.length()-1); // Remove "<" and ">"
        s = convertUnicodeSequences(s); // Convert Unicode escape sequences
        s = astq.defURI(s);
        return s; 
    }
}

// ------------------------------------------
// Tokens
// ------------------------------------------

TOKEN_MGR_DECLS:{
		
	void CommonTokenAction(Token token) {
		//System.out.println(token+" ");
	}
}

// Comments and whitespace

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN: { <#WS: " " | "\t" | "\n" | "\r" | "\f"> }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

// Main tokens */

TOKEN:
{
   // Includes # for relative URIs
   <Q_IRIref: "<" (~[">","<","\u0000"-"\u0020"])* ">" > 
   
| <QNAME_NS: (<NCNAME_PREFIX>)? ":" >

| <QNAME: (<NCNAME_PREFIX>)? ":" (["0"-"9"])* (<NCNAME>)? >

| <BLANK_NODE_LABEL:   "_:"   ( ["0"-"9"]  | <BLANKNAME> )   ( (<BLANKNAME> | ".")* <BLANKNAME> ) ?   >



| <VAR1: "?" <VARNAME> >
| <VAR2: "$" <VARNAME> >
| <ABASE:    "@base">
| <APREFIX:  "@prefix">
| <ATLIST:   "@list" >
| <ATPATH:   "@path" >
| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >	
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
}

// -------------------------------------------------
// Keyworks : includes operators that are words and should be
// before general things like IDENTIFIER which swallow almost
// anything

TOKEN : { 
	<KW_A: "a" > 
} // Before HEX rule!

TOKEN [IGNORE_CASE] :
{
// Prologue
  < BASE: "base" >
| < PREFIX: "prefix" >
// Result forms
| < SELECT: "select" >
| < DESCRIBE: "describe" >
| < CONSTRUCT: "construct" >
| < RULE: "rule" >
| < ASK: "ask" >
| < TEMPLATE: "template" >

| < DISTINCT: "distinct" >
| < SEPARATOR: "separator" >

| < REDUCED: "reduced" >
| < LIMIT: "limit" >
| < OFFSET: "offset" >
| < ORDER: "order" >
| < BY: "by" >
| < RELAX: "relax" >

| < ASC: "asc" >
| < DESC: "desc" >

// Dataset
| < NAMED: "named" >
| < FROM: "from" >

// Graph pattern operators 
| < WHERE: "where" >
| < GRAPH: "graph" >
| < SERVICE: "service" >
| < OPTIONAL: "optional" >
| < UNION: "union" >
| < MINUSP: "minus" >
| < NOT: "not">
| < SCOPE: "scope">
| < TRY: "try">
| < CATCH: "catch">
| < THROW: "throw">
| < STOP: "stop">
| < LET: "let">
| < LETDYN: "letdyn">
| < SET: "set">
| < STATIC: "static">
| < FOR: "for">
| < LOOP: "loop">
| < IF: "if">
| < THEN: "then">
| < ELSE: "else">
| < EXIST: "exists">
| < FILTER: "filter" >


// UPDATE

| < LOAD: "load">
| < CLEAR: "clear">
| < DROP: "drop">
| < CREATE: "create">
| < ADD: "add" >
| < TO: "to"> 
| < MOVE: "move">
| < COPY: "copy">
| < INSERT: "insert">
| < DELETE: "delete">
| < WITH: "with">
| < USING: "using">
| < DEFAUT: "default">
| < ALL: "all">
| < INTO: "into">
| < SILENT: "silent">
| < DATA: "data">

// LDScript
| <ERROR: "error">
| <RETURN: "return">
| <AGGREGATE: "aggregate">
| <UNNEST: "unnest">
| <MAP: "map">
| <MAPLIST: "maplist">
| <MAPFIND: "mapfind">
| <MAPFINDLIST: "mapfindlist">
| <MAPMERGE: "mapmerge">
| <MAPEVERY: "mapevery">
| <MAPANY: "mapany">
| <FUNCALL: "funcall">
| <EVAL: "eval">
| <METHOD: "method">
| <APPLY: "apply">
| <REDUCE: "reduce">
| <SELF: "self">

// Expression operators
| <BOUND: "bound" >
| <COALESCE: "coalesce">
| <SAMETERM: "sameTerm">
| <STR:     "str" >
| <STRDT:   "strdt" >
| <STRLANG:  "strlang" >
| <BNODE:  "bnode" >
| <URI:     "uri" >
| <IRI:     "iri" >
| <UUID: "uuid">
| <STRUUID: "struuid">
| <DTYPE:   "datatype" >
| <LANG:    "lang" >
| <LANGMATCHES: "langmatches" >
| <CONTAINS: "contains">
| <STRSTARTS: "strstarts">
| <STRENDS:     "strends">
| <STRLEN: "strlen">
| <SUBSTR: "substr">
| <UCASE: "ucase">
| <LCASE: "lcase">
| <STRBEFORE: "strbefore">
| <STRAFTER: "strafter">
| <ENCODE_FOR_URI: "encode_for_uri">
| <CONCAT:  "concat">
| <REPLACE: "replace">
| <IS_URI:  "isURI" >
| <IS_IRI:  "isIRI" >
| <IS_BLANK: "isBlank" >
| <IS_LITERAL: "isLiteral" >
| <IS_NUMERIC: "isNumeric">
| <IS_EXTENSION: "isExtension">
| <IS_SAFE: "safe">
| <IS_UNDEFINED: "isUndefined">
| <IS_WELLFORMED: "isWellFormed">

| <REGEX: "regex" >

| <RAND: "rand">
| <ROUND: "round">
| <FLOOR: "floor">
| <CEIL: "ceil">
| <POWER: "power">
| <ABS: "abs">

| <NOW: "now">
| <YEAR: "year">
| <MONTH: "month">
| <DAY: "day">
| <HOURS: "hours">
| <MINUTES: "minutes">
| <SECONDS: "seconds">
| <TIMEZONE: "timezone">
| <TZ: "tz">

| <MD5: "md5">
| <SHA1: "sha1">
| <SHA256: "sha256">
| <SHA384: "sha384">
| <SHA512: "sha512">

| <GROUP_CONCAT: "group_concat">
| <SUM: "sum">
| <SAMPLE: "sample">
| <AVG: "avg">
| <MIN: "min">
| <MAX: "max">


| <TRUE: "true" >
| <FALSE: "false" >
}

// -------------------------------------------------
// Rajouts pour CORESE
// -------------------------------------------------

TOKEN [IGNORE_CASE] :
{
  <S_MORE: "more" >
| <PRAGMA: "pragma" >
| <GROUP: "group" >
| <FORMAT: "format" >
| <BOX: "box" >
| <IBOX: "ibox" >
| <SBOX: "sbox" >
| <HAVING: "having" >
| <VALUES: "values"  >
| <BIND: "bind">
| <UNDEF: "undef">
| <COUNT: "count" >
| <SCORE: "score" >
| <AS: "as" >
| <SORTED: "sorted" >
| <ALL2: "all::" >
| <CURRENT: "current::" >
| <DIRECT2: "direct::" >
| <COLON2: "::" >
| <TUPLE: "tuple">
| <TRIPLE: "triple">
| <SUBJECT: "subject">
| <PREDICATE: "predicate">
| <OBJECT: "object">
| <IS_TRIPLE: "isTriple">
| <SPARQL_COMPARE: "sparql-compare">
| <XPATH: "xpath">
| <FUNCTION: "function">
| <LAMBDA: "lambda">
| <QUERY: "query">
| <PACKAGE: "package">
}

TOKEN [IGNORE_CASE] :
{
  <IN: "in">
}

TOKEN :
{
  <EQ2: "==">
| <NE2: "!==">
| <BEGIN_WITH: "^">
//| <STRICT_SPEC: "<:">
| <SPEC: "<=:">
| <SAME: "=:">
| <GENERALISATION: ">=:">
| <STRICT_GENERALISATION: ">:">
| <EQ_LANG: "~=">
}



// -------------------------------------------------

TOKEN :
{
   < INTEGER: (["-"])? <DIGITS> >
|
   < DECIMAL: (["-"])? (<DIGITS>)+ "." (<DIGITS>)* | "." (<DIGITS>)+ >
      // Required exponent.
| < DOUBLE:
      (["-"])?
      (   
        (["0"-"9"])+  "." (["0"-"9"])* <EXPONENT>
        | "." (["0"-"9"])+ <EXPONENT>
        | (["0"-"9"])+ <EXPONENT>
      )
      >

   // Optional exponent.
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">
| <ECHAR: "\\" ("t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'"| "U" (["0"-"9", "A"-"F", "a"-"f"]){8} | "u" (["0"-"9", "A"-"F", "a"-"f"]){4})>

| < STRING_LITERAL1:
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" >
      
| < STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >
      
| < STRING_LITERAL_LONG1:
     <QUOTE_3S>
      ( ( "'" | "''" ) ?     ( ~["'", "\\"] |  <ECHAR> ) )*
     <QUOTE_3S> >
     
| < STRING_LITERAL_LONG2:
     <QUOTE_3D>
      ( ( "\"" | "\"\"" ) ?  ( ~["\"", "\\"] |  <ECHAR> ) )*
     <QUOTE_3D> >    
          
 
  
     
     
| < DIGITS: (["0"-"9"])+>
| <HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >


| < LBRACE: "{" >
| < RBRACE: "}" >

| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < ANON: <LBRACKET> (<WS>)* <RBRACKET> >

| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Operator

TOKEN :
{
  < EQ: "=" >
| < NE: "!=" >
| < LTLT: "<<">
| < GTGT: ">>">
| < LT: "<" >
| < GT: ">" >
| < LE: "<=" > 
| < GE: ">=" > 

| < BANG: "!" >
| <TILDE: "~">
| < COLON: ":" >

| < SC_OR: "||" >
| < SC_AND: "&&" >

| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < QM: "?" >
| < BAR: "|" >

| < DATATYPE: "^^">
| < AT: "@">
| <VAR3: <VARNAME> >

}

// See XML chars.txt for notes

TOKEN:
{
  // XML 1.1 NCNameStartChar without "_"
  <#NCCHAR1p:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFDCF"] | ["\uFDF0"-"\uFFFD"] >
          //["\u10000"-"\uEFFFF"] >
|
  <#NCCHAR1: <NCCHAR1p> | "_" >

// No trailing DOTs in qnames.
|
  // #NCCHAR without "."
  <#NCCHAR: (<NCCHAR1> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  // NCNAME but no leading "_", no trailing ".", can have dot inside prefix name.
  <#NCNAME_PREFIX: <NCCHAR1p> ((<NCCHAR> | "."   )* <NCCHAR>)? >
|
  // With a leading "_", no dot at end of local name.
    
    <#NCNAME:  <NCCHAR1>   ((<NCCHAR> | "." | ":" | "_" | <LOCAL_ESC> | <PERCENT> )*     (<NCCHAR> | ":" | <LOCAL_ESC> | <PERCENT> ))? > 
|


    <#BLANKNAME:  <NCCHAR1>   ((<NCCHAR> | "." |  "_"  )*     (<NCCHAR>) )? > 


|
  // NCNAME without "-" and ".", allowing leading digits.
  <#VARNAME: ( <NCCHAR1> | ["0"-"9"] )
             ( <NCCHAR1> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
               
               
| <#LOCAL_ESC:  "\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "\"" | "(" | ")" | "*" | "+" | "," | ";" | "=" |  "/" | "?" | "#" | "@" | "%" )  >



| <#PERCENT: "%" <HEX> <HEX> >

}

/*
 * (c) Copyright 2004, 2005 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
